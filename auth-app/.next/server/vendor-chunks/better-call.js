"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/better-call";
exports.ids = ["vendor-chunks/better-call"];
exports.modules = {

/***/ "(rsc)/./node_modules/better-call/dist/index.js":
/*!************************************************!*\
  !*** ./node_modules/better-call/dist/index.js ***!
  \************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   APIError: () => (/* binding */ APIError),\n/* harmony export */   BetterCallError: () => (/* binding */ BetterCallError),\n/* harmony export */   createEndpoint: () => (/* binding */ createEndpoint),\n/* harmony export */   createInternalContext: () => (/* binding */ createInternalContext),\n/* harmony export */   createMiddleware: () => (/* binding */ createMiddleware),\n/* harmony export */   createRouter: () => (/* binding */ createRouter),\n/* harmony export */   generator: () => (/* binding */ generator),\n/* harmony export */   getCookieKey: () => (/* binding */ getCookieKey),\n/* harmony export */   getHTML: () => (/* binding */ getHTML),\n/* harmony export */   hideInternalStackFrames: () => (/* binding */ hideInternalStackFrames),\n/* harmony export */   makeErrorForHideStackFrame: () => (/* binding */ makeErrorForHideStackFrame),\n/* harmony export */   parseCookies: () => (/* binding */ parseCookies),\n/* harmony export */   serializeCookie: () => (/* binding */ serializeCookie),\n/* harmony export */   serializeSignedCookie: () => (/* binding */ serializeSignedCookie),\n/* harmony export */   statusCodes: () => (/* binding */ statusCodes),\n/* harmony export */   toResponse: () => (/* binding */ toResponse)\n/* harmony export */ });\n/* harmony import */ var _better_auth_utils__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @better-auth/utils */ \"(rsc)/./node_modules/@better-auth/utils/dist/index.mjs\");\n/* harmony import */ var rou3__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! rou3 */ \"(rsc)/./node_modules/rou3/dist/index.mjs\");\n\n\n\n//#region src/error.ts\nfunction isErrorStackTraceLimitWritable() {\n\tconst desc = Object.getOwnPropertyDescriptor(Error, \"stackTraceLimit\");\n\tif (desc === void 0) return Object.isExtensible(Error);\n\treturn Object.prototype.hasOwnProperty.call(desc, \"writable\") ? desc.writable : desc.set !== void 0;\n}\n/**\n* Hide internal stack frames from the error stack trace.\n*/\nfunction hideInternalStackFrames(stack) {\n\tconst lines = stack.split(\"\\n    at \");\n\tif (lines.length <= 1) return stack;\n\tlines.splice(1, 1);\n\treturn lines.join(\"\\n    at \");\n}\n/**\n* Creates a custom error class that hides stack frames.\n*/\nfunction makeErrorForHideStackFrame(Base, clazz) {\n\tclass HideStackFramesError extends Base {\n\t\t#hiddenStack;\n\t\tconstructor(...args) {\n\t\t\tif (isErrorStackTraceLimitWritable()) {\n\t\t\t\tconst limit = Error.stackTraceLimit;\n\t\t\t\tError.stackTraceLimit = 0;\n\t\t\t\tsuper(...args);\n\t\t\t\tError.stackTraceLimit = limit;\n\t\t\t} else super(...args);\n\t\t\tconst stack = (/* @__PURE__ */ new Error()).stack;\n\t\t\tif (stack) this.#hiddenStack = hideInternalStackFrames(stack.replace(/^Error/, this.name));\n\t\t}\n\t\tget errorStack() {\n\t\t\treturn this.#hiddenStack;\n\t\t}\n\t}\n\tObject.defineProperty(HideStackFramesError.prototype, \"constructor\", {\n\t\tget() {\n\t\t\treturn clazz;\n\t\t},\n\t\tenumerable: false,\n\t\tconfigurable: true\n\t});\n\treturn HideStackFramesError;\n}\nconst statusCodes = {\n\tOK: 200,\n\tCREATED: 201,\n\tACCEPTED: 202,\n\tNO_CONTENT: 204,\n\tMULTIPLE_CHOICES: 300,\n\tMOVED_PERMANENTLY: 301,\n\tFOUND: 302,\n\tSEE_OTHER: 303,\n\tNOT_MODIFIED: 304,\n\tTEMPORARY_REDIRECT: 307,\n\tBAD_REQUEST: 400,\n\tUNAUTHORIZED: 401,\n\tPAYMENT_REQUIRED: 402,\n\tFORBIDDEN: 403,\n\tNOT_FOUND: 404,\n\tMETHOD_NOT_ALLOWED: 405,\n\tNOT_ACCEPTABLE: 406,\n\tPROXY_AUTHENTICATION_REQUIRED: 407,\n\tREQUEST_TIMEOUT: 408,\n\tCONFLICT: 409,\n\tGONE: 410,\n\tLENGTH_REQUIRED: 411,\n\tPRECONDITION_FAILED: 412,\n\tPAYLOAD_TOO_LARGE: 413,\n\tURI_TOO_LONG: 414,\n\tUNSUPPORTED_MEDIA_TYPE: 415,\n\tRANGE_NOT_SATISFIABLE: 416,\n\tEXPECTATION_FAILED: 417,\n\t\"I'M_A_TEAPOT\": 418,\n\tMISDIRECTED_REQUEST: 421,\n\tUNPROCESSABLE_ENTITY: 422,\n\tLOCKED: 423,\n\tFAILED_DEPENDENCY: 424,\n\tTOO_EARLY: 425,\n\tUPGRADE_REQUIRED: 426,\n\tPRECONDITION_REQUIRED: 428,\n\tTOO_MANY_REQUESTS: 429,\n\tREQUEST_HEADER_FIELDS_TOO_LARGE: 431,\n\tUNAVAILABLE_FOR_LEGAL_REASONS: 451,\n\tINTERNAL_SERVER_ERROR: 500,\n\tNOT_IMPLEMENTED: 501,\n\tBAD_GATEWAY: 502,\n\tSERVICE_UNAVAILABLE: 503,\n\tGATEWAY_TIMEOUT: 504,\n\tHTTP_VERSION_NOT_SUPPORTED: 505,\n\tVARIANT_ALSO_NEGOTIATES: 506,\n\tINSUFFICIENT_STORAGE: 507,\n\tLOOP_DETECTED: 508,\n\tNOT_EXTENDED: 510,\n\tNETWORK_AUTHENTICATION_REQUIRED: 511\n};\nvar InternalAPIError = class extends Error {\n\tconstructor(status = \"INTERNAL_SERVER_ERROR\", body = void 0, headers = {}, statusCode = typeof status === \"number\" ? status : statusCodes[status]) {\n\t\tsuper(body?.message, body?.cause ? { cause: body.cause } : void 0);\n\t\tthis.status = status;\n\t\tthis.body = body;\n\t\tthis.headers = headers;\n\t\tthis.statusCode = statusCode;\n\t\tthis.name = \"APIError\";\n\t\tthis.status = status;\n\t\tthis.headers = headers;\n\t\tthis.statusCode = statusCode;\n\t\tthis.body = body ? {\n\t\t\tcode: body?.message?.toUpperCase().replace(/ /g, \"_\").replace(/[^A-Z0-9_]/g, \"\"),\n\t\t\t...body\n\t\t} : void 0;\n\t}\n};\nvar BetterCallError = class extends Error {\n\tconstructor(message) {\n\t\tsuper(message);\n\t\tthis.name = \"BetterCallError\";\n\t}\n};\nconst APIError = makeErrorForHideStackFrame(InternalAPIError, Error);\n\n//#endregion\n//#region src/utils.ts\nasync function getBody(request, allowedMediaTypes) {\n\tconst contentType = request.headers.get(\"content-type\") || \"\";\n\tconst normalizedContentType = contentType.toLowerCase();\n\tif (!request.body) return;\n\tif (allowedMediaTypes && allowedMediaTypes.length > 0) {\n\t\tif (!allowedMediaTypes.some((allowed) => {\n\t\t\tconst normalizedContentTypeBase = normalizedContentType.split(\";\")[0].trim();\n\t\t\tconst normalizedAllowed = allowed.toLowerCase().trim();\n\t\t\treturn normalizedContentTypeBase === normalizedAllowed || normalizedContentTypeBase.includes(normalizedAllowed);\n\t\t})) {\n\t\t\tif (!normalizedContentType) throw new APIError(415, {\n\t\t\t\tmessage: `Content-Type is required. Allowed types: ${allowedMediaTypes.join(\", \")}`,\n\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\"\n\t\t\t});\n\t\t\tthrow new APIError(415, {\n\t\t\t\tmessage: `Content-Type \"${contentType}\" is not allowed. Allowed types: ${allowedMediaTypes.join(\", \")}`,\n\t\t\t\tcode: \"UNSUPPORTED_MEDIA_TYPE\"\n\t\t\t});\n\t\t}\n\t}\n\tif (normalizedContentType.includes(\"application/json\")) return await request.json();\n\tif (normalizedContentType.includes(\"application/x-www-form-urlencoded\")) {\n\t\tconst formData = await request.formData();\n\t\tconst result = {};\n\t\tformData.forEach((value, key) => {\n\t\t\tresult[key] = value.toString();\n\t\t});\n\t\treturn result;\n\t}\n\tif (normalizedContentType.includes(\"multipart/form-data\")) {\n\t\tconst formData = await request.formData();\n\t\tconst result = {};\n\t\tformData.forEach((value, key) => {\n\t\t\tresult[key] = value;\n\t\t});\n\t\treturn result;\n\t}\n\tif (normalizedContentType.includes(\"text/plain\")) return await request.text();\n\tif (normalizedContentType.includes(\"application/octet-stream\")) return await request.arrayBuffer();\n\tif (normalizedContentType.includes(\"application/pdf\") || normalizedContentType.includes(\"image/\") || normalizedContentType.includes(\"video/\")) return await request.blob();\n\tif (normalizedContentType.includes(\"application/stream\") || request.body instanceof ReadableStream) return request.body;\n\treturn await request.text();\n}\nfunction isAPIError(error) {\n\treturn error instanceof APIError || error?.name === \"APIError\";\n}\nfunction tryDecode(str) {\n\ttry {\n\t\treturn str.includes(\"%\") ? decodeURIComponent(str) : str;\n\t} catch {\n\t\treturn str;\n\t}\n}\n\n//#endregion\n//#region src/to-response.ts\nfunction isJSONSerializable(value) {\n\tif (value === void 0) return false;\n\tconst t = typeof value;\n\tif (t === \"string\" || t === \"number\" || t === \"boolean\" || t === null) return true;\n\tif (t !== \"object\") return false;\n\tif (Array.isArray(value)) return true;\n\tif (value.buffer) return false;\n\treturn value.constructor && value.constructor.name === \"Object\" || typeof value.toJSON === \"function\";\n}\nfunction safeStringify(obj, replacer, space) {\n\tlet id = 0;\n\tconst seen = /* @__PURE__ */ new WeakMap();\n\tconst safeReplacer = (key, value) => {\n\t\tif (typeof value === \"bigint\") return value.toString();\n\t\tif (typeof value === \"object\" && value !== null) {\n\t\t\tif (seen.has(value)) return `[Circular ref-${seen.get(value)}]`;\n\t\t\tseen.set(value, id++);\n\t\t}\n\t\tif (replacer) return replacer(key, value);\n\t\treturn value;\n\t};\n\treturn JSON.stringify(obj, safeReplacer, space);\n}\nfunction isJSONResponse(value) {\n\tif (!value || typeof value !== \"object\") return false;\n\treturn \"_flag\" in value && value._flag === \"json\";\n}\nfunction toResponse(data, init) {\n\tif (data instanceof Response) {\n\t\tif (init?.headers instanceof Headers) init.headers.forEach((value, key) => {\n\t\t\tdata.headers.set(key, value);\n\t\t});\n\t\treturn data;\n\t}\n\tif (isJSONResponse(data)) {\n\t\tconst body$1 = data.body;\n\t\tconst routerResponse = data.routerResponse;\n\t\tif (routerResponse instanceof Response) return routerResponse;\n\t\tconst headers$1 = new Headers();\n\t\tif (routerResponse?.headers) {\n\t\t\tconst headers$2 = new Headers(routerResponse.headers);\n\t\t\tfor (const [key, value] of headers$2.entries()) headers$2.set(key, value);\n\t\t}\n\t\tif (data.headers) for (const [key, value] of new Headers(data.headers).entries()) headers$1.set(key, value);\n\t\tif (init?.headers) for (const [key, value] of new Headers(init.headers).entries()) headers$1.set(key, value);\n\t\theaders$1.set(\"Content-Type\", \"application/json\");\n\t\treturn new Response(JSON.stringify(body$1), {\n\t\t\t...routerResponse,\n\t\t\theaders: headers$1,\n\t\t\tstatus: data.status ?? init?.status ?? routerResponse?.status,\n\t\t\tstatusText: init?.statusText ?? routerResponse?.statusText\n\t\t});\n\t}\n\tif (isAPIError(data)) return toResponse(data.body, {\n\t\tstatus: init?.status ?? data.statusCode,\n\t\tstatusText: data.status.toString(),\n\t\theaders: init?.headers || data.headers\n\t});\n\tlet body = data;\n\tlet headers = new Headers(init?.headers);\n\tif (!data) {\n\t\tif (data === null) body = JSON.stringify(null);\n\t\theaders.set(\"content-type\", \"application/json\");\n\t} else if (typeof data === \"string\") {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", \"text/plain\");\n\t} else if (data instanceof ArrayBuffer || ArrayBuffer.isView(data)) {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", \"application/octet-stream\");\n\t} else if (data instanceof Blob) {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", data.type || \"application/octet-stream\");\n\t} else if (data instanceof FormData) body = data;\n\telse if (data instanceof URLSearchParams) {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", \"application/x-www-form-urlencoded\");\n\t} else if (data instanceof ReadableStream) {\n\t\tbody = data;\n\t\theaders.set(\"Content-Type\", \"application/octet-stream\");\n\t} else if (isJSONSerializable(data)) {\n\t\tbody = safeStringify(data);\n\t\theaders.set(\"Content-Type\", \"application/json\");\n\t}\n\treturn new Response(body, {\n\t\t...init,\n\t\theaders\n\t});\n}\n\n//#endregion\n//#region src/validator.ts\n/**\n* Runs validation on body and query\n* @returns error and data object\n*/\nasync function runValidation(options, context = {}) {\n\tlet request = {\n\t\tbody: context.body,\n\t\tquery: context.query\n\t};\n\tif (options.body) {\n\t\tconst result = await options.body[\"~standard\"].validate(context.body);\n\t\tif (result.issues) return {\n\t\t\tdata: null,\n\t\t\terror: fromError(result.issues, \"body\")\n\t\t};\n\t\trequest.body = result.value;\n\t}\n\tif (options.query) {\n\t\tconst result = await options.query[\"~standard\"].validate(context.query);\n\t\tif (result.issues) return {\n\t\t\tdata: null,\n\t\t\terror: fromError(result.issues, \"query\")\n\t\t};\n\t\trequest.query = result.value;\n\t}\n\tif (options.requireHeaders && !context.headers) return {\n\t\tdata: null,\n\t\terror: { message: \"Headers is required\" }\n\t};\n\tif (options.requireRequest && !context.request) return {\n\t\tdata: null,\n\t\terror: { message: \"Request is required\" }\n\t};\n\treturn {\n\t\tdata: request,\n\t\terror: null\n\t};\n}\nfunction fromError(error, validating) {\n\tconst errorMessages = [];\n\tfor (const issue$1 of error) {\n\t\tconst message = issue$1.message;\n\t\terrorMessages.push(message);\n\t}\n\treturn { message: `Invalid ${validating} parameters` };\n}\n\n//#endregion\n//#region src/crypto.ts\nconst algorithm = {\n\tname: \"HMAC\",\n\thash: \"SHA-256\"\n};\nconst getCryptoKey = async (secret) => {\n\tconst secretBuf = typeof secret === \"string\" ? new TextEncoder().encode(secret) : secret;\n\treturn await (0,_better_auth_utils__WEBPACK_IMPORTED_MODULE_0__.getWebcryptoSubtle)().importKey(\"raw\", secretBuf, algorithm, false, [\"sign\", \"verify\"]);\n};\nconst verifySignature = async (base64Signature, value, secret) => {\n\ttry {\n\t\tconst signatureBinStr = atob(base64Signature);\n\t\tconst signature = new Uint8Array(signatureBinStr.length);\n\t\tfor (let i = 0, len = signatureBinStr.length; i < len; i++) signature[i] = signatureBinStr.charCodeAt(i);\n\t\treturn await (0,_better_auth_utils__WEBPACK_IMPORTED_MODULE_0__.getWebcryptoSubtle)().verify(algorithm, secret, signature, new TextEncoder().encode(value));\n\t} catch (e) {\n\t\treturn false;\n\t}\n};\nconst makeSignature = async (value, secret) => {\n\tconst key = await getCryptoKey(secret);\n\tconst signature = await (0,_better_auth_utils__WEBPACK_IMPORTED_MODULE_0__.getWebcryptoSubtle)().sign(algorithm.name, key, new TextEncoder().encode(value));\n\treturn btoa(String.fromCharCode(...new Uint8Array(signature)));\n};\nconst signCookieValue = async (value, secret) => {\n\tconst signature = await makeSignature(value, secret);\n\tvalue = `${value}.${signature}`;\n\tvalue = encodeURIComponent(value);\n\treturn value;\n};\n\n//#endregion\n//#region src/cookies.ts\nconst getCookieKey = (key, prefix) => {\n\tlet finalKey = key;\n\tif (prefix) if (prefix === \"secure\") finalKey = \"__Secure-\" + key;\n\telse if (prefix === \"host\") finalKey = \"__Host-\" + key;\n\telse return;\n\treturn finalKey;\n};\n/**\n* Parse an HTTP Cookie header string and returning an object of all cookie\n* name-value pairs.\n*\n* Inspired by https://github.com/unjs/cookie-es/blob/main/src/cookie/parse.ts\n*\n* @param str the string representing a `Cookie` header value\n*/\nfunction parseCookies(str) {\n\tif (typeof str !== \"string\") throw new TypeError(\"argument str must be a string\");\n\tconst cookies = /* @__PURE__ */ new Map();\n\tlet index = 0;\n\twhile (index < str.length) {\n\t\tconst eqIdx = str.indexOf(\"=\", index);\n\t\tif (eqIdx === -1) break;\n\t\tlet endIdx = str.indexOf(\";\", index);\n\t\tif (endIdx === -1) endIdx = str.length;\n\t\telse if (endIdx < eqIdx) {\n\t\t\tindex = str.lastIndexOf(\";\", eqIdx - 1) + 1;\n\t\t\tcontinue;\n\t\t}\n\t\tconst key = str.slice(index, eqIdx).trim();\n\t\tif (!cookies.has(key)) {\n\t\t\tlet val = str.slice(eqIdx + 1, endIdx).trim();\n\t\t\tif (val.codePointAt(0) === 34) val = val.slice(1, -1);\n\t\t\tcookies.set(key, tryDecode(val));\n\t\t}\n\t\tindex = endIdx + 1;\n\t}\n\treturn cookies;\n}\nconst _serialize = (key, value, opt = {}) => {\n\tlet cookie;\n\tif (opt?.prefix === \"secure\") cookie = `${`__Secure-${key}`}=${value}`;\n\telse if (opt?.prefix === \"host\") cookie = `${`__Host-${key}`}=${value}`;\n\telse cookie = `${key}=${value}`;\n\tif (key.startsWith(\"__Secure-\") && !opt.secure) opt.secure = true;\n\tif (key.startsWith(\"__Host-\")) {\n\t\tif (!opt.secure) opt.secure = true;\n\t\tif (opt.path !== \"/\") opt.path = \"/\";\n\t\tif (opt.domain) opt.domain = void 0;\n\t}\n\tif (opt && typeof opt.maxAge === \"number\" && opt.maxAge >= 0) {\n\t\tif (opt.maxAge > 3456e4) throw new Error(\"Cookies Max-Age SHOULD NOT be greater than 400 days (34560000 seconds) in duration.\");\n\t\tcookie += `; Max-Age=${Math.floor(opt.maxAge)}`;\n\t}\n\tif (opt.domain && opt.prefix !== \"host\") cookie += `; Domain=${opt.domain}`;\n\tif (opt.path) cookie += `; Path=${opt.path}`;\n\tif (opt.expires) {\n\t\tif (opt.expires.getTime() - Date.now() > 3456e7) throw new Error(\"Cookies Expires SHOULD NOT be greater than 400 days (34560000 seconds) in the future.\");\n\t\tcookie += `; Expires=${opt.expires.toUTCString()}`;\n\t}\n\tif (opt.httpOnly) cookie += \"; HttpOnly\";\n\tif (opt.secure) cookie += \"; Secure\";\n\tif (opt.sameSite) cookie += `; SameSite=${opt.sameSite.charAt(0).toUpperCase() + opt.sameSite.slice(1)}`;\n\tif (opt.partitioned) {\n\t\tif (!opt.secure) opt.secure = true;\n\t\tcookie += \"; Partitioned\";\n\t}\n\treturn cookie;\n};\nconst serializeCookie = (key, value, opt) => {\n\tvalue = encodeURIComponent(value);\n\treturn _serialize(key, value, opt);\n};\nconst serializeSignedCookie = async (key, value, secret, opt) => {\n\tvalue = await signCookieValue(value, secret);\n\treturn _serialize(key, value, opt);\n};\n\n//#endregion\n//#region src/context.ts\nconst createInternalContext = async (context, { options, path }) => {\n\tconst headers = new Headers();\n\tlet responseStatus = void 0;\n\tconst { data, error } = await runValidation(options, context);\n\tif (error) throw new APIError(400, {\n\t\tmessage: error.message,\n\t\tcode: \"VALIDATION_ERROR\"\n\t});\n\tconst requestHeaders = \"headers\" in context ? context.headers instanceof Headers ? context.headers : new Headers(context.headers) : \"request\" in context && context.request instanceof Request ? context.request.headers : null;\n\tconst requestCookies = requestHeaders?.get(\"cookie\");\n\tconst parsedCookies = requestCookies ? parseCookies(requestCookies) : void 0;\n\tconst internalContext = {\n\t\t...context,\n\t\tbody: data.body,\n\t\tquery: data.query,\n\t\tpath: context.path || path || \"virtual:\",\n\t\tcontext: \"context\" in context && context.context ? context.context : {},\n\t\treturned: void 0,\n\t\theaders: context?.headers,\n\t\trequest: context?.request,\n\t\tparams: \"params\" in context ? context.params : void 0,\n\t\tmethod: context.method,\n\t\tsetHeader: (key, value) => {\n\t\t\theaders.set(key, value);\n\t\t},\n\t\tgetHeader: (key) => {\n\t\t\tif (!requestHeaders) return null;\n\t\t\treturn requestHeaders.get(key);\n\t\t},\n\t\tgetCookie: (key, prefix) => {\n\t\t\tconst finalKey = getCookieKey(key, prefix);\n\t\t\tif (!finalKey) return null;\n\t\t\treturn parsedCookies?.get(finalKey) || null;\n\t\t},\n\t\tgetSignedCookie: async (key, secret, prefix) => {\n\t\t\tconst finalKey = getCookieKey(key, prefix);\n\t\t\tif (!finalKey) return null;\n\t\t\tconst value = parsedCookies?.get(finalKey);\n\t\t\tif (!value) return null;\n\t\t\tconst signatureStartPos = value.lastIndexOf(\".\");\n\t\t\tif (signatureStartPos < 1) return null;\n\t\t\tconst signedValue = value.substring(0, signatureStartPos);\n\t\t\tconst signature = value.substring(signatureStartPos + 1);\n\t\t\tif (signature.length !== 44 || !signature.endsWith(\"=\")) return null;\n\t\t\treturn await verifySignature(signature, signedValue, await getCryptoKey(secret)) ? signedValue : false;\n\t\t},\n\t\tsetCookie: (key, value, options$1) => {\n\t\t\tconst cookie = serializeCookie(key, value, options$1);\n\t\t\theaders.append(\"set-cookie\", cookie);\n\t\t\treturn cookie;\n\t\t},\n\t\tsetSignedCookie: async (key, value, secret, options$1) => {\n\t\t\tconst cookie = await serializeSignedCookie(key, value, secret, options$1);\n\t\t\theaders.append(\"set-cookie\", cookie);\n\t\t\treturn cookie;\n\t\t},\n\t\tredirect: (url) => {\n\t\t\theaders.set(\"location\", url);\n\t\t\treturn new APIError(\"FOUND\", void 0, headers);\n\t\t},\n\t\terror: (status, body, headers$1) => {\n\t\t\treturn new APIError(status, body, headers$1);\n\t\t},\n\t\tsetStatus: (status) => {\n\t\t\tresponseStatus = status;\n\t\t},\n\t\tjson: (json, routerResponse) => {\n\t\t\tif (!context.asResponse) return json;\n\t\t\treturn {\n\t\t\t\tbody: routerResponse?.body || json,\n\t\t\t\trouterResponse,\n\t\t\t\t_flag: \"json\"\n\t\t\t};\n\t\t},\n\t\tresponseHeaders: headers,\n\t\tget responseStatus() {\n\t\t\treturn responseStatus;\n\t\t}\n\t};\n\tfor (const middleware of options.use || []) {\n\t\tconst response = await middleware({\n\t\t\t...internalContext,\n\t\t\treturnHeaders: true,\n\t\t\tasResponse: false\n\t\t});\n\t\tif (response.response) Object.assign(internalContext.context, response.response);\n\t\t/**\n\t\t* Apply headers from the middleware to the endpoint headers\n\t\t*/\n\t\tif (response.headers) response.headers.forEach((value, key) => {\n\t\t\tinternalContext.responseHeaders.set(key, value);\n\t\t});\n\t}\n\treturn internalContext;\n};\n\n//#endregion\n//#region src/endpoint.ts\nfunction createEndpoint(pathOrOptions, handlerOrOptions, handlerOrNever) {\n\tconst path = typeof pathOrOptions === \"string\" ? pathOrOptions : void 0;\n\tconst options = typeof handlerOrOptions === \"object\" ? handlerOrOptions : pathOrOptions;\n\tconst handler = typeof handlerOrOptions === \"function\" ? handlerOrOptions : handlerOrNever;\n\tif ((options.method === \"GET\" || options.method === \"HEAD\") && options.body) throw new BetterCallError(\"Body is not allowed with GET or HEAD methods\");\n\tconst internalHandler = async (...inputCtx) => {\n\t\tconst context = inputCtx[0] || {};\n\t\tconst internalContext = await createInternalContext(context, {\n\t\t\toptions,\n\t\t\tpath\n\t\t});\n\t\tconst response = await handler(internalContext).catch(async (e) => {\n\t\t\tif (isAPIError(e)) {\n\t\t\t\tconst onAPIError = options.onAPIError;\n\t\t\t\tif (onAPIError) await onAPIError(e);\n\t\t\t\tif (context.asResponse) return e;\n\t\t\t}\n\t\t\tthrow e;\n\t\t});\n\t\tconst headers = internalContext.responseHeaders;\n\t\tconst status = internalContext.responseStatus;\n\t\treturn context.asResponse ? toResponse(response, {\n\t\t\theaders,\n\t\t\tstatus\n\t\t}) : context.returnHeaders ? context.returnStatus ? {\n\t\t\theaders,\n\t\t\tresponse,\n\t\t\tstatus\n\t\t} : {\n\t\t\theaders,\n\t\t\tresponse\n\t\t} : context.returnStatus ? {\n\t\t\tresponse,\n\t\t\tstatus\n\t\t} : response;\n\t};\n\tinternalHandler.options = options;\n\tinternalHandler.path = path;\n\treturn internalHandler;\n}\ncreateEndpoint.create = (opts) => {\n\treturn (path, options, handler) => {\n\t\treturn createEndpoint(path, {\n\t\t\t...options,\n\t\t\tuse: [...options?.use || [], ...opts?.use || []]\n\t\t}, handler);\n\t};\n};\n\n//#endregion\n//#region src/middleware.ts\nfunction createMiddleware(optionsOrHandler, handler) {\n\tconst internalHandler = async (inputCtx) => {\n\t\tconst context = inputCtx;\n\t\tconst _handler = typeof optionsOrHandler === \"function\" ? optionsOrHandler : handler;\n\t\tconst internalContext = await createInternalContext(context, {\n\t\t\toptions: typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler,\n\t\t\tpath: \"/\"\n\t\t});\n\t\tif (!_handler) throw new Error(\"handler must be defined\");\n\t\tconst response = await _handler(internalContext);\n\t\tconst headers = internalContext.responseHeaders;\n\t\treturn context.returnHeaders ? {\n\t\t\theaders,\n\t\t\tresponse\n\t\t} : response;\n\t};\n\tinternalHandler.options = typeof optionsOrHandler === \"function\" ? {} : optionsOrHandler;\n\treturn internalHandler;\n}\ncreateMiddleware.create = (opts) => {\n\tfunction fn(optionsOrHandler, handler) {\n\t\tif (typeof optionsOrHandler === \"function\") return createMiddleware({ use: opts?.use }, optionsOrHandler);\n\t\tif (!handler) throw new Error(\"Middleware handler is required\");\n\t\treturn createMiddleware({\n\t\t\t...optionsOrHandler,\n\t\t\tmethod: \"*\",\n\t\t\tuse: [...opts?.use || [], ...optionsOrHandler.use || []]\n\t\t}, handler);\n\t}\n\treturn fn;\n};\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/core.js\n/** A special constant with type `never` */\nconst NEVER = Object.freeze({ status: \"aborted\" });\nfunction $constructor(name, initializer$2, params) {\n\tfunction init(inst, def) {\n\t\tvar _a;\n\t\tObject.defineProperty(inst, \"_zod\", {\n\t\t\tvalue: inst._zod ?? {},\n\t\t\tenumerable: false\n\t\t});\n\t\t(_a = inst._zod).traits ?? (_a.traits = /* @__PURE__ */ new Set());\n\t\tinst._zod.traits.add(name);\n\t\tinitializer$2(inst, def);\n\t\tfor (const k in _.prototype) if (!(k in inst)) Object.defineProperty(inst, k, { value: _.prototype[k].bind(inst) });\n\t\tinst._zod.constr = _;\n\t\tinst._zod.def = def;\n\t}\n\tconst Parent = params?.Parent ?? Object;\n\tclass Definition extends Parent {}\n\tObject.defineProperty(Definition, \"name\", { value: name });\n\tfunction _(def) {\n\t\tvar _a;\n\t\tconst inst = params?.Parent ? new Definition() : this;\n\t\tinit(inst, def);\n\t\t(_a = inst._zod).deferred ?? (_a.deferred = []);\n\t\tfor (const fn of inst._zod.deferred) fn();\n\t\treturn inst;\n\t}\n\tObject.defineProperty(_, \"init\", { value: init });\n\tObject.defineProperty(_, Symbol.hasInstance, { value: (inst) => {\n\t\tif (params?.Parent && inst instanceof params.Parent) return true;\n\t\treturn inst?._zod?.traits?.has(name);\n\t} });\n\tObject.defineProperty(_, \"name\", { value: name });\n\treturn _;\n}\nconst $brand = Symbol(\"zod_brand\");\nvar $ZodAsyncError = class extends Error {\n\tconstructor() {\n\t\tsuper(`Encountered Promise during synchronous parse. Use .parseAsync() instead.`);\n\t}\n};\nconst globalConfig = {};\nfunction config(newConfig) {\n\tif (newConfig) Object.assign(globalConfig, newConfig);\n\treturn globalConfig;\n}\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/util.js\nfunction getEnumValues(entries) {\n\tconst numericValues = Object.values(entries).filter((v) => typeof v === \"number\");\n\treturn Object.entries(entries).filter(([k, _]) => numericValues.indexOf(+k) === -1).map(([_, v]) => v);\n}\nfunction jsonStringifyReplacer(_, value) {\n\tif (typeof value === \"bigint\") return value.toString();\n\treturn value;\n}\nfunction cached(getter) {\n\treturn { get value() {\n\t\t{\n\t\t\tconst value = getter();\n\t\t\tObject.defineProperty(this, \"value\", { value });\n\t\t\treturn value;\n\t\t}\n\t\tthrow new Error(\"cached value already set\");\n\t} };\n}\nfunction nullish(input) {\n\treturn input === null || input === void 0;\n}\nfunction cleanRegex(source) {\n\tconst start = source.startsWith(\"^\") ? 1 : 0;\n\tconst end = source.endsWith(\"$\") ? source.length - 1 : source.length;\n\treturn source.slice(start, end);\n}\nfunction defineLazy(object, key, getter) {\n\tObject.defineProperty(object, key, {\n\t\tget() {\n\t\t\t{\n\t\t\t\tconst value = getter();\n\t\t\t\tobject[key] = value;\n\t\t\t\treturn value;\n\t\t\t}\n\t\t\tthrow new Error(\"cached value already set\");\n\t\t},\n\t\tset(v) {\n\t\t\tObject.defineProperty(object, key, { value: v });\n\t\t},\n\t\tconfigurable: true\n\t});\n}\nfunction assignProp(target, prop, value) {\n\tObject.defineProperty(target, prop, {\n\t\tvalue,\n\t\twritable: true,\n\t\tenumerable: true,\n\t\tconfigurable: true\n\t});\n}\nfunction esc(str) {\n\treturn JSON.stringify(str);\n}\nconst captureStackTrace = Error.captureStackTrace ? Error.captureStackTrace : (..._args) => {};\nfunction isObject(data) {\n\treturn typeof data === \"object\" && data !== null && !Array.isArray(data);\n}\nconst allowsEval = cached(() => {\n\tif (typeof navigator !== \"undefined\" && navigator?.userAgent?.includes(\"Cloudflare\")) return false;\n\ttry {\n\t\tnew Function(\"\");\n\t\treturn true;\n\t} catch (_) {\n\t\treturn false;\n\t}\n});\nfunction isPlainObject(o) {\n\tif (isObject(o) === false) return false;\n\tconst ctor = o.constructor;\n\tif (ctor === void 0) return true;\n\tconst prot = ctor.prototype;\n\tif (isObject(prot) === false) return false;\n\tif (Object.prototype.hasOwnProperty.call(prot, \"isPrototypeOf\") === false) return false;\n\treturn true;\n}\nconst propertyKeyTypes = new Set([\n\t\"string\",\n\t\"number\",\n\t\"symbol\"\n]);\nfunction escapeRegex(str) {\n\treturn str.replace(/[.*+?^${}()|[\\]\\\\]/g, \"\\\\$&\");\n}\nfunction clone(inst, def, params) {\n\tconst cl = new inst._zod.constr(def ?? inst._zod.def);\n\tif (!def || params?.parent) cl._zod.parent = inst;\n\treturn cl;\n}\nfunction normalizeParams(_params) {\n\tconst params = _params;\n\tif (!params) return {};\n\tif (typeof params === \"string\") return { error: () => params };\n\tif (params?.message !== void 0) {\n\t\tif (params?.error !== void 0) throw new Error(\"Cannot specify both `message` and `error` params\");\n\t\tparams.error = params.message;\n\t}\n\tdelete params.message;\n\tif (typeof params.error === \"string\") return {\n\t\t...params,\n\t\terror: () => params.error\n\t};\n\treturn params;\n}\nfunction optionalKeys(shape) {\n\treturn Object.keys(shape).filter((k) => {\n\t\treturn shape[k]._zod.optin === \"optional\" && shape[k]._zod.optout === \"optional\";\n\t});\n}\nconst NUMBER_FORMAT_RANGES = {\n\tsafeint: [Number.MIN_SAFE_INTEGER, Number.MAX_SAFE_INTEGER],\n\tint32: [-2147483648, 2147483647],\n\tuint32: [0, 4294967295],\n\tfloat32: [-34028234663852886e22, 34028234663852886e22],\n\tfloat64: [-Number.MAX_VALUE, Number.MAX_VALUE]\n};\nfunction pick(schema, mask) {\n\tconst newShape = {};\n\tconst currDef = schema._zod.def;\n\tfor (const key in mask) {\n\t\tif (!(key in currDef.shape)) throw new Error(`Unrecognized key: \"${key}\"`);\n\t\tif (!mask[key]) continue;\n\t\tnewShape[key] = currDef.shape[key];\n\t}\n\treturn clone(schema, {\n\t\t...schema._zod.def,\n\t\tshape: newShape,\n\t\tchecks: []\n\t});\n}\nfunction omit(schema, mask) {\n\tconst newShape = { ...schema._zod.def.shape };\n\tconst currDef = schema._zod.def;\n\tfor (const key in mask) {\n\t\tif (!(key in currDef.shape)) throw new Error(`Unrecognized key: \"${key}\"`);\n\t\tif (!mask[key]) continue;\n\t\tdelete newShape[key];\n\t}\n\treturn clone(schema, {\n\t\t...schema._zod.def,\n\t\tshape: newShape,\n\t\tchecks: []\n\t});\n}\nfunction extend(schema, shape) {\n\tif (!isPlainObject(shape)) throw new Error(\"Invalid input to extend: expected a plain object\");\n\treturn clone(schema, {\n\t\t...schema._zod.def,\n\t\tget shape() {\n\t\t\tconst _shape = {\n\t\t\t\t...schema._zod.def.shape,\n\t\t\t\t...shape\n\t\t\t};\n\t\t\tassignProp(this, \"shape\", _shape);\n\t\t\treturn _shape;\n\t\t},\n\t\tchecks: []\n\t});\n}\nfunction merge(a, b) {\n\treturn clone(a, {\n\t\t...a._zod.def,\n\t\tget shape() {\n\t\t\tconst _shape = {\n\t\t\t\t...a._zod.def.shape,\n\t\t\t\t...b._zod.def.shape\n\t\t\t};\n\t\t\tassignProp(this, \"shape\", _shape);\n\t\t\treturn _shape;\n\t\t},\n\t\tcatchall: b._zod.def.catchall,\n\t\tchecks: []\n\t});\n}\nfunction partial(Class, schema, mask) {\n\tconst oldShape = schema._zod.def.shape;\n\tconst shape = { ...oldShape };\n\tif (mask) for (const key in mask) {\n\t\tif (!(key in oldShape)) throw new Error(`Unrecognized key: \"${key}\"`);\n\t\tif (!mask[key]) continue;\n\t\tshape[key] = Class ? new Class({\n\t\t\ttype: \"optional\",\n\t\t\tinnerType: oldShape[key]\n\t\t}) : oldShape[key];\n\t}\n\telse for (const key in oldShape) shape[key] = Class ? new Class({\n\t\ttype: \"optional\",\n\t\tinnerType: oldShape[key]\n\t}) : oldShape[key];\n\treturn clone(schema, {\n\t\t...schema._zod.def,\n\t\tshape,\n\t\tchecks: []\n\t});\n}\nfunction required(Class, schema, mask) {\n\tconst oldShape = schema._zod.def.shape;\n\tconst shape = { ...oldShape };\n\tif (mask) for (const key in mask) {\n\t\tif (!(key in shape)) throw new Error(`Unrecognized key: \"${key}\"`);\n\t\tif (!mask[key]) continue;\n\t\tshape[key] = new Class({\n\t\t\ttype: \"nonoptional\",\n\t\t\tinnerType: oldShape[key]\n\t\t});\n\t}\n\telse for (const key in oldShape) shape[key] = new Class({\n\t\ttype: \"nonoptional\",\n\t\tinnerType: oldShape[key]\n\t});\n\treturn clone(schema, {\n\t\t...schema._zod.def,\n\t\tshape,\n\t\tchecks: []\n\t});\n}\nfunction aborted(x, startIndex = 0) {\n\tfor (let i = startIndex; i < x.issues.length; i++) if (x.issues[i]?.continue !== true) return true;\n\treturn false;\n}\nfunction prefixIssues(path, issues) {\n\treturn issues.map((iss) => {\n\t\tvar _a;\n\t\t(_a = iss).path ?? (_a.path = []);\n\t\tiss.path.unshift(path);\n\t\treturn iss;\n\t});\n}\nfunction unwrapMessage(message) {\n\treturn typeof message === \"string\" ? message : message?.message;\n}\nfunction finalizeIssue(iss, ctx, config$1) {\n\tconst full = {\n\t\t...iss,\n\t\tpath: iss.path ?? []\n\t};\n\tif (!iss.message) full.message = unwrapMessage(iss.inst?._zod.def?.error?.(iss)) ?? unwrapMessage(ctx?.error?.(iss)) ?? unwrapMessage(config$1.customError?.(iss)) ?? unwrapMessage(config$1.localeError?.(iss)) ?? \"Invalid input\";\n\tdelete full.inst;\n\tdelete full.continue;\n\tif (!ctx?.reportInput) delete full.input;\n\treturn full;\n}\nfunction getLengthableOrigin(input) {\n\tif (Array.isArray(input)) return \"array\";\n\tif (typeof input === \"string\") return \"string\";\n\treturn \"unknown\";\n}\nfunction issue(...args) {\n\tconst [iss, input, inst] = args;\n\tif (typeof iss === \"string\") return {\n\t\tmessage: iss,\n\t\tcode: \"custom\",\n\t\tinput,\n\t\tinst\n\t};\n\treturn { ...iss };\n}\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/errors.js\nconst initializer$1 = (inst, def) => {\n\tinst.name = \"$ZodError\";\n\tObject.defineProperty(inst, \"_zod\", {\n\t\tvalue: inst._zod,\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(inst, \"issues\", {\n\t\tvalue: def,\n\t\tenumerable: false\n\t});\n\tObject.defineProperty(inst, \"message\", {\n\t\tget() {\n\t\t\treturn JSON.stringify(def, jsonStringifyReplacer, 2);\n\t\t},\n\t\tenumerable: true\n\t});\n\tObject.defineProperty(inst, \"toString\", {\n\t\tvalue: () => inst.message,\n\t\tenumerable: false\n\t});\n};\nconst $ZodError = $constructor(\"$ZodError\", initializer$1);\nconst $ZodRealError = $constructor(\"$ZodError\", initializer$1, { Parent: Error });\nfunction flattenError(error, mapper = (issue$1) => issue$1.message) {\n\tconst fieldErrors = {};\n\tconst formErrors = [];\n\tfor (const sub of error.issues) if (sub.path.length > 0) {\n\t\tfieldErrors[sub.path[0]] = fieldErrors[sub.path[0]] || [];\n\t\tfieldErrors[sub.path[0]].push(mapper(sub));\n\t} else formErrors.push(mapper(sub));\n\treturn {\n\t\tformErrors,\n\t\tfieldErrors\n\t};\n}\nfunction formatError(error, _mapper) {\n\tconst mapper = _mapper || function(issue$1) {\n\t\treturn issue$1.message;\n\t};\n\tconst fieldErrors = { _errors: [] };\n\tconst processError = (error$1) => {\n\t\tfor (const issue$1 of error$1.issues) if (issue$1.code === \"invalid_union\" && issue$1.errors.length) issue$1.errors.map((issues) => processError({ issues }));\n\t\telse if (issue$1.code === \"invalid_key\") processError({ issues: issue$1.issues });\n\t\telse if (issue$1.code === \"invalid_element\") processError({ issues: issue$1.issues });\n\t\telse if (issue$1.path.length === 0) fieldErrors._errors.push(mapper(issue$1));\n\t\telse {\n\t\t\tlet curr = fieldErrors;\n\t\t\tlet i = 0;\n\t\t\twhile (i < issue$1.path.length) {\n\t\t\t\tconst el = issue$1.path[i];\n\t\t\t\tif (!(i === issue$1.path.length - 1)) curr[el] = curr[el] || { _errors: [] };\n\t\t\t\telse {\n\t\t\t\t\tcurr[el] = curr[el] || { _errors: [] };\n\t\t\t\t\tcurr[el]._errors.push(mapper(issue$1));\n\t\t\t\t}\n\t\t\t\tcurr = curr[el];\n\t\t\t\ti++;\n\t\t\t}\n\t\t}\n\t};\n\tprocessError(error);\n\treturn fieldErrors;\n}\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/parse.js\nconst _parse = (_Err) => (schema, value, _ctx, _params) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { async: false }) : { async: false };\n\tconst result = schema._zod.run({\n\t\tvalue,\n\t\tissues: []\n\t}, ctx);\n\tif (result instanceof Promise) throw new $ZodAsyncError();\n\tif (result.issues.length) {\n\t\tconst e = new (_params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n\t\tcaptureStackTrace(e, _params?.callee);\n\t\tthrow e;\n\t}\n\treturn result.value;\n};\nconst parse$1 = /* @__PURE__ */ _parse($ZodRealError);\nconst _parseAsync = (_Err) => async (schema, value, _ctx, params) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n\tlet result = schema._zod.run({\n\t\tvalue,\n\t\tissues: []\n\t}, ctx);\n\tif (result instanceof Promise) result = await result;\n\tif (result.issues.length) {\n\t\tconst e = new (params?.Err ?? _Err)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())));\n\t\tcaptureStackTrace(e, params?.callee);\n\t\tthrow e;\n\t}\n\treturn result.value;\n};\nconst parseAsync$1 = /* @__PURE__ */ _parseAsync($ZodRealError);\nconst _safeParse = (_Err) => (schema, value, _ctx) => {\n\tconst ctx = _ctx ? {\n\t\t..._ctx,\n\t\tasync: false\n\t} : { async: false };\n\tconst result = schema._zod.run({\n\t\tvalue,\n\t\tissues: []\n\t}, ctx);\n\tif (result instanceof Promise) throw new $ZodAsyncError();\n\treturn result.issues.length ? {\n\t\tsuccess: false,\n\t\terror: new (_Err ?? $ZodError)(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n\t} : {\n\t\tsuccess: true,\n\t\tdata: result.value\n\t};\n};\nconst safeParse$1 = /* @__PURE__ */ _safeParse($ZodRealError);\nconst _safeParseAsync = (_Err) => async (schema, value, _ctx) => {\n\tconst ctx = _ctx ? Object.assign(_ctx, { async: true }) : { async: true };\n\tlet result = schema._zod.run({\n\t\tvalue,\n\t\tissues: []\n\t}, ctx);\n\tif (result instanceof Promise) result = await result;\n\treturn result.issues.length ? {\n\t\tsuccess: false,\n\t\terror: new _Err(result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n\t} : {\n\t\tsuccess: true,\n\t\tdata: result.value\n\t};\n};\nconst safeParseAsync$1 = /* @__PURE__ */ _safeParseAsync($ZodRealError);\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/checks.js\nconst $ZodCheck = /* @__PURE__ */ $constructor(\"$ZodCheck\", (inst, def) => {\n\tvar _a;\n\tinst._zod ?? (inst._zod = {});\n\tinst._zod.def = def;\n\t(_a = inst._zod).onattach ?? (_a.onattach = []);\n});\nconst $ZodCheckMaxLength = /* @__PURE__ */ $constructor(\"$ZodCheckMaxLength\", (inst, def) => {\n\tvar _a;\n\t$ZodCheck.init(inst, def);\n\t(_a = inst._zod.def).when ?? (_a.when = (payload) => {\n\t\tconst val = payload.value;\n\t\treturn !nullish(val) && val.length !== void 0;\n\t});\n\tinst._zod.onattach.push((inst$1) => {\n\t\tconst curr = inst$1._zod.bag.maximum ?? Number.POSITIVE_INFINITY;\n\t\tif (def.maximum < curr) inst$1._zod.bag.maximum = def.maximum;\n\t});\n\tinst._zod.check = (payload) => {\n\t\tconst input = payload.value;\n\t\tif (input.length <= def.maximum) return;\n\t\tconst origin = getLengthableOrigin(input);\n\t\tpayload.issues.push({\n\t\t\torigin,\n\t\t\tcode: \"too_big\",\n\t\t\tmaximum: def.maximum,\n\t\t\tinclusive: true,\n\t\t\tinput,\n\t\t\tinst,\n\t\t\tcontinue: !def.abort\n\t\t});\n\t};\n});\nconst $ZodCheckMinLength = /* @__PURE__ */ $constructor(\"$ZodCheckMinLength\", (inst, def) => {\n\tvar _a;\n\t$ZodCheck.init(inst, def);\n\t(_a = inst._zod.def).when ?? (_a.when = (payload) => {\n\t\tconst val = payload.value;\n\t\treturn !nullish(val) && val.length !== void 0;\n\t});\n\tinst._zod.onattach.push((inst$1) => {\n\t\tconst curr = inst$1._zod.bag.minimum ?? Number.NEGATIVE_INFINITY;\n\t\tif (def.minimum > curr) inst$1._zod.bag.minimum = def.minimum;\n\t});\n\tinst._zod.check = (payload) => {\n\t\tconst input = payload.value;\n\t\tif (input.length >= def.minimum) return;\n\t\tconst origin = getLengthableOrigin(input);\n\t\tpayload.issues.push({\n\t\t\torigin,\n\t\t\tcode: \"too_small\",\n\t\t\tminimum: def.minimum,\n\t\t\tinclusive: true,\n\t\t\tinput,\n\t\t\tinst,\n\t\t\tcontinue: !def.abort\n\t\t});\n\t};\n});\nconst $ZodCheckLengthEquals = /* @__PURE__ */ $constructor(\"$ZodCheckLengthEquals\", (inst, def) => {\n\tvar _a;\n\t$ZodCheck.init(inst, def);\n\t(_a = inst._zod.def).when ?? (_a.when = (payload) => {\n\t\tconst val = payload.value;\n\t\treturn !nullish(val) && val.length !== void 0;\n\t});\n\tinst._zod.onattach.push((inst$1) => {\n\t\tconst bag = inst$1._zod.bag;\n\t\tbag.minimum = def.length;\n\t\tbag.maximum = def.length;\n\t\tbag.length = def.length;\n\t});\n\tinst._zod.check = (payload) => {\n\t\tconst input = payload.value;\n\t\tconst length = input.length;\n\t\tif (length === def.length) return;\n\t\tconst origin = getLengthableOrigin(input);\n\t\tconst tooBig = length > def.length;\n\t\tpayload.issues.push({\n\t\t\torigin,\n\t\t\t...tooBig ? {\n\t\t\t\tcode: \"too_big\",\n\t\t\t\tmaximum: def.length\n\t\t\t} : {\n\t\t\t\tcode: \"too_small\",\n\t\t\t\tminimum: def.length\n\t\t\t},\n\t\t\tinclusive: true,\n\t\t\texact: true,\n\t\t\tinput: payload.value,\n\t\t\tinst,\n\t\t\tcontinue: !def.abort\n\t\t});\n\t};\n});\nconst $ZodCheckOverwrite = /* @__PURE__ */ $constructor(\"$ZodCheckOverwrite\", (inst, def) => {\n\t$ZodCheck.init(inst, def);\n\tinst._zod.check = (payload) => {\n\t\tpayload.value = def.tx(payload.value);\n\t};\n});\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/doc.js\nvar Doc = class {\n\tconstructor(args = []) {\n\t\tthis.content = [];\n\t\tthis.indent = 0;\n\t\tif (this) this.args = args;\n\t}\n\tindented(fn) {\n\t\tthis.indent += 1;\n\t\tfn(this);\n\t\tthis.indent -= 1;\n\t}\n\twrite(arg) {\n\t\tif (typeof arg === \"function\") {\n\t\t\targ(this, { execution: \"sync\" });\n\t\t\targ(this, { execution: \"async\" });\n\t\t\treturn;\n\t\t}\n\t\tconst lines = arg.split(\"\\n\").filter((x) => x);\n\t\tconst minIndent = Math.min(...lines.map((x) => x.length - x.trimStart().length));\n\t\tconst dedented = lines.map((x) => x.slice(minIndent)).map((x) => \" \".repeat(this.indent * 2) + x);\n\t\tfor (const line of dedented) this.content.push(line);\n\t}\n\tcompile() {\n\t\tconst F = Function;\n\t\tconst args = this?.args;\n\t\tconst lines = [...(this?.content ?? [``]).map((x) => `  ${x}`)];\n\t\treturn new F(...args, lines.join(\"\\n\"));\n\t}\n};\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/versions.js\nconst version = {\n\tmajor: 4,\n\tminor: 0,\n\tpatch: 0\n};\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/schemas.js\nconst $ZodType = /* @__PURE__ */ $constructor(\"$ZodType\", (inst, def) => {\n\tvar _a;\n\tinst ?? (inst = {});\n\tinst._zod.def = def;\n\tinst._zod.bag = inst._zod.bag || {};\n\tinst._zod.version = version;\n\tconst checks = [...inst._zod.def.checks ?? []];\n\tif (inst._zod.traits.has(\"$ZodCheck\")) checks.unshift(inst);\n\tfor (const ch of checks) for (const fn of ch._zod.onattach) fn(inst);\n\tif (checks.length === 0) {\n\t\t(_a = inst._zod).deferred ?? (_a.deferred = []);\n\t\tinst._zod.deferred?.push(() => {\n\t\t\tinst._zod.run = inst._zod.parse;\n\t\t});\n\t} else {\n\t\tconst runChecks = (payload, checks$1, ctx) => {\n\t\t\tlet isAborted = aborted(payload);\n\t\t\tlet asyncResult;\n\t\t\tfor (const ch of checks$1) {\n\t\t\t\tif (ch._zod.def.when) {\n\t\t\t\t\tif (!ch._zod.def.when(payload)) continue;\n\t\t\t\t} else if (isAborted) continue;\n\t\t\t\tconst currLen = payload.issues.length;\n\t\t\t\tconst _ = ch._zod.check(payload);\n\t\t\t\tif (_ instanceof Promise && ctx?.async === false) throw new $ZodAsyncError();\n\t\t\t\tif (asyncResult || _ instanceof Promise) asyncResult = (asyncResult ?? Promise.resolve()).then(async () => {\n\t\t\t\t\tawait _;\n\t\t\t\t\tif (payload.issues.length === currLen) return;\n\t\t\t\t\tif (!isAborted) isAborted = aborted(payload, currLen);\n\t\t\t\t});\n\t\t\t\telse {\n\t\t\t\t\tif (payload.issues.length === currLen) continue;\n\t\t\t\t\tif (!isAborted) isAborted = aborted(payload, currLen);\n\t\t\t\t}\n\t\t\t}\n\t\t\tif (asyncResult) return asyncResult.then(() => {\n\t\t\t\treturn payload;\n\t\t\t});\n\t\t\treturn payload;\n\t\t};\n\t\tinst._zod.run = (payload, ctx) => {\n\t\t\tconst result = inst._zod.parse(payload, ctx);\n\t\t\tif (result instanceof Promise) {\n\t\t\t\tif (ctx.async === false) throw new $ZodAsyncError();\n\t\t\t\treturn result.then((result$1) => runChecks(result$1, checks, ctx));\n\t\t\t}\n\t\t\treturn runChecks(result, checks, ctx);\n\t\t};\n\t}\n\tinst[\"~standard\"] = {\n\t\tvalidate: (value) => {\n\t\t\ttry {\n\t\t\t\tconst r = safeParse$1(inst, value);\n\t\t\t\treturn r.success ? { value: r.data } : { issues: r.error?.issues };\n\t\t\t} catch (_) {\n\t\t\t\treturn safeParseAsync$1(inst, value).then((r) => r.success ? { value: r.data } : { issues: r.error?.issues });\n\t\t\t}\n\t\t},\n\t\tvendor: \"zod\",\n\t\tversion: 1\n\t};\n});\nconst $ZodUnknown = /* @__PURE__ */ $constructor(\"$ZodUnknown\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.parse = (payload) => payload;\n});\nconst $ZodNever = /* @__PURE__ */ $constructor(\"$ZodNever\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.parse = (payload, _ctx) => {\n\t\tpayload.issues.push({\n\t\t\texpected: \"never\",\n\t\t\tcode: \"invalid_type\",\n\t\t\tinput: payload.value,\n\t\t\tinst\n\t\t});\n\t\treturn payload;\n\t};\n});\nfunction handleArrayResult(result, final, index) {\n\tif (result.issues.length) final.issues.push(...prefixIssues(index, result.issues));\n\tfinal.value[index] = result.value;\n}\nconst $ZodArray = /* @__PURE__ */ $constructor(\"$ZodArray\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.parse = (payload, ctx) => {\n\t\tconst input = payload.value;\n\t\tif (!Array.isArray(input)) {\n\t\t\tpayload.issues.push({\n\t\t\t\texpected: \"array\",\n\t\t\t\tcode: \"invalid_type\",\n\t\t\t\tinput,\n\t\t\t\tinst\n\t\t\t});\n\t\t\treturn payload;\n\t\t}\n\t\tpayload.value = Array(input.length);\n\t\tconst proms = [];\n\t\tfor (let i = 0; i < input.length; i++) {\n\t\t\tconst item = input[i];\n\t\t\tconst result = def.element._zod.run({\n\t\t\t\tvalue: item,\n\t\t\t\tissues: []\n\t\t\t}, ctx);\n\t\t\tif (result instanceof Promise) proms.push(result.then((result$1) => handleArrayResult(result$1, payload, i)));\n\t\t\telse handleArrayResult(result, payload, i);\n\t\t}\n\t\tif (proms.length) return Promise.all(proms).then(() => payload);\n\t\treturn payload;\n\t};\n});\nfunction handleObjectResult(result, final, key) {\n\tif (result.issues.length) final.issues.push(...prefixIssues(key, result.issues));\n\tfinal.value[key] = result.value;\n}\nfunction handleOptionalObjectResult(result, final, key, input) {\n\tif (result.issues.length) if (input[key] === void 0) if (key in input) final.value[key] = void 0;\n\telse final.value[key] = result.value;\n\telse final.issues.push(...prefixIssues(key, result.issues));\n\telse if (result.value === void 0) {\n\t\tif (key in input) final.value[key] = void 0;\n\t} else final.value[key] = result.value;\n}\nconst $ZodObject = /* @__PURE__ */ $constructor(\"$ZodObject\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tconst _normalized = cached(() => {\n\t\tconst keys = Object.keys(def.shape);\n\t\tfor (const k of keys) if (!(def.shape[k] instanceof $ZodType)) throw new Error(`Invalid element at key \"${k}\": expected a Zod schema`);\n\t\tconst okeys = optionalKeys(def.shape);\n\t\treturn {\n\t\t\tshape: def.shape,\n\t\t\tkeys,\n\t\t\tkeySet: new Set(keys),\n\t\t\tnumKeys: keys.length,\n\t\t\toptionalKeys: new Set(okeys)\n\t\t};\n\t});\n\tdefineLazy(inst._zod, \"propValues\", () => {\n\t\tconst shape = def.shape;\n\t\tconst propValues = {};\n\t\tfor (const key in shape) {\n\t\t\tconst field = shape[key]._zod;\n\t\t\tif (field.values) {\n\t\t\t\tpropValues[key] ?? (propValues[key] = /* @__PURE__ */ new Set());\n\t\t\t\tfor (const v of field.values) propValues[key].add(v);\n\t\t\t}\n\t\t}\n\t\treturn propValues;\n\t});\n\tconst generateFastpass = (shape) => {\n\t\tconst doc = new Doc([\n\t\t\t\"shape\",\n\t\t\t\"payload\",\n\t\t\t\"ctx\"\n\t\t]);\n\t\tconst normalized = _normalized.value;\n\t\tconst parseStr = (key) => {\n\t\t\tconst k = esc(key);\n\t\t\treturn `shape[${k}]._zod.run({ value: input[${k}], issues: [] }, ctx)`;\n\t\t};\n\t\tdoc.write(`const input = payload.value;`);\n\t\tconst ids = Object.create(null);\n\t\tlet counter = 0;\n\t\tfor (const key of normalized.keys) ids[key] = `key_${counter++}`;\n\t\tdoc.write(`const newResult = {}`);\n\t\tfor (const key of normalized.keys) if (normalized.optionalKeys.has(key)) {\n\t\t\tconst id = ids[key];\n\t\t\tdoc.write(`const ${id} = ${parseStr(key)};`);\n\t\t\tconst k = esc(key);\n\t\t\tdoc.write(`\n        if (${id}.issues.length) {\n          if (input[${k}] === undefined) {\n            if (${k} in input) {\n              newResult[${k}] = undefined;\n            }\n          } else {\n            payload.issues = payload.issues.concat(\n              ${id}.issues.map((iss) => ({\n                ...iss,\n                path: iss.path ? [${k}, ...iss.path] : [${k}],\n              }))\n            );\n          }\n        } else if (${id}.value === undefined) {\n          if (${k} in input) newResult[${k}] = undefined;\n        } else {\n          newResult[${k}] = ${id}.value;\n        }\n        `);\n\t\t} else {\n\t\t\tconst id = ids[key];\n\t\t\tdoc.write(`const ${id} = ${parseStr(key)};`);\n\t\t\tdoc.write(`\n          if (${id}.issues.length) payload.issues = payload.issues.concat(${id}.issues.map(iss => ({\n            ...iss,\n            path: iss.path ? [${esc(key)}, ...iss.path] : [${esc(key)}]\n          })));`);\n\t\t\tdoc.write(`newResult[${esc(key)}] = ${id}.value`);\n\t\t}\n\t\tdoc.write(`payload.value = newResult;`);\n\t\tdoc.write(`return payload;`);\n\t\tconst fn = doc.compile();\n\t\treturn (payload, ctx) => fn(shape, payload, ctx);\n\t};\n\tlet fastpass;\n\tconst isObject$1 = isObject;\n\tconst jit = !globalConfig.jitless;\n\tconst allowsEval$1 = allowsEval;\n\tconst fastEnabled = jit && allowsEval$1.value;\n\tconst catchall = def.catchall;\n\tlet value;\n\tinst._zod.parse = (payload, ctx) => {\n\t\tvalue ?? (value = _normalized.value);\n\t\tconst input = payload.value;\n\t\tif (!isObject$1(input)) {\n\t\t\tpayload.issues.push({\n\t\t\t\texpected: \"object\",\n\t\t\t\tcode: \"invalid_type\",\n\t\t\t\tinput,\n\t\t\t\tinst\n\t\t\t});\n\t\t\treturn payload;\n\t\t}\n\t\tconst proms = [];\n\t\tif (jit && fastEnabled && ctx?.async === false && ctx.jitless !== true) {\n\t\t\tif (!fastpass) fastpass = generateFastpass(def.shape);\n\t\t\tpayload = fastpass(payload, ctx);\n\t\t} else {\n\t\t\tpayload.value = {};\n\t\t\tconst shape = value.shape;\n\t\t\tfor (const key of value.keys) {\n\t\t\t\tconst el = shape[key];\n\t\t\t\tconst r = el._zod.run({\n\t\t\t\t\tvalue: input[key],\n\t\t\t\t\tissues: []\n\t\t\t\t}, ctx);\n\t\t\t\tconst isOptional = el._zod.optin === \"optional\" && el._zod.optout === \"optional\";\n\t\t\t\tif (r instanceof Promise) proms.push(r.then((r$1) => isOptional ? handleOptionalObjectResult(r$1, payload, key, input) : handleObjectResult(r$1, payload, key)));\n\t\t\t\telse if (isOptional) handleOptionalObjectResult(r, payload, key, input);\n\t\t\t\telse handleObjectResult(r, payload, key);\n\t\t\t}\n\t\t}\n\t\tif (!catchall) return proms.length ? Promise.all(proms).then(() => payload) : payload;\n\t\tconst unrecognized = [];\n\t\tconst keySet = value.keySet;\n\t\tconst _catchall = catchall._zod;\n\t\tconst t = _catchall.def.type;\n\t\tfor (const key of Object.keys(input)) {\n\t\t\tif (keySet.has(key)) continue;\n\t\t\tif (t === \"never\") {\n\t\t\t\tunrecognized.push(key);\n\t\t\t\tcontinue;\n\t\t\t}\n\t\t\tconst r = _catchall.run({\n\t\t\t\tvalue: input[key],\n\t\t\t\tissues: []\n\t\t\t}, ctx);\n\t\t\tif (r instanceof Promise) proms.push(r.then((r$1) => handleObjectResult(r$1, payload, key)));\n\t\t\telse handleObjectResult(r, payload, key);\n\t\t}\n\t\tif (unrecognized.length) payload.issues.push({\n\t\t\tcode: \"unrecognized_keys\",\n\t\t\tkeys: unrecognized,\n\t\t\tinput,\n\t\t\tinst\n\t\t});\n\t\tif (!proms.length) return payload;\n\t\treturn Promise.all(proms).then(() => {\n\t\t\treturn payload;\n\t\t});\n\t};\n});\nfunction handleUnionResults(results, final, inst, ctx) {\n\tfor (const result of results) if (result.issues.length === 0) {\n\t\tfinal.value = result.value;\n\t\treturn final;\n\t}\n\tfinal.issues.push({\n\t\tcode: \"invalid_union\",\n\t\tinput: final.value,\n\t\tinst,\n\t\terrors: results.map((result) => result.issues.map((iss) => finalizeIssue(iss, ctx, config())))\n\t});\n\treturn final;\n}\nconst $ZodUnion = /* @__PURE__ */ $constructor(\"$ZodUnion\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tdefineLazy(inst._zod, \"optin\", () => def.options.some((o) => o._zod.optin === \"optional\") ? \"optional\" : void 0);\n\tdefineLazy(inst._zod, \"optout\", () => def.options.some((o) => o._zod.optout === \"optional\") ? \"optional\" : void 0);\n\tdefineLazy(inst._zod, \"values\", () => {\n\t\tif (def.options.every((o) => o._zod.values)) return new Set(def.options.flatMap((option) => Array.from(option._zod.values)));\n\t});\n\tdefineLazy(inst._zod, \"pattern\", () => {\n\t\tif (def.options.every((o) => o._zod.pattern)) {\n\t\t\tconst patterns = def.options.map((o) => o._zod.pattern);\n\t\t\treturn /* @__PURE__ */ new RegExp(`^(${patterns.map((p) => cleanRegex(p.source)).join(\"|\")})$`);\n\t\t}\n\t});\n\tinst._zod.parse = (payload, ctx) => {\n\t\tlet async = false;\n\t\tconst results = [];\n\t\tfor (const option of def.options) {\n\t\t\tconst result = option._zod.run({\n\t\t\t\tvalue: payload.value,\n\t\t\t\tissues: []\n\t\t\t}, ctx);\n\t\t\tif (result instanceof Promise) {\n\t\t\t\tresults.push(result);\n\t\t\t\tasync = true;\n\t\t\t} else {\n\t\t\t\tif (result.issues.length === 0) return result;\n\t\t\t\tresults.push(result);\n\t\t\t}\n\t\t}\n\t\tif (!async) return handleUnionResults(results, payload, inst, ctx);\n\t\treturn Promise.all(results).then((results$1) => {\n\t\t\treturn handleUnionResults(results$1, payload, inst, ctx);\n\t\t});\n\t};\n});\nconst $ZodIntersection = /* @__PURE__ */ $constructor(\"$ZodIntersection\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.parse = (payload, ctx) => {\n\t\tconst input = payload.value;\n\t\tconst left = def.left._zod.run({\n\t\t\tvalue: input,\n\t\t\tissues: []\n\t\t}, ctx);\n\t\tconst right = def.right._zod.run({\n\t\t\tvalue: input,\n\t\t\tissues: []\n\t\t}, ctx);\n\t\tif (left instanceof Promise || right instanceof Promise) return Promise.all([left, right]).then(([left$1, right$1]) => {\n\t\t\treturn handleIntersectionResults(payload, left$1, right$1);\n\t\t});\n\t\treturn handleIntersectionResults(payload, left, right);\n\t};\n});\nfunction mergeValues(a, b) {\n\tif (a === b) return {\n\t\tvalid: true,\n\t\tdata: a\n\t};\n\tif (a instanceof Date && b instanceof Date && +a === +b) return {\n\t\tvalid: true,\n\t\tdata: a\n\t};\n\tif (isPlainObject(a) && isPlainObject(b)) {\n\t\tconst bKeys = Object.keys(b);\n\t\tconst sharedKeys = Object.keys(a).filter((key) => bKeys.indexOf(key) !== -1);\n\t\tconst newObj = {\n\t\t\t...a,\n\t\t\t...b\n\t\t};\n\t\tfor (const key of sharedKeys) {\n\t\t\tconst sharedValue = mergeValues(a[key], b[key]);\n\t\t\tif (!sharedValue.valid) return {\n\t\t\t\tvalid: false,\n\t\t\t\tmergeErrorPath: [key, ...sharedValue.mergeErrorPath]\n\t\t\t};\n\t\t\tnewObj[key] = sharedValue.data;\n\t\t}\n\t\treturn {\n\t\t\tvalid: true,\n\t\t\tdata: newObj\n\t\t};\n\t}\n\tif (Array.isArray(a) && Array.isArray(b)) {\n\t\tif (a.length !== b.length) return {\n\t\t\tvalid: false,\n\t\t\tmergeErrorPath: []\n\t\t};\n\t\tconst newArray = [];\n\t\tfor (let index = 0; index < a.length; index++) {\n\t\t\tconst itemA = a[index];\n\t\t\tconst itemB = b[index];\n\t\t\tconst sharedValue = mergeValues(itemA, itemB);\n\t\t\tif (!sharedValue.valid) return {\n\t\t\t\tvalid: false,\n\t\t\t\tmergeErrorPath: [index, ...sharedValue.mergeErrorPath]\n\t\t\t};\n\t\t\tnewArray.push(sharedValue.data);\n\t\t}\n\t\treturn {\n\t\t\tvalid: true,\n\t\t\tdata: newArray\n\t\t};\n\t}\n\treturn {\n\t\tvalid: false,\n\t\tmergeErrorPath: []\n\t};\n}\nfunction handleIntersectionResults(result, left, right) {\n\tif (left.issues.length) result.issues.push(...left.issues);\n\tif (right.issues.length) result.issues.push(...right.issues);\n\tif (aborted(result)) return result;\n\tconst merged = mergeValues(left.value, right.value);\n\tif (!merged.valid) throw new Error(`Unmergable intersection. Error path: ${JSON.stringify(merged.mergeErrorPath)}`);\n\tresult.value = merged.data;\n\treturn result;\n}\nconst $ZodEnum = /* @__PURE__ */ $constructor(\"$ZodEnum\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tconst values = getEnumValues(def.entries);\n\tinst._zod.values = new Set(values);\n\tinst._zod.pattern = /* @__PURE__ */ new RegExp(`^(${values.filter((k) => propertyKeyTypes.has(typeof k)).map((o) => typeof o === \"string\" ? escapeRegex(o) : o.toString()).join(\"|\")})$`);\n\tinst._zod.parse = (payload, _ctx) => {\n\t\tconst input = payload.value;\n\t\tif (inst._zod.values.has(input)) return payload;\n\t\tpayload.issues.push({\n\t\t\tcode: \"invalid_value\",\n\t\t\tvalues,\n\t\t\tinput,\n\t\t\tinst\n\t\t});\n\t\treturn payload;\n\t};\n});\nconst $ZodTransform = /* @__PURE__ */ $constructor(\"$ZodTransform\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.parse = (payload, _ctx) => {\n\t\tconst _out = def.transform(payload.value, payload);\n\t\tif (_ctx.async) return (_out instanceof Promise ? _out : Promise.resolve(_out)).then((output) => {\n\t\t\tpayload.value = output;\n\t\t\treturn payload;\n\t\t});\n\t\tif (_out instanceof Promise) throw new $ZodAsyncError();\n\t\tpayload.value = _out;\n\t\treturn payload;\n\t};\n});\nconst $ZodOptional = /* @__PURE__ */ $constructor(\"$ZodOptional\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.optin = \"optional\";\n\tinst._zod.optout = \"optional\";\n\tdefineLazy(inst._zod, \"values\", () => {\n\t\treturn def.innerType._zod.values ? new Set([...def.innerType._zod.values, void 0]) : void 0;\n\t});\n\tdefineLazy(inst._zod, \"pattern\", () => {\n\t\tconst pattern = def.innerType._zod.pattern;\n\t\treturn pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)})?$`) : void 0;\n\t});\n\tinst._zod.parse = (payload, ctx) => {\n\t\tif (def.innerType._zod.optin === \"optional\") return def.innerType._zod.run(payload, ctx);\n\t\tif (payload.value === void 0) return payload;\n\t\treturn def.innerType._zod.run(payload, ctx);\n\t};\n});\nconst $ZodNullable = /* @__PURE__ */ $constructor(\"$ZodNullable\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tdefineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n\tdefineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n\tdefineLazy(inst._zod, \"pattern\", () => {\n\t\tconst pattern = def.innerType._zod.pattern;\n\t\treturn pattern ? /* @__PURE__ */ new RegExp(`^(${cleanRegex(pattern.source)}|null)$`) : void 0;\n\t});\n\tdefineLazy(inst._zod, \"values\", () => {\n\t\treturn def.innerType._zod.values ? new Set([...def.innerType._zod.values, null]) : void 0;\n\t});\n\tinst._zod.parse = (payload, ctx) => {\n\t\tif (payload.value === null) return payload;\n\t\treturn def.innerType._zod.run(payload, ctx);\n\t};\n});\nconst $ZodDefault = /* @__PURE__ */ $constructor(\"$ZodDefault\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.optin = \"optional\";\n\tdefineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n\tinst._zod.parse = (payload, ctx) => {\n\t\tif (payload.value === void 0) {\n\t\t\tpayload.value = def.defaultValue;\n\t\t\t/**\n\t\t\t* $ZodDefault always returns the default value immediately.\n\t\t\t* It doesn't pass the default value into the validator (\"prefault\"). There's no reason to pass the default value through validation. The validity of the default is enforced by TypeScript statically. Otherwise, it's the responsibility of the user to ensure the default is valid. In the case of pipes with divergent in/out types, you can specify the default on the `in` schema of your ZodPipe to set a \"prefault\" for the pipe.   */\n\t\t\treturn payload;\n\t\t}\n\t\tconst result = def.innerType._zod.run(payload, ctx);\n\t\tif (result instanceof Promise) return result.then((result$1) => handleDefaultResult(result$1, def));\n\t\treturn handleDefaultResult(result, def);\n\t};\n});\nfunction handleDefaultResult(payload, def) {\n\tif (payload.value === void 0) payload.value = def.defaultValue;\n\treturn payload;\n}\nconst $ZodPrefault = /* @__PURE__ */ $constructor(\"$ZodPrefault\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.optin = \"optional\";\n\tdefineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n\tinst._zod.parse = (payload, ctx) => {\n\t\tif (payload.value === void 0) payload.value = def.defaultValue;\n\t\treturn def.innerType._zod.run(payload, ctx);\n\t};\n});\nconst $ZodNonOptional = /* @__PURE__ */ $constructor(\"$ZodNonOptional\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tdefineLazy(inst._zod, \"values\", () => {\n\t\tconst v = def.innerType._zod.values;\n\t\treturn v ? new Set([...v].filter((x) => x !== void 0)) : void 0;\n\t});\n\tinst._zod.parse = (payload, ctx) => {\n\t\tconst result = def.innerType._zod.run(payload, ctx);\n\t\tif (result instanceof Promise) return result.then((result$1) => handleNonOptionalResult(result$1, inst));\n\t\treturn handleNonOptionalResult(result, inst);\n\t};\n});\nfunction handleNonOptionalResult(payload, inst) {\n\tif (!payload.issues.length && payload.value === void 0) payload.issues.push({\n\t\tcode: \"invalid_type\",\n\t\texpected: \"nonoptional\",\n\t\tinput: payload.value,\n\t\tinst\n\t});\n\treturn payload;\n}\nconst $ZodCatch = /* @__PURE__ */ $constructor(\"$ZodCatch\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst._zod.optin = \"optional\";\n\tdefineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n\tdefineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n\tinst._zod.parse = (payload, ctx) => {\n\t\tconst result = def.innerType._zod.run(payload, ctx);\n\t\tif (result instanceof Promise) return result.then((result$1) => {\n\t\t\tpayload.value = result$1.value;\n\t\t\tif (result$1.issues.length) {\n\t\t\t\tpayload.value = def.catchValue({\n\t\t\t\t\t...payload,\n\t\t\t\t\terror: { issues: result$1.issues.map((iss) => finalizeIssue(iss, ctx, config())) },\n\t\t\t\t\tinput: payload.value\n\t\t\t\t});\n\t\t\t\tpayload.issues = [];\n\t\t\t}\n\t\t\treturn payload;\n\t\t});\n\t\tpayload.value = result.value;\n\t\tif (result.issues.length) {\n\t\t\tpayload.value = def.catchValue({\n\t\t\t\t...payload,\n\t\t\t\terror: { issues: result.issues.map((iss) => finalizeIssue(iss, ctx, config())) },\n\t\t\t\tinput: payload.value\n\t\t\t});\n\t\t\tpayload.issues = [];\n\t\t}\n\t\treturn payload;\n\t};\n});\nconst $ZodPipe = /* @__PURE__ */ $constructor(\"$ZodPipe\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tdefineLazy(inst._zod, \"values\", () => def.in._zod.values);\n\tdefineLazy(inst._zod, \"optin\", () => def.in._zod.optin);\n\tdefineLazy(inst._zod, \"optout\", () => def.out._zod.optout);\n\tinst._zod.parse = (payload, ctx) => {\n\t\tconst left = def.in._zod.run(payload, ctx);\n\t\tif (left instanceof Promise) return left.then((left$1) => handlePipeResult(left$1, def, ctx));\n\t\treturn handlePipeResult(left, def, ctx);\n\t};\n});\nfunction handlePipeResult(left, def, ctx) {\n\tif (aborted(left)) return left;\n\treturn def.out._zod.run({\n\t\tvalue: left.value,\n\t\tissues: left.issues\n\t}, ctx);\n}\nconst $ZodReadonly = /* @__PURE__ */ $constructor(\"$ZodReadonly\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tdefineLazy(inst._zod, \"propValues\", () => def.innerType._zod.propValues);\n\tdefineLazy(inst._zod, \"values\", () => def.innerType._zod.values);\n\tdefineLazy(inst._zod, \"optin\", () => def.innerType._zod.optin);\n\tdefineLazy(inst._zod, \"optout\", () => def.innerType._zod.optout);\n\tinst._zod.parse = (payload, ctx) => {\n\t\tconst result = def.innerType._zod.run(payload, ctx);\n\t\tif (result instanceof Promise) return result.then(handleReadonlyResult);\n\t\treturn handleReadonlyResult(result);\n\t};\n});\nfunction handleReadonlyResult(payload) {\n\tpayload.value = Object.freeze(payload.value);\n\treturn payload;\n}\nconst $ZodCustom = /* @__PURE__ */ $constructor(\"$ZodCustom\", (inst, def) => {\n\t$ZodCheck.init(inst, def);\n\t$ZodType.init(inst, def);\n\tinst._zod.parse = (payload, _) => {\n\t\treturn payload;\n\t};\n\tinst._zod.check = (payload) => {\n\t\tconst input = payload.value;\n\t\tconst r = def.fn(input);\n\t\tif (r instanceof Promise) return r.then((r$1) => handleRefineResult(r$1, payload, input, inst));\n\t\thandleRefineResult(r, payload, input, inst);\n\t};\n});\nfunction handleRefineResult(result, payload, input, inst) {\n\tif (!result) {\n\t\tconst _iss = {\n\t\t\tcode: \"custom\",\n\t\t\tinput,\n\t\t\tinst,\n\t\t\tpath: [...inst._zod.def.path ?? []],\n\t\t\tcontinue: !inst._zod.def.abort\n\t\t};\n\t\tif (inst._zod.def.params) _iss.params = inst._zod.def.params;\n\t\tpayload.issues.push(issue(_iss));\n\t}\n}\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/registries.js\nconst $output = Symbol(\"ZodOutput\");\nconst $input = Symbol(\"ZodInput\");\nvar $ZodRegistry = class {\n\tconstructor() {\n\t\tthis._map = /* @__PURE__ */ new Map();\n\t\tthis._idmap = /* @__PURE__ */ new Map();\n\t}\n\tadd(schema, ..._meta) {\n\t\tconst meta = _meta[0];\n\t\tthis._map.set(schema, meta);\n\t\tif (meta && typeof meta === \"object\" && \"id\" in meta) {\n\t\t\tif (this._idmap.has(meta.id)) throw new Error(`ID ${meta.id} already exists in the registry`);\n\t\t\tthis._idmap.set(meta.id, schema);\n\t\t}\n\t\treturn this;\n\t}\n\tclear() {\n\t\tthis._map = /* @__PURE__ */ new Map();\n\t\tthis._idmap = /* @__PURE__ */ new Map();\n\t\treturn this;\n\t}\n\tremove(schema) {\n\t\tconst meta = this._map.get(schema);\n\t\tif (meta && typeof meta === \"object\" && \"id\" in meta) this._idmap.delete(meta.id);\n\t\tthis._map.delete(schema);\n\t\treturn this;\n\t}\n\tget(schema) {\n\t\tconst p = schema._zod.parent;\n\t\tif (p) {\n\t\t\tconst pm = { ...this.get(p) ?? {} };\n\t\t\tdelete pm.id;\n\t\t\treturn {\n\t\t\t\t...pm,\n\t\t\t\t...this._map.get(schema)\n\t\t\t};\n\t\t}\n\t\treturn this._map.get(schema);\n\t}\n\thas(schema) {\n\t\treturn this._map.has(schema);\n\t}\n};\nfunction registry() {\n\treturn new $ZodRegistry();\n}\nconst globalRegistry = /* @__PURE__ */ registry();\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/core/api.js\nfunction _unknown(Class) {\n\treturn new Class({ type: \"unknown\" });\n}\nfunction _never(Class, params) {\n\treturn new Class({\n\t\ttype: \"never\",\n\t\t...normalizeParams(params)\n\t});\n}\nfunction _maxLength(maximum, params) {\n\treturn new $ZodCheckMaxLength({\n\t\tcheck: \"max_length\",\n\t\t...normalizeParams(params),\n\t\tmaximum\n\t});\n}\nfunction _minLength(minimum, params) {\n\treturn new $ZodCheckMinLength({\n\t\tcheck: \"min_length\",\n\t\t...normalizeParams(params),\n\t\tminimum\n\t});\n}\nfunction _length(length, params) {\n\treturn new $ZodCheckLengthEquals({\n\t\tcheck: \"length_equals\",\n\t\t...normalizeParams(params),\n\t\tlength\n\t});\n}\nfunction _overwrite(tx) {\n\treturn new $ZodCheckOverwrite({\n\t\tcheck: \"overwrite\",\n\t\ttx\n\t});\n}\nfunction _array(Class, element, params) {\n\treturn new Class({\n\t\ttype: \"array\",\n\t\telement,\n\t\t...normalizeParams(params)\n\t});\n}\nfunction _refine(Class, fn, _params) {\n\treturn new Class({\n\t\ttype: \"custom\",\n\t\tcheck: \"custom\",\n\t\tfn,\n\t\t...normalizeParams(_params)\n\t});\n}\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/errors.js\nconst initializer = (inst, issues) => {\n\t$ZodError.init(inst, issues);\n\tinst.name = \"ZodError\";\n\tObject.defineProperties(inst, {\n\t\tformat: { value: (mapper) => formatError(inst, mapper) },\n\t\tflatten: { value: (mapper) => flattenError(inst, mapper) },\n\t\taddIssue: { value: (issue$1) => inst.issues.push(issue$1) },\n\t\taddIssues: { value: (issues$1) => inst.issues.push(...issues$1) },\n\t\tisEmpty: { get() {\n\t\t\treturn inst.issues.length === 0;\n\t\t} }\n\t});\n};\nconst ZodError = $constructor(\"ZodError\", initializer);\nconst ZodRealError = $constructor(\"ZodError\", initializer, { Parent: Error });\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/parse.js\nconst parse = /* @__PURE__ */ _parse(ZodRealError);\nconst parseAsync = /* @__PURE__ */ _parseAsync(ZodRealError);\nconst safeParse = /* @__PURE__ */ _safeParse(ZodRealError);\nconst safeParseAsync = /* @__PURE__ */ _safeParseAsync(ZodRealError);\n\n//#endregion\n//#region node_modules/.pnpm/zod@4.0.1/node_modules/zod/v4/classic/schemas.js\nconst ZodType = /* @__PURE__ */ $constructor(\"ZodType\", (inst, def) => {\n\t$ZodType.init(inst, def);\n\tinst.def = def;\n\tObject.defineProperty(inst, \"_def\", { value: def });\n\tinst.check = (...checks) => {\n\t\treturn inst.clone({\n\t\t\t...def,\n\t\t\tchecks: [...def.checks ?? [], ...checks.map((ch) => typeof ch === \"function\" ? { _zod: {\n\t\t\t\tcheck: ch,\n\t\t\t\tdef: { check: \"custom\" },\n\t\t\t\tonattach: []\n\t\t\t} } : ch)]\n\t\t});\n\t};\n\tinst.clone = (def$1, params) => clone(inst, def$1, params);\n\tinst.brand = () => inst;\n\tinst.register = ((reg, meta) => {\n\t\treg.add(inst, meta);\n\t\treturn inst;\n\t});\n\tinst.parse = (data, params) => parse(inst, data, params, { callee: inst.parse });\n\tinst.safeParse = (data, params) => safeParse(inst, data, params);\n\tinst.parseAsync = async (data, params) => parseAsync(inst, data, params, { callee: inst.parseAsync });\n\tinst.safeParseAsync = async (data, params) => safeParseAsync(inst, data, params);\n\tinst.spa = inst.safeParseAsync;\n\tinst.refine = (check$1, params) => inst.check(refine(check$1, params));\n\tinst.superRefine = (refinement) => inst.check(superRefine(refinement));\n\tinst.overwrite = (fn) => inst.check(_overwrite(fn));\n\tinst.optional = () => optional(inst);\n\tinst.nullable = () => nullable(inst);\n\tinst.nullish = () => optional(nullable(inst));\n\tinst.nonoptional = (params) => nonoptional(inst, params);\n\tinst.array = () => array(inst);\n\tinst.or = (arg) => union([inst, arg]);\n\tinst.and = (arg) => intersection(inst, arg);\n\tinst.transform = (tx) => pipe(inst, transform(tx));\n\tinst.default = (def$1) => _default(inst, def$1);\n\tinst.prefault = (def$1) => prefault(inst, def$1);\n\tinst.catch = (params) => _catch(inst, params);\n\tinst.pipe = (target) => pipe(inst, target);\n\tinst.readonly = () => readonly(inst);\n\tinst.describe = (description) => {\n\t\tconst cl = inst.clone();\n\t\tglobalRegistry.add(cl, { description });\n\t\treturn cl;\n\t};\n\tObject.defineProperty(inst, \"description\", {\n\t\tget() {\n\t\t\treturn globalRegistry.get(inst)?.description;\n\t\t},\n\t\tconfigurable: true\n\t});\n\tinst.meta = (...args) => {\n\t\tif (args.length === 0) return globalRegistry.get(inst);\n\t\tconst cl = inst.clone();\n\t\tglobalRegistry.add(cl, args[0]);\n\t\treturn cl;\n\t};\n\tinst.isOptional = () => inst.safeParse(void 0).success;\n\tinst.isNullable = () => inst.safeParse(null).success;\n\treturn inst;\n});\nconst ZodUnknown = /* @__PURE__ */ $constructor(\"ZodUnknown\", (inst, def) => {\n\t$ZodUnknown.init(inst, def);\n\tZodType.init(inst, def);\n});\nfunction unknown() {\n\treturn _unknown(ZodUnknown);\n}\nconst ZodNever = /* @__PURE__ */ $constructor(\"ZodNever\", (inst, def) => {\n\t$ZodNever.init(inst, def);\n\tZodType.init(inst, def);\n});\nfunction never(params) {\n\treturn _never(ZodNever, params);\n}\nconst ZodArray = /* @__PURE__ */ $constructor(\"ZodArray\", (inst, def) => {\n\t$ZodArray.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.element = def.element;\n\tinst.min = (minLength, params) => inst.check(_minLength(minLength, params));\n\tinst.nonempty = (params) => inst.check(_minLength(1, params));\n\tinst.max = (maxLength, params) => inst.check(_maxLength(maxLength, params));\n\tinst.length = (len, params) => inst.check(_length(len, params));\n\tinst.unwrap = () => inst.element;\n});\nfunction array(element, params) {\n\treturn _array(ZodArray, element, params);\n}\nconst ZodObject = /* @__PURE__ */ $constructor(\"ZodObject\", (inst, def) => {\n\t$ZodObject.init(inst, def);\n\tZodType.init(inst, def);\n\tdefineLazy(inst, \"shape\", () => def.shape);\n\tinst.keyof = () => _enum(Object.keys(inst._zod.def.shape));\n\tinst.catchall = (catchall) => inst.clone({\n\t\t...inst._zod.def,\n\t\tcatchall\n\t});\n\tinst.passthrough = () => inst.clone({\n\t\t...inst._zod.def,\n\t\tcatchall: unknown()\n\t});\n\tinst.loose = () => inst.clone({\n\t\t...inst._zod.def,\n\t\tcatchall: unknown()\n\t});\n\tinst.strict = () => inst.clone({\n\t\t...inst._zod.def,\n\t\tcatchall: never()\n\t});\n\tinst.strip = () => inst.clone({\n\t\t...inst._zod.def,\n\t\tcatchall: void 0\n\t});\n\tinst.extend = (incoming) => {\n\t\treturn extend(inst, incoming);\n\t};\n\tinst.merge = (other) => merge(inst, other);\n\tinst.pick = (mask) => pick(inst, mask);\n\tinst.omit = (mask) => omit(inst, mask);\n\tinst.partial = (...args) => partial(ZodOptional, inst, args[0]);\n\tinst.required = (...args) => required(ZodNonOptional, inst, args[0]);\n});\nconst ZodUnion = /* @__PURE__ */ $constructor(\"ZodUnion\", (inst, def) => {\n\t$ZodUnion.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.options = def.options;\n});\nfunction union(options, params) {\n\treturn new ZodUnion({\n\t\ttype: \"union\",\n\t\toptions,\n\t\t...normalizeParams(params)\n\t});\n}\nconst ZodIntersection = /* @__PURE__ */ $constructor(\"ZodIntersection\", (inst, def) => {\n\t$ZodIntersection.init(inst, def);\n\tZodType.init(inst, def);\n});\nfunction intersection(left, right) {\n\treturn new ZodIntersection({\n\t\ttype: \"intersection\",\n\t\tleft,\n\t\tright\n\t});\n}\nconst ZodEnum = /* @__PURE__ */ $constructor(\"ZodEnum\", (inst, def) => {\n\t$ZodEnum.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.enum = def.entries;\n\tinst.options = Object.values(def.entries);\n\tconst keys = new Set(Object.keys(def.entries));\n\tinst.extract = (values, params) => {\n\t\tconst newEntries = {};\n\t\tfor (const value of values) if (keys.has(value)) newEntries[value] = def.entries[value];\n\t\telse throw new Error(`Key ${value} not found in enum`);\n\t\treturn new ZodEnum({\n\t\t\t...def,\n\t\t\tchecks: [],\n\t\t\t...normalizeParams(params),\n\t\t\tentries: newEntries\n\t\t});\n\t};\n\tinst.exclude = (values, params) => {\n\t\tconst newEntries = { ...def.entries };\n\t\tfor (const value of values) if (keys.has(value)) delete newEntries[value];\n\t\telse throw new Error(`Key ${value} not found in enum`);\n\t\treturn new ZodEnum({\n\t\t\t...def,\n\t\t\tchecks: [],\n\t\t\t...normalizeParams(params),\n\t\t\tentries: newEntries\n\t\t});\n\t};\n});\nfunction _enum(values, params) {\n\treturn new ZodEnum({\n\t\ttype: \"enum\",\n\t\tentries: Array.isArray(values) ? Object.fromEntries(values.map((v) => [v, v])) : values,\n\t\t...normalizeParams(params)\n\t});\n}\nconst ZodTransform = /* @__PURE__ */ $constructor(\"ZodTransform\", (inst, def) => {\n\t$ZodTransform.init(inst, def);\n\tZodType.init(inst, def);\n\tinst._zod.parse = (payload, _ctx) => {\n\t\tpayload.addIssue = (issue$1) => {\n\t\t\tif (typeof issue$1 === \"string\") payload.issues.push(issue(issue$1, payload.value, def));\n\t\t\telse {\n\t\t\t\tconst _issue = issue$1;\n\t\t\t\tif (_issue.fatal) _issue.continue = false;\n\t\t\t\t_issue.code ?? (_issue.code = \"custom\");\n\t\t\t\t_issue.input ?? (_issue.input = payload.value);\n\t\t\t\t_issue.inst ?? (_issue.inst = inst);\n\t\t\t\t_issue.continue ?? (_issue.continue = true);\n\t\t\t\tpayload.issues.push(issue(_issue));\n\t\t\t}\n\t\t};\n\t\tconst output = def.transform(payload.value, payload);\n\t\tif (output instanceof Promise) return output.then((output$1) => {\n\t\t\tpayload.value = output$1;\n\t\t\treturn payload;\n\t\t});\n\t\tpayload.value = output;\n\t\treturn payload;\n\t};\n});\nfunction transform(fn) {\n\treturn new ZodTransform({\n\t\ttype: \"transform\",\n\t\ttransform: fn\n\t});\n}\nconst ZodOptional = /* @__PURE__ */ $constructor(\"ZodOptional\", (inst, def) => {\n\t$ZodOptional.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.unwrap = () => inst._zod.def.innerType;\n});\nfunction optional(innerType) {\n\treturn new ZodOptional({\n\t\ttype: \"optional\",\n\t\tinnerType\n\t});\n}\nconst ZodNullable = /* @__PURE__ */ $constructor(\"ZodNullable\", (inst, def) => {\n\t$ZodNullable.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nullable(innerType) {\n\treturn new ZodNullable({\n\t\ttype: \"nullable\",\n\t\tinnerType\n\t});\n}\nconst ZodDefault = /* @__PURE__ */ $constructor(\"ZodDefault\", (inst, def) => {\n\t$ZodDefault.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.unwrap = () => inst._zod.def.innerType;\n\tinst.removeDefault = inst.unwrap;\n});\nfunction _default(innerType, defaultValue) {\n\treturn new ZodDefault({\n\t\ttype: \"default\",\n\t\tinnerType,\n\t\tget defaultValue() {\n\t\t\treturn typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n\t\t}\n\t});\n}\nconst ZodPrefault = /* @__PURE__ */ $constructor(\"ZodPrefault\", (inst, def) => {\n\t$ZodPrefault.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.unwrap = () => inst._zod.def.innerType;\n});\nfunction prefault(innerType, defaultValue) {\n\treturn new ZodPrefault({\n\t\ttype: \"prefault\",\n\t\tinnerType,\n\t\tget defaultValue() {\n\t\t\treturn typeof defaultValue === \"function\" ? defaultValue() : defaultValue;\n\t\t}\n\t});\n}\nconst ZodNonOptional = /* @__PURE__ */ $constructor(\"ZodNonOptional\", (inst, def) => {\n\t$ZodNonOptional.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.unwrap = () => inst._zod.def.innerType;\n});\nfunction nonoptional(innerType, params) {\n\treturn new ZodNonOptional({\n\t\ttype: \"nonoptional\",\n\t\tinnerType,\n\t\t...normalizeParams(params)\n\t});\n}\nconst ZodCatch = /* @__PURE__ */ $constructor(\"ZodCatch\", (inst, def) => {\n\t$ZodCatch.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.unwrap = () => inst._zod.def.innerType;\n\tinst.removeCatch = inst.unwrap;\n});\nfunction _catch(innerType, catchValue) {\n\treturn new ZodCatch({\n\t\ttype: \"catch\",\n\t\tinnerType,\n\t\tcatchValue: typeof catchValue === \"function\" ? catchValue : () => catchValue\n\t});\n}\nconst ZodPipe = /* @__PURE__ */ $constructor(\"ZodPipe\", (inst, def) => {\n\t$ZodPipe.init(inst, def);\n\tZodType.init(inst, def);\n\tinst.in = def.in;\n\tinst.out = def.out;\n});\nfunction pipe(in_, out) {\n\treturn new ZodPipe({\n\t\ttype: \"pipe\",\n\t\tin: in_,\n\t\tout\n\t});\n}\nconst ZodReadonly = /* @__PURE__ */ $constructor(\"ZodReadonly\", (inst, def) => {\n\t$ZodReadonly.init(inst, def);\n\tZodType.init(inst, def);\n});\nfunction readonly(innerType) {\n\treturn new ZodReadonly({\n\t\ttype: \"readonly\",\n\t\tinnerType\n\t});\n}\nconst ZodCustom = /* @__PURE__ */ $constructor(\"ZodCustom\", (inst, def) => {\n\t$ZodCustom.init(inst, def);\n\tZodType.init(inst, def);\n});\nfunction check(fn) {\n\tconst ch = new $ZodCheck({ check: \"custom\" });\n\tch._zod.check = fn;\n\treturn ch;\n}\nfunction refine(fn, _params = {}) {\n\treturn _refine(ZodCustom, fn, _params);\n}\nfunction superRefine(fn) {\n\tconst ch = check((payload) => {\n\t\tpayload.addIssue = (issue$1) => {\n\t\t\tif (typeof issue$1 === \"string\") payload.issues.push(issue(issue$1, payload.value, ch._zod.def));\n\t\t\telse {\n\t\t\t\tconst _issue = issue$1;\n\t\t\t\tif (_issue.fatal) _issue.continue = false;\n\t\t\t\t_issue.code ?? (_issue.code = \"custom\");\n\t\t\t\t_issue.input ?? (_issue.input = payload.value);\n\t\t\t\t_issue.inst ?? (_issue.inst = ch);\n\t\t\t\t_issue.continue ?? (_issue.continue = !ch._zod.def.abort);\n\t\t\t\tpayload.issues.push(issue(_issue));\n\t\t\t}\n\t\t};\n\t\treturn fn(payload.value, payload);\n\t});\n\treturn ch;\n}\n\n//#endregion\n//#region src/openapi.ts\nconst paths = {};\nfunction getTypeFromZodType(zodType) {\n\tswitch (zodType.constructor.name) {\n\t\tcase \"ZodString\": return \"string\";\n\t\tcase \"ZodNumber\": return \"number\";\n\t\tcase \"ZodBoolean\": return \"boolean\";\n\t\tcase \"ZodObject\": return \"object\";\n\t\tcase \"ZodArray\": return \"array\";\n\t\tdefault: return \"string\";\n\t}\n}\nfunction getParameters(options) {\n\tconst parameters = [];\n\tif (options.metadata?.openapi?.parameters) {\n\t\tparameters.push(...options.metadata.openapi.parameters);\n\t\treturn parameters;\n\t}\n\tif (options.query instanceof ZodObject) Object.entries(options.query.shape).forEach(([key, value]) => {\n\t\tif (value instanceof ZodObject) parameters.push({\n\t\t\tname: key,\n\t\t\tin: \"query\",\n\t\t\tschema: {\n\t\t\t\ttype: getTypeFromZodType(value),\n\t\t\t\t...\"minLength\" in value && value.minLength ? { minLength: value.minLength } : {},\n\t\t\t\tdescription: value.description\n\t\t\t}\n\t\t});\n\t});\n\treturn parameters;\n}\nfunction getRequestBody(options) {\n\tif (options.metadata?.openapi?.requestBody) return options.metadata.openapi.requestBody;\n\tif (!options.body) return void 0;\n\tif (options.body instanceof ZodObject || options.body instanceof ZodOptional) {\n\t\tconst shape = options.body.shape;\n\t\tif (!shape) return void 0;\n\t\tconst properties = {};\n\t\tconst required$1 = [];\n\t\tObject.entries(shape).forEach(([key, value]) => {\n\t\t\tif (value instanceof ZodObject) {\n\t\t\t\tproperties[key] = {\n\t\t\t\t\ttype: getTypeFromZodType(value),\n\t\t\t\t\tdescription: value.description\n\t\t\t\t};\n\t\t\t\tif (!(value instanceof ZodOptional)) required$1.push(key);\n\t\t\t}\n\t\t});\n\t\treturn {\n\t\t\trequired: options.body instanceof ZodOptional ? false : options.body ? true : false,\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties,\n\t\t\t\trequired: required$1\n\t\t\t} } }\n\t\t};\n\t}\n}\nfunction getResponse(responses) {\n\treturn {\n\t\t\"400\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } },\n\t\t\t\trequired: [\"message\"]\n\t\t\t} } },\n\t\t\tdescription: \"Bad Request. Usually due to missing parameters, or invalid parameters.\"\n\t\t},\n\t\t\"401\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } },\n\t\t\t\trequired: [\"message\"]\n\t\t\t} } },\n\t\t\tdescription: \"Unauthorized. Due to missing or invalid authentication.\"\n\t\t},\n\t\t\"403\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t} } },\n\t\t\tdescription: \"Forbidden. You do not have permission to access this resource or to perform this action.\"\n\t\t},\n\t\t\"404\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t} } },\n\t\t\tdescription: \"Not Found. The requested resource was not found.\"\n\t\t},\n\t\t\"429\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t} } },\n\t\t\tdescription: \"Too Many Requests. You have exceeded the rate limit. Try again later.\"\n\t\t},\n\t\t\"500\": {\n\t\t\tcontent: { \"application/json\": { schema: {\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: { message: { type: \"string\" } }\n\t\t\t} } },\n\t\t\tdescription: \"Internal Server Error. This is a problem with the server that you cannot fix.\"\n\t\t},\n\t\t...responses\n\t};\n}\nasync function generator(endpoints, config$1) {\n\tconst components = { schemas: {} };\n\tObject.entries(endpoints).forEach(([_, value]) => {\n\t\tconst options = value.options;\n\t\tif (!value.path || options.metadata?.SERVER_ONLY) return;\n\t\tif (options.method === \"GET\") paths[value.path] = { get: {\n\t\t\ttags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n\t\t\tdescription: options.metadata?.openapi?.description,\n\t\t\toperationId: options.metadata?.openapi?.operationId,\n\t\t\tsecurity: [{ bearerAuth: [] }],\n\t\t\tparameters: getParameters(options),\n\t\t\tresponses: getResponse(options.metadata?.openapi?.responses)\n\t\t} };\n\t\tif (options.method === \"POST\") {\n\t\t\tconst body = getRequestBody(options);\n\t\t\tpaths[value.path] = { post: {\n\t\t\t\ttags: [\"Default\", ...options.metadata?.openapi?.tags || []],\n\t\t\t\tdescription: options.metadata?.openapi?.description,\n\t\t\t\toperationId: options.metadata?.openapi?.operationId,\n\t\t\t\tsecurity: [{ bearerAuth: [] }],\n\t\t\t\tparameters: getParameters(options),\n\t\t\t\t...body ? { requestBody: body } : { requestBody: { content: { \"application/json\": { schema: {\n\t\t\t\t\ttype: \"object\",\n\t\t\t\t\tproperties: {}\n\t\t\t\t} } } } },\n\t\t\t\tresponses: getResponse(options.metadata?.openapi?.responses)\n\t\t\t} };\n\t\t}\n\t});\n\treturn {\n\t\topenapi: \"3.1.1\",\n\t\tinfo: {\n\t\t\ttitle: \"Better Auth\",\n\t\t\tdescription: \"API Reference for your Better Auth Instance\",\n\t\t\tversion: \"1.1.0\"\n\t\t},\n\t\tcomponents,\n\t\tsecurity: [{ apiKeyCookie: [] }],\n\t\tservers: [{ url: config$1?.url }],\n\t\ttags: [{\n\t\t\tname: \"Default\",\n\t\t\tdescription: \"Default endpoints that are included with Better Auth by default. These endpoints are not part of any plugin.\"\n\t\t}],\n\t\tpaths\n\t};\n}\nconst getHTML = (apiReference, config$1) => `<!doctype html>\n<html>\n  <head>\n    <title>Scalar API Reference</title>\n    <meta charset=\"utf-8\" />\n    <meta\n      name=\"viewport\"\n      content=\"width=device-width, initial-scale=1\" />\n  </head>\n  <body>\n    <script\n      id=\"api-reference\"\n      type=\"application/json\">\n    ${JSON.stringify(apiReference)}\n    <\\/script>\n\t <script>\n      var configuration = {\n\t  \tfavicon: ${config$1?.logo ? `data:image/svg+xml;utf8,${encodeURIComponent(config$1.logo)}` : void 0} ,\n\t   \ttheme: ${config$1?.theme || \"saturn\"},\n        metaData: {\n\t\t\ttitle: ${config$1?.title || \"Open API Reference\"},\n\t\t\tdescription: ${config$1?.description || \"Better Call Open API\"},\n\t\t}\n      }\n      document.getElementById('api-reference').dataset.configuration =\n        JSON.stringify(configuration)\n    <\\/script>\n\t  <script src=\"https://cdn.jsdelivr.net/npm/@scalar/api-reference\"><\\/script>\n  </body>\n</html>`;\n\n//#endregion\n//#region src/router.ts\nconst createRouter = (endpoints, config$1) => {\n\tif (!config$1?.openapi?.disabled) {\n\t\tconst openapi = {\n\t\t\tpath: \"/api/reference\",\n\t\t\t...config$1?.openapi\n\t\t};\n\t\tendpoints[\"openapi\"] = createEndpoint(openapi.path, { method: \"GET\" }, async (c) => {\n\t\t\tconst schema = await generator(endpoints);\n\t\t\treturn new Response(getHTML(schema, openapi.scalar), { headers: { \"Content-Type\": \"text/html\" } });\n\t\t});\n\t}\n\tconst router = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n\tconst middlewareRouter = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.createRouter)();\n\tfor (const endpoint of Object.values(endpoints)) {\n\t\tif (!endpoint.options || !endpoint.path) continue;\n\t\tif (endpoint.options?.metadata?.SERVER_ONLY) continue;\n\t\tconst methods = Array.isArray(endpoint.options?.method) ? endpoint.options.method : [endpoint.options?.method];\n\t\tfor (const method of methods) (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(router, method, endpoint.path, endpoint);\n\t}\n\tif (config$1?.routerMiddleware?.length) for (const { path, middleware } of config$1.routerMiddleware) (0,rou3__WEBPACK_IMPORTED_MODULE_1__.addRoute)(middlewareRouter, \"*\", path, middleware);\n\tconst processRequest = async (request) => {\n\t\tconst url = new URL(request.url);\n\t\tconst path = config$1?.basePath ? url.pathname.split(config$1.basePath).reduce((acc, curr, index) => {\n\t\t\tif (index !== 0) if (index > 1) acc.push(`${config$1.basePath}${curr}`);\n\t\t\telse acc.push(curr);\n\t\t\treturn acc;\n\t\t}, []).join(\"\") : url.pathname;\n\t\tif (!path?.length) return new Response(null, {\n\t\t\tstatus: 404,\n\t\t\tstatusText: \"Not Found\"\n\t\t});\n\t\tconst route = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findRoute)(router, request.method, path);\n\t\tif (!route?.data) return new Response(null, {\n\t\t\tstatus: 404,\n\t\t\tstatusText: \"Not Found\"\n\t\t});\n\t\tconst query = {};\n\t\turl.searchParams.forEach((value, key) => {\n\t\t\tif (key in query) if (Array.isArray(query[key])) query[key].push(value);\n\t\t\telse query[key] = [query[key], value];\n\t\t\telse query[key] = value;\n\t\t});\n\t\tconst handler = route.data;\n\t\ttry {\n\t\t\tconst allowedMediaTypes = handler.options.metadata?.allowedMediaTypes || config$1?.allowedMediaTypes;\n\t\t\tconst context = {\n\t\t\t\tpath,\n\t\t\t\tmethod: request.method,\n\t\t\t\theaders: request.headers,\n\t\t\t\tparams: route.params ? JSON.parse(JSON.stringify(route.params)) : {},\n\t\t\t\trequest,\n\t\t\t\tbody: handler.options.disableBody ? void 0 : await getBody(handler.options.cloneRequest ? request.clone() : request, allowedMediaTypes),\n\t\t\t\tquery,\n\t\t\t\t_flag: \"router\",\n\t\t\t\tasResponse: true,\n\t\t\t\tcontext: config$1?.routerContext\n\t\t\t};\n\t\t\tconst middlewareRoutes = (0,rou3__WEBPACK_IMPORTED_MODULE_1__.findAllRoutes)(middlewareRouter, \"*\", path);\n\t\t\tif (middlewareRoutes?.length) for (const { data: middleware, params } of middlewareRoutes) {\n\t\t\t\tconst res = await middleware({\n\t\t\t\t\t...context,\n\t\t\t\t\tparams,\n\t\t\t\t\tasResponse: false\n\t\t\t\t});\n\t\t\t\tif (res instanceof Response) return res;\n\t\t\t}\n\t\t\treturn await handler(context);\n\t\t} catch (error) {\n\t\t\tif (config$1?.onError) try {\n\t\t\t\tconst errorResponse = await config$1.onError(error);\n\t\t\t\tif (errorResponse instanceof Response) return toResponse(errorResponse);\n\t\t\t} catch (error$1) {\n\t\t\t\tif (isAPIError(error$1)) return toResponse(error$1);\n\t\t\t\tthrow error$1;\n\t\t\t}\n\t\t\tif (config$1?.throwError) throw error;\n\t\t\tif (isAPIError(error)) return toResponse(error);\n\t\t\tconsole.error(`# SERVER_ERROR: `, error);\n\t\t\treturn new Response(null, {\n\t\t\t\tstatus: 500,\n\t\t\t\tstatusText: \"Internal Server Error\"\n\t\t\t});\n\t\t}\n\t};\n\treturn {\n\t\thandler: async (request) => {\n\t\t\tconst onReq = await config$1?.onRequest?.(request);\n\t\t\tif (onReq instanceof Response) return onReq;\n\t\t\tconst res = await processRequest(onReq instanceof Request ? onReq : request);\n\t\t\tconst onRes = await config$1?.onResponse?.(res);\n\t\t\tif (onRes instanceof Response) return onRes;\n\t\t\treturn res;\n\t\t},\n\t\tendpoints\n\t};\n};\n\n//#endregion\n\n//# sourceMappingURL=index.js.map//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHJzYykvLi9ub2RlX21vZHVsZXMvYmV0dGVyLWNhbGwvZGlzdC9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBd0Q7QUFDa0M7O0FBRTFGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMEVBQTBFO0FBQzFFLHVDQUF1QyxvQkFBb0I7QUFDM0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1FQUFtRTtBQUNuRTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EseURBQXlELDZCQUE2QjtBQUN0RjtBQUNBLElBQUk7QUFDSjtBQUNBLDhCQUE4QixZQUFZLG1DQUFt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QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHLElBQUk7QUFDUDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLGFBQWEsTUFBTTtBQUM3RDtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZCQUE2QjtBQUM3QjtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FB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O0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsSUFBSTtBQUNKO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsMENBQTBDLG9EQUFvRDtBQUM5RjtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSxHQUFHO0FBQ0g7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNB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QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQSx1QkFBdUI7QUFDdkI7QUFDQSw4QkFBOEIsT0FBTztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsR0FBRztBQUNIO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxFQUFFO0FBQ0Y7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7QUFDRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQztBQUNEO0FBQ0EsNEJBQTRCLGlCQUFpQjtBQUM3QztBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEVBQUU7QUFDRjtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsbURBQW1ELDZCQUE2QixJQUFJO0FBQ3BGO0FBQ0E7QUFDQSxHQUFHO0FBQ0gsRUFBRTtBQUNGO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FB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QUNBO0FBQ0E7QUFDQTtBQUNBLElBQUk7QUFDSjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEdBQUc7QUFDSDtBQUNBO0FBQ0E7O0FBRUE7QUFDa1I7QUFDbFIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly9hdXRoLWFwcC8uL25vZGVfbW9kdWxlcy9iZXR0ZXItY2FsbC9kaXN0L2luZGV4LmpzP2QwMDMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZ2V0V2ViY3J5cHRvU3VidGxlIH0gZnJvbSBcIkBiZXR0ZXItYXV0aC91dGlsc1wiO1xuaW1wb3J0IHsgYWRkUm91dGUsIGNyZWF0ZVJvdXRlciBhcyBjcmVhdGVSb3V0ZXIkMSwgZmluZEFsbFJvdXRlcywgZmluZFJvdXRlIH0gZnJvbSBcInJvdTNcIjtcblxuLy8jcmVnaW9uIHNyYy9lcnJvci50c1xuZnVuY3Rpb24gaXNFcnJvclN0YWNrVHJhY2VMaW1pdFdyaXRhYmxlKCkge1xuXHRjb25zdCBkZXNjID0gT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihFcnJvciwgXCJzdGFja1RyYWNlTGltaXRcIik7XG5cdGlmIChkZXNjID09PSB2b2lkIDApIHJldHVybiBPYmplY3QuaXNFeHRlbnNpYmxlKEVycm9yKTtcblx0cmV0dXJuIE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChkZXNjLCBcIndyaXRhYmxlXCIpID8gZGVzYy53cml0YWJsZSA6IGRlc2Muc2V0ICE9PSB2b2lkIDA7XG59XG4vKipcbiogSGlkZSBpbnRlcm5hbCBzdGFjayBmcmFtZXMgZnJvbSB0aGUgZXJyb3Igc3RhY2sgdHJhY2UuXG4qL1xuZnVuY3Rpb24gaGlkZUludGVybmFsU3RhY2tGcmFtZXMoc3RhY2spIHtcblx0Y29uc3QgbGluZXMgPSBzdGFjay5zcGxpdChcIlxcbiAgICBhdCBcIik7XG5cdGlmIChsaW5lcy5sZW5ndGggPD0gMSkgcmV0dXJuIHN0YWNrO1xuXHRsaW5lcy5zcGxpY2UoMSwgMSk7XG5cdHJldHVybiBsaW5lcy5qb2luKFwiXFxuICAgIGF0IFwiKTtcbn1cbi8qKlxuKiBDcmVhdGVzIGEgY3VzdG9tIGVycm9yIGNsYXNzIHRoYXQgaGlkZXMgc3RhY2sgZnJhbWVzLlxuKi9cbmZ1bmN0aW9uIG1ha2VFcnJvckZvckhpZGVTdGFja0ZyYW1lKEJhc2UsIGNsYXp6KSB7XG5cdGNsYXNzIEhpZGVTdGFja0ZyYW1lc0Vycm9yIGV4dGVuZHMgQmFzZSB7XG5cdFx0I2hpZGRlblN0YWNrO1xuXHRcdGNvbnN0cnVjdG9yKC4uLmFyZ3MpIHtcblx0XHRcdGlmIChpc0Vycm9yU3RhY2tUcmFjZUxpbWl0V3JpdGFibGUoKSkge1xuXHRcdFx0XHRjb25zdCBsaW1pdCA9IEVycm9yLnN0YWNrVHJhY2VMaW1pdDtcblx0XHRcdFx0RXJyb3Iuc3RhY2tUcmFjZUxpbWl0ID0gMDtcblx0XHRcdFx0c3VwZXIoLi4uYXJncyk7XG5cdFx0XHRcdEVycm9yLnN0YWNrVHJhY2VMaW1pdCA9IGxpbWl0O1xuXHRcdFx0fSBlbHNlIHN1cGVyKC4uLmFyZ3MpO1xuXHRcdFx0Y29uc3Qgc3RhY2sgPSAoLyogQF9fUFVSRV9fICovIG5ldyBFcnJvcigpKS5zdGFjaztcblx0XHRcdGlmIChzdGFjaykgdGhpcy4jaGlkZGVuU3RhY2sgPSBoaWRlSW50ZXJuYWxTdGFja0ZyYW1lcyhzdGFjay5yZXBsYWNlKC9eRXJyb3IvLCB0aGlzLm5hbWUpKTtcblx0XHR9XG5cdFx0Z2V0IGVycm9yU3RhY2soKSB7XG5cdFx0XHRyZXR1cm4gdGhpcy4jaGlkZGVuU3RhY2s7XG5cdFx0fVxuXHR9XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShIaWRlU3RhY2tGcmFtZXNFcnJvci5wcm90b3R5cGUsIFwiY29uc3RydWN0b3JcIiwge1xuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiBjbGF6ejtcblx0XHR9LFxuXHRcdGVudW1lcmFibGU6IGZhbHNlLFxuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHR9KTtcblx0cmV0dXJuIEhpZGVTdGFja0ZyYW1lc0Vycm9yO1xufVxuY29uc3Qgc3RhdHVzQ29kZXMgPSB7XG5cdE9LOiAyMDAsXG5cdENSRUFURUQ6IDIwMSxcblx0QUNDRVBURUQ6IDIwMixcblx0Tk9fQ09OVEVOVDogMjA0LFxuXHRNVUxUSVBMRV9DSE9JQ0VTOiAzMDAsXG5cdE1PVkVEX1BFUk1BTkVOVExZOiAzMDEsXG5cdEZPVU5EOiAzMDIsXG5cdFNFRV9PVEhFUjogMzAzLFxuXHROT1RfTU9ESUZJRUQ6IDMwNCxcblx0VEVNUE9SQVJZX1JFRElSRUNUOiAzMDcsXG5cdEJBRF9SRVFVRVNUOiA0MDAsXG5cdFVOQVVUSE9SSVpFRDogNDAxLFxuXHRQQVlNRU5UX1JFUVVJUkVEOiA0MDIsXG5cdEZPUkJJRERFTjogNDAzLFxuXHROT1RfRk9VTkQ6IDQwNCxcblx0TUVUSE9EX05PVF9BTExPV0VEOiA0MDUsXG5cdE5PVF9BQ0NFUFRBQkxFOiA0MDYsXG5cdFBST1hZX0FVVEhFTlRJQ0FUSU9OX1JFUVVJUkVEOiA0MDcsXG5cdFJFUVVFU1RfVElNRU9VVDogNDA4LFxuXHRDT05GTElDVDogNDA5LFxuXHRHT05FOiA0MTAsXG5cdExFTkdUSF9SRVFVSVJFRDogNDExLFxuXHRQUkVDT05ESVRJT05fRkFJTEVEOiA0MTIsXG5cdFBBWUxPQURfVE9PX0xBUkdFOiA0MTMsXG5cdFVSSV9UT09fTE9ORzogNDE0LFxuXHRVTlNVUFBPUlRFRF9NRURJQV9UWVBFOiA0MTUsXG5cdFJBTkdFX05PVF9TQVRJU0ZJQUJMRTogNDE2LFxuXHRFWFBFQ1RBVElPTl9GQUlMRUQ6IDQxNyxcblx0XCJJJ01fQV9URUFQT1RcIjogNDE4LFxuXHRNSVNESVJFQ1RFRF9SRVFVRVNUOiA0MjEsXG5cdFVOUFJPQ0VTU0FCTEVfRU5USVRZOiA0MjIsXG5cdExPQ0tFRDogNDIzLFxuXHRGQUlMRURfREVQRU5ERU5DWTogNDI0LFxuXHRUT09fRUFSTFk6IDQyNSxcblx0VVBHUkFERV9SRVFVSVJFRDogNDI2LFxuXHRQUkVDT05ESVRJT05fUkVRVUlSRUQ6IDQyOCxcblx0VE9PX01BTllfUkVRVUVTVFM6IDQyOSxcblx0UkVRVUVTVF9IRUFERVJfRklFTERTX1RPT19MQVJHRTogNDMxLFxuXHRVTkFWQUlMQUJMRV9GT1JfTEVHQUxfUkVBU09OUzogNDUxLFxuXHRJTlRFUk5BTF9TRVJWRVJfRVJST1I6IDUwMCxcblx0Tk9UX0lNUExFTUVOVEVEOiA1MDEsXG5cdEJBRF9HQVRFV0FZOiA1MDIsXG5cdFNFUlZJQ0VfVU5BVkFJTEFCTEU6IDUwMyxcblx0R0FURVdBWV9USU1FT1VUOiA1MDQsXG5cdEhUVFBfVkVSU0lPTl9OT1RfU1VQUE9SVEVEOiA1MDUsXG5cdFZBUklBTlRfQUxTT19ORUdPVElBVEVTOiA1MDYsXG5cdElOU1VGRklDSUVOVF9TVE9SQUdFOiA1MDcsXG5cdExPT1BfREVURUNURUQ6IDUwOCxcblx0Tk9UX0VYVEVOREVEOiA1MTAsXG5cdE5FVFdPUktfQVVUSEVOVElDQVRJT05fUkVRVUlSRUQ6IDUxMVxufTtcbnZhciBJbnRlcm5hbEFQSUVycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKHN0YXR1cyA9IFwiSU5URVJOQUxfU0VSVkVSX0VSUk9SXCIsIGJvZHkgPSB2b2lkIDAsIGhlYWRlcnMgPSB7fSwgc3RhdHVzQ29kZSA9IHR5cGVvZiBzdGF0dXMgPT09IFwibnVtYmVyXCIgPyBzdGF0dXMgOiBzdGF0dXNDb2Rlc1tzdGF0dXNdKSB7XG5cdFx0c3VwZXIoYm9keT8ubWVzc2FnZSwgYm9keT8uY2F1c2UgPyB7IGNhdXNlOiBib2R5LmNhdXNlIH0gOiB2b2lkIDApO1xuXHRcdHRoaXMuc3RhdHVzID0gc3RhdHVzO1xuXHRcdHRoaXMuYm9keSA9IGJvZHk7XG5cdFx0dGhpcy5oZWFkZXJzID0gaGVhZGVycztcblx0XHR0aGlzLnN0YXR1c0NvZGUgPSBzdGF0dXNDb2RlO1xuXHRcdHRoaXMubmFtZSA9IFwiQVBJRXJyb3JcIjtcblx0XHR0aGlzLnN0YXR1cyA9IHN0YXR1cztcblx0XHR0aGlzLmhlYWRlcnMgPSBoZWFkZXJzO1xuXHRcdHRoaXMuc3RhdHVzQ29kZSA9IHN0YXR1c0NvZGU7XG5cdFx0dGhpcy5ib2R5ID0gYm9keSA/IHtcblx0XHRcdGNvZGU6IGJvZHk/Lm1lc3NhZ2U/LnRvVXBwZXJDYXNlKCkucmVwbGFjZSgvIC9nLCBcIl9cIikucmVwbGFjZSgvW15BLVowLTlfXS9nLCBcIlwiKSxcblx0XHRcdC4uLmJvZHlcblx0XHR9IDogdm9pZCAwO1xuXHR9XG59O1xudmFyIEJldHRlckNhbGxFcnJvciA9IGNsYXNzIGV4dGVuZHMgRXJyb3Ige1xuXHRjb25zdHJ1Y3RvcihtZXNzYWdlKSB7XG5cdFx0c3VwZXIobWVzc2FnZSk7XG5cdFx0dGhpcy5uYW1lID0gXCJCZXR0ZXJDYWxsRXJyb3JcIjtcblx0fVxufTtcbmNvbnN0IEFQSUVycm9yID0gbWFrZUVycm9yRm9ySGlkZVN0YWNrRnJhbWUoSW50ZXJuYWxBUElFcnJvciwgRXJyb3IpO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdXRpbHMudHNcbmFzeW5jIGZ1bmN0aW9uIGdldEJvZHkocmVxdWVzdCwgYWxsb3dlZE1lZGlhVHlwZXMpIHtcblx0Y29uc3QgY29udGVudFR5cGUgPSByZXF1ZXN0LmhlYWRlcnMuZ2V0KFwiY29udGVudC10eXBlXCIpIHx8IFwiXCI7XG5cdGNvbnN0IG5vcm1hbGl6ZWRDb250ZW50VHlwZSA9IGNvbnRlbnRUeXBlLnRvTG93ZXJDYXNlKCk7XG5cdGlmICghcmVxdWVzdC5ib2R5KSByZXR1cm47XG5cdGlmIChhbGxvd2VkTWVkaWFUeXBlcyAmJiBhbGxvd2VkTWVkaWFUeXBlcy5sZW5ndGggPiAwKSB7XG5cdFx0aWYgKCFhbGxvd2VkTWVkaWFUeXBlcy5zb21lKChhbGxvd2VkKSA9PiB7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkQ29udGVudFR5cGVCYXNlID0gbm9ybWFsaXplZENvbnRlbnRUeXBlLnNwbGl0KFwiO1wiKVswXS50cmltKCk7XG5cdFx0XHRjb25zdCBub3JtYWxpemVkQWxsb3dlZCA9IGFsbG93ZWQudG9Mb3dlckNhc2UoKS50cmltKCk7XG5cdFx0XHRyZXR1cm4gbm9ybWFsaXplZENvbnRlbnRUeXBlQmFzZSA9PT0gbm9ybWFsaXplZEFsbG93ZWQgfHwgbm9ybWFsaXplZENvbnRlbnRUeXBlQmFzZS5pbmNsdWRlcyhub3JtYWxpemVkQWxsb3dlZCk7XG5cdFx0fSkpIHtcblx0XHRcdGlmICghbm9ybWFsaXplZENvbnRlbnRUeXBlKSB0aHJvdyBuZXcgQVBJRXJyb3IoNDE1LCB7XG5cdFx0XHRcdG1lc3NhZ2U6IGBDb250ZW50LVR5cGUgaXMgcmVxdWlyZWQuIEFsbG93ZWQgdHlwZXM6ICR7YWxsb3dlZE1lZGlhVHlwZXMuam9pbihcIiwgXCIpfWAsXG5cdFx0XHRcdGNvZGU6IFwiVU5TVVBQT1JURURfTUVESUFfVFlQRVwiXG5cdFx0XHR9KTtcblx0XHRcdHRocm93IG5ldyBBUElFcnJvcig0MTUsIHtcblx0XHRcdFx0bWVzc2FnZTogYENvbnRlbnQtVHlwZSBcIiR7Y29udGVudFR5cGV9XCIgaXMgbm90IGFsbG93ZWQuIEFsbG93ZWQgdHlwZXM6ICR7YWxsb3dlZE1lZGlhVHlwZXMuam9pbihcIiwgXCIpfWAsXG5cdFx0XHRcdGNvZGU6IFwiVU5TVVBQT1JURURfTUVESUFfVFlQRVwiXG5cdFx0XHR9KTtcblx0XHR9XG5cdH1cblx0aWYgKG5vcm1hbGl6ZWRDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL2pzb25cIikpIHJldHVybiBhd2FpdCByZXF1ZXN0Lmpzb24oKTtcblx0aWYgKG5vcm1hbGl6ZWRDb250ZW50VHlwZS5pbmNsdWRlcyhcImFwcGxpY2F0aW9uL3gtd3d3LWZvcm0tdXJsZW5jb2RlZFwiKSkge1xuXHRcdGNvbnN0IGZvcm1EYXRhID0gYXdhaXQgcmVxdWVzdC5mb3JtRGF0YSgpO1xuXHRcdGNvbnN0IHJlc3VsdCA9IHt9O1xuXHRcdGZvcm1EYXRhLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcblx0XHRcdHJlc3VsdFtrZXldID0gdmFsdWUudG9TdHJpbmcoKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGlmIChub3JtYWxpemVkQ29udGVudFR5cGUuaW5jbHVkZXMoXCJtdWx0aXBhcnQvZm9ybS1kYXRhXCIpKSB7XG5cdFx0Y29uc3QgZm9ybURhdGEgPSBhd2FpdCByZXF1ZXN0LmZvcm1EYXRhKCk7XG5cdFx0Y29uc3QgcmVzdWx0ID0ge307XG5cdFx0Zm9ybURhdGEuZm9yRWFjaCgodmFsdWUsIGtleSkgPT4ge1xuXHRcdFx0cmVzdWx0W2tleV0gPSB2YWx1ZTtcblx0XHR9KTtcblx0XHRyZXR1cm4gcmVzdWx0O1xuXHR9XG5cdGlmIChub3JtYWxpemVkQ29udGVudFR5cGUuaW5jbHVkZXMoXCJ0ZXh0L3BsYWluXCIpKSByZXR1cm4gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG5cdGlmIChub3JtYWxpemVkQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIikpIHJldHVybiBhd2FpdCByZXF1ZXN0LmFycmF5QnVmZmVyKCk7XG5cdGlmIChub3JtYWxpemVkQ29udGVudFR5cGUuaW5jbHVkZXMoXCJhcHBsaWNhdGlvbi9wZGZcIikgfHwgbm9ybWFsaXplZENvbnRlbnRUeXBlLmluY2x1ZGVzKFwiaW1hZ2UvXCIpIHx8IG5vcm1hbGl6ZWRDb250ZW50VHlwZS5pbmNsdWRlcyhcInZpZGVvL1wiKSkgcmV0dXJuIGF3YWl0IHJlcXVlc3QuYmxvYigpO1xuXHRpZiAobm9ybWFsaXplZENvbnRlbnRUeXBlLmluY2x1ZGVzKFwiYXBwbGljYXRpb24vc3RyZWFtXCIpIHx8IHJlcXVlc3QuYm9keSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSByZXR1cm4gcmVxdWVzdC5ib2R5O1xuXHRyZXR1cm4gYXdhaXQgcmVxdWVzdC50ZXh0KCk7XG59XG5mdW5jdGlvbiBpc0FQSUVycm9yKGVycm9yKSB7XG5cdHJldHVybiBlcnJvciBpbnN0YW5jZW9mIEFQSUVycm9yIHx8IGVycm9yPy5uYW1lID09PSBcIkFQSUVycm9yXCI7XG59XG5mdW5jdGlvbiB0cnlEZWNvZGUoc3RyKSB7XG5cdHRyeSB7XG5cdFx0cmV0dXJuIHN0ci5pbmNsdWRlcyhcIiVcIikgPyBkZWNvZGVVUklDb21wb25lbnQoc3RyKSA6IHN0cjtcblx0fSBjYXRjaCB7XG5cdFx0cmV0dXJuIHN0cjtcblx0fVxufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvdG8tcmVzcG9uc2UudHNcbmZ1bmN0aW9uIGlzSlNPTlNlcmlhbGl6YWJsZSh2YWx1ZSkge1xuXHRpZiAodmFsdWUgPT09IHZvaWQgMCkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCB0ID0gdHlwZW9mIHZhbHVlO1xuXHRpZiAodCA9PT0gXCJzdHJpbmdcIiB8fCB0ID09PSBcIm51bWJlclwiIHx8IHQgPT09IFwiYm9vbGVhblwiIHx8IHQgPT09IG51bGwpIHJldHVybiB0cnVlO1xuXHRpZiAodCAhPT0gXCJvYmplY3RcIikgcmV0dXJuIGZhbHNlO1xuXHRpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHJldHVybiB0cnVlO1xuXHRpZiAodmFsdWUuYnVmZmVyKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiB2YWx1ZS5jb25zdHJ1Y3RvciAmJiB2YWx1ZS5jb25zdHJ1Y3Rvci5uYW1lID09PSBcIk9iamVjdFwiIHx8IHR5cGVvZiB2YWx1ZS50b0pTT04gPT09IFwiZnVuY3Rpb25cIjtcbn1cbmZ1bmN0aW9uIHNhZmVTdHJpbmdpZnkob2JqLCByZXBsYWNlciwgc3BhY2UpIHtcblx0bGV0IGlkID0gMDtcblx0Y29uc3Qgc2VlbiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgV2Vha01hcCgpO1xuXHRjb25zdCBzYWZlUmVwbGFjZXIgPSAoa2V5LCB2YWx1ZSkgPT4ge1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwiYmlnaW50XCIpIHJldHVybiB2YWx1ZS50b1N0cmluZygpO1xuXHRcdGlmICh0eXBlb2YgdmFsdWUgPT09IFwib2JqZWN0XCIgJiYgdmFsdWUgIT09IG51bGwpIHtcblx0XHRcdGlmIChzZWVuLmhhcyh2YWx1ZSkpIHJldHVybiBgW0NpcmN1bGFyIHJlZi0ke3NlZW4uZ2V0KHZhbHVlKX1dYDtcblx0XHRcdHNlZW4uc2V0KHZhbHVlLCBpZCsrKTtcblx0XHR9XG5cdFx0aWYgKHJlcGxhY2VyKSByZXR1cm4gcmVwbGFjZXIoa2V5LCB2YWx1ZSk7XG5cdFx0cmV0dXJuIHZhbHVlO1xuXHR9O1xuXHRyZXR1cm4gSlNPTi5zdHJpbmdpZnkob2JqLCBzYWZlUmVwbGFjZXIsIHNwYWNlKTtcbn1cbmZ1bmN0aW9uIGlzSlNPTlJlc3BvbnNlKHZhbHVlKSB7XG5cdGlmICghdmFsdWUgfHwgdHlwZW9mIHZhbHVlICE9PSBcIm9iamVjdFwiKSByZXR1cm4gZmFsc2U7XG5cdHJldHVybiBcIl9mbGFnXCIgaW4gdmFsdWUgJiYgdmFsdWUuX2ZsYWcgPT09IFwianNvblwiO1xufVxuZnVuY3Rpb24gdG9SZXNwb25zZShkYXRhLCBpbml0KSB7XG5cdGlmIChkYXRhIGluc3RhbmNlb2YgUmVzcG9uc2UpIHtcblx0XHRpZiAoaW5pdD8uaGVhZGVycyBpbnN0YW5jZW9mIEhlYWRlcnMpIGluaXQuaGVhZGVycy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG5cdFx0XHRkYXRhLmhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuXHRcdH0pO1xuXHRcdHJldHVybiBkYXRhO1xuXHR9XG5cdGlmIChpc0pTT05SZXNwb25zZShkYXRhKSkge1xuXHRcdGNvbnN0IGJvZHkkMSA9IGRhdGEuYm9keTtcblx0XHRjb25zdCByb3V0ZXJSZXNwb25zZSA9IGRhdGEucm91dGVyUmVzcG9uc2U7XG5cdFx0aWYgKHJvdXRlclJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHJldHVybiByb3V0ZXJSZXNwb25zZTtcblx0XHRjb25zdCBoZWFkZXJzJDEgPSBuZXcgSGVhZGVycygpO1xuXHRcdGlmIChyb3V0ZXJSZXNwb25zZT8uaGVhZGVycykge1xuXHRcdFx0Y29uc3QgaGVhZGVycyQyID0gbmV3IEhlYWRlcnMocm91dGVyUmVzcG9uc2UuaGVhZGVycyk7XG5cdFx0XHRmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBoZWFkZXJzJDIuZW50cmllcygpKSBoZWFkZXJzJDIuc2V0KGtleSwgdmFsdWUpO1xuXHRcdH1cblx0XHRpZiAoZGF0YS5oZWFkZXJzKSBmb3IgKGNvbnN0IFtrZXksIHZhbHVlXSBvZiBuZXcgSGVhZGVycyhkYXRhLmhlYWRlcnMpLmVudHJpZXMoKSkgaGVhZGVycyQxLnNldChrZXksIHZhbHVlKTtcblx0XHRpZiAoaW5pdD8uaGVhZGVycykgZm9yIChjb25zdCBba2V5LCB2YWx1ZV0gb2YgbmV3IEhlYWRlcnMoaW5pdC5oZWFkZXJzKS5lbnRyaWVzKCkpIGhlYWRlcnMkMS5zZXQoa2V5LCB2YWx1ZSk7XG5cdFx0aGVhZGVycyQxLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL2pzb25cIik7XG5cdFx0cmV0dXJuIG5ldyBSZXNwb25zZShKU09OLnN0cmluZ2lmeShib2R5JDEpLCB7XG5cdFx0XHQuLi5yb3V0ZXJSZXNwb25zZSxcblx0XHRcdGhlYWRlcnM6IGhlYWRlcnMkMSxcblx0XHRcdHN0YXR1czogZGF0YS5zdGF0dXMgPz8gaW5pdD8uc3RhdHVzID8/IHJvdXRlclJlc3BvbnNlPy5zdGF0dXMsXG5cdFx0XHRzdGF0dXNUZXh0OiBpbml0Py5zdGF0dXNUZXh0ID8/IHJvdXRlclJlc3BvbnNlPy5zdGF0dXNUZXh0XG5cdFx0fSk7XG5cdH1cblx0aWYgKGlzQVBJRXJyb3IoZGF0YSkpIHJldHVybiB0b1Jlc3BvbnNlKGRhdGEuYm9keSwge1xuXHRcdHN0YXR1czogaW5pdD8uc3RhdHVzID8/IGRhdGEuc3RhdHVzQ29kZSxcblx0XHRzdGF0dXNUZXh0OiBkYXRhLnN0YXR1cy50b1N0cmluZygpLFxuXHRcdGhlYWRlcnM6IGluaXQ/LmhlYWRlcnMgfHwgZGF0YS5oZWFkZXJzXG5cdH0pO1xuXHRsZXQgYm9keSA9IGRhdGE7XG5cdGxldCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoaW5pdD8uaGVhZGVycyk7XG5cdGlmICghZGF0YSkge1xuXHRcdGlmIChkYXRhID09PSBudWxsKSBib2R5ID0gSlNPTi5zdHJpbmdpZnkobnVsbCk7XG5cdFx0aGVhZGVycy5zZXQoXCJjb250ZW50LXR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHR9IGVsc2UgaWYgKHR5cGVvZiBkYXRhID09PSBcInN0cmluZ1wiKSB7XG5cdFx0Ym9keSA9IGRhdGE7XG5cdFx0aGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJ0ZXh0L3BsYWluXCIpO1xuXHR9IGVsc2UgaWYgKGRhdGEgaW5zdGFuY2VvZiBBcnJheUJ1ZmZlciB8fCBBcnJheUJ1ZmZlci5pc1ZpZXcoZGF0YSkpIHtcblx0XHRib2R5ID0gZGF0YTtcblx0XHRoZWFkZXJzLnNldChcIkNvbnRlbnQtVHlwZVwiLCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKTtcblx0fSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgQmxvYikge1xuXHRcdGJvZHkgPSBkYXRhO1xuXHRcdGhlYWRlcnMuc2V0KFwiQ29udGVudC1UeXBlXCIsIGRhdGEudHlwZSB8fCBcImFwcGxpY2F0aW9uL29jdGV0LXN0cmVhbVwiKTtcblx0fSBlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgRm9ybURhdGEpIGJvZHkgPSBkYXRhO1xuXHRlbHNlIGlmIChkYXRhIGluc3RhbmNlb2YgVVJMU2VhcmNoUGFyYW1zKSB7XG5cdFx0Ym9keSA9IGRhdGE7XG5cdFx0aGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi94LXd3dy1mb3JtLXVybGVuY29kZWRcIik7XG5cdH0gZWxzZSBpZiAoZGF0YSBpbnN0YW5jZW9mIFJlYWRhYmxlU3RyZWFtKSB7XG5cdFx0Ym9keSA9IGRhdGE7XG5cdFx0aGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9vY3RldC1zdHJlYW1cIik7XG5cdH0gZWxzZSBpZiAoaXNKU09OU2VyaWFsaXphYmxlKGRhdGEpKSB7XG5cdFx0Ym9keSA9IHNhZmVTdHJpbmdpZnkoZGF0YSk7XG5cdFx0aGVhZGVycy5zZXQoXCJDb250ZW50LVR5cGVcIiwgXCJhcHBsaWNhdGlvbi9qc29uXCIpO1xuXHR9XG5cdHJldHVybiBuZXcgUmVzcG9uc2UoYm9keSwge1xuXHRcdC4uLmluaXQsXG5cdFx0aGVhZGVyc1xuXHR9KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL3ZhbGlkYXRvci50c1xuLyoqXG4qIFJ1bnMgdmFsaWRhdGlvbiBvbiBib2R5IGFuZCBxdWVyeVxuKiBAcmV0dXJucyBlcnJvciBhbmQgZGF0YSBvYmplY3RcbiovXG5hc3luYyBmdW5jdGlvbiBydW5WYWxpZGF0aW9uKG9wdGlvbnMsIGNvbnRleHQgPSB7fSkge1xuXHRsZXQgcmVxdWVzdCA9IHtcblx0XHRib2R5OiBjb250ZXh0LmJvZHksXG5cdFx0cXVlcnk6IGNvbnRleHQucXVlcnlcblx0fTtcblx0aWYgKG9wdGlvbnMuYm9keSkge1xuXHRcdGNvbnN0IHJlc3VsdCA9IGF3YWl0IG9wdGlvbnMuYm9keVtcIn5zdGFuZGFyZFwiXS52YWxpZGF0ZShjb250ZXh0LmJvZHkpO1xuXHRcdGlmIChyZXN1bHQuaXNzdWVzKSByZXR1cm4ge1xuXHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdGVycm9yOiBmcm9tRXJyb3IocmVzdWx0Lmlzc3VlcywgXCJib2R5XCIpXG5cdFx0fTtcblx0XHRyZXF1ZXN0LmJvZHkgPSByZXN1bHQudmFsdWU7XG5cdH1cblx0aWYgKG9wdGlvbnMucXVlcnkpIHtcblx0XHRjb25zdCByZXN1bHQgPSBhd2FpdCBvcHRpb25zLnF1ZXJ5W1wifnN0YW5kYXJkXCJdLnZhbGlkYXRlKGNvbnRleHQucXVlcnkpO1xuXHRcdGlmIChyZXN1bHQuaXNzdWVzKSByZXR1cm4ge1xuXHRcdFx0ZGF0YTogbnVsbCxcblx0XHRcdGVycm9yOiBmcm9tRXJyb3IocmVzdWx0Lmlzc3VlcywgXCJxdWVyeVwiKVxuXHRcdH07XG5cdFx0cmVxdWVzdC5xdWVyeSA9IHJlc3VsdC52YWx1ZTtcblx0fVxuXHRpZiAob3B0aW9ucy5yZXF1aXJlSGVhZGVycyAmJiAhY29udGV4dC5oZWFkZXJzKSByZXR1cm4ge1xuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZXJyb3I6IHsgbWVzc2FnZTogXCJIZWFkZXJzIGlzIHJlcXVpcmVkXCIgfVxuXHR9O1xuXHRpZiAob3B0aW9ucy5yZXF1aXJlUmVxdWVzdCAmJiAhY29udGV4dC5yZXF1ZXN0KSByZXR1cm4ge1xuXHRcdGRhdGE6IG51bGwsXG5cdFx0ZXJyb3I6IHsgbWVzc2FnZTogXCJSZXF1ZXN0IGlzIHJlcXVpcmVkXCIgfVxuXHR9O1xuXHRyZXR1cm4ge1xuXHRcdGRhdGE6IHJlcXVlc3QsXG5cdFx0ZXJyb3I6IG51bGxcblx0fTtcbn1cbmZ1bmN0aW9uIGZyb21FcnJvcihlcnJvciwgdmFsaWRhdGluZykge1xuXHRjb25zdCBlcnJvck1lc3NhZ2VzID0gW107XG5cdGZvciAoY29uc3QgaXNzdWUkMSBvZiBlcnJvcikge1xuXHRcdGNvbnN0IG1lc3NhZ2UgPSBpc3N1ZSQxLm1lc3NhZ2U7XG5cdFx0ZXJyb3JNZXNzYWdlcy5wdXNoKG1lc3NhZ2UpO1xuXHR9XG5cdHJldHVybiB7IG1lc3NhZ2U6IGBJbnZhbGlkICR7dmFsaWRhdGluZ30gcGFyYW1ldGVyc2AgfTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2NyeXB0by50c1xuY29uc3QgYWxnb3JpdGhtID0ge1xuXHRuYW1lOiBcIkhNQUNcIixcblx0aGFzaDogXCJTSEEtMjU2XCJcbn07XG5jb25zdCBnZXRDcnlwdG9LZXkgPSBhc3luYyAoc2VjcmV0KSA9PiB7XG5cdGNvbnN0IHNlY3JldEJ1ZiA9IHR5cGVvZiBzZWNyZXQgPT09IFwic3RyaW5nXCIgPyBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUoc2VjcmV0KSA6IHNlY3JldDtcblx0cmV0dXJuIGF3YWl0IGdldFdlYmNyeXB0b1N1YnRsZSgpLmltcG9ydEtleShcInJhd1wiLCBzZWNyZXRCdWYsIGFsZ29yaXRobSwgZmFsc2UsIFtcInNpZ25cIiwgXCJ2ZXJpZnlcIl0pO1xufTtcbmNvbnN0IHZlcmlmeVNpZ25hdHVyZSA9IGFzeW5jIChiYXNlNjRTaWduYXR1cmUsIHZhbHVlLCBzZWNyZXQpID0+IHtcblx0dHJ5IHtcblx0XHRjb25zdCBzaWduYXR1cmVCaW5TdHIgPSBhdG9iKGJhc2U2NFNpZ25hdHVyZSk7XG5cdFx0Y29uc3Qgc2lnbmF0dXJlID0gbmV3IFVpbnQ4QXJyYXkoc2lnbmF0dXJlQmluU3RyLmxlbmd0aCk7XG5cdFx0Zm9yIChsZXQgaSA9IDAsIGxlbiA9IHNpZ25hdHVyZUJpblN0ci5sZW5ndGg7IGkgPCBsZW47IGkrKykgc2lnbmF0dXJlW2ldID0gc2lnbmF0dXJlQmluU3RyLmNoYXJDb2RlQXQoaSk7XG5cdFx0cmV0dXJuIGF3YWl0IGdldFdlYmNyeXB0b1N1YnRsZSgpLnZlcmlmeShhbGdvcml0aG0sIHNlY3JldCwgc2lnbmF0dXJlLCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpKTtcblx0fSBjYXRjaCAoZSkge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufTtcbmNvbnN0IG1ha2VTaWduYXR1cmUgPSBhc3luYyAodmFsdWUsIHNlY3JldCkgPT4ge1xuXHRjb25zdCBrZXkgPSBhd2FpdCBnZXRDcnlwdG9LZXkoc2VjcmV0KTtcblx0Y29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgZ2V0V2ViY3J5cHRvU3VidGxlKCkuc2lnbihhbGdvcml0aG0ubmFtZSwga2V5LCBuZXcgVGV4dEVuY29kZXIoKS5lbmNvZGUodmFsdWUpKTtcblx0cmV0dXJuIGJ0b2EoU3RyaW5nLmZyb21DaGFyQ29kZSguLi5uZXcgVWludDhBcnJheShzaWduYXR1cmUpKSk7XG59O1xuY29uc3Qgc2lnbkNvb2tpZVZhbHVlID0gYXN5bmMgKHZhbHVlLCBzZWNyZXQpID0+IHtcblx0Y29uc3Qgc2lnbmF0dXJlID0gYXdhaXQgbWFrZVNpZ25hdHVyZSh2YWx1ZSwgc2VjcmV0KTtcblx0dmFsdWUgPSBgJHt2YWx1ZX0uJHtzaWduYXR1cmV9YDtcblx0dmFsdWUgPSBlbmNvZGVVUklDb21wb25lbnQodmFsdWUpO1xuXHRyZXR1cm4gdmFsdWU7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvY29va2llcy50c1xuY29uc3QgZ2V0Q29va2llS2V5ID0gKGtleSwgcHJlZml4KSA9PiB7XG5cdGxldCBmaW5hbEtleSA9IGtleTtcblx0aWYgKHByZWZpeCkgaWYgKHByZWZpeCA9PT0gXCJzZWN1cmVcIikgZmluYWxLZXkgPSBcIl9fU2VjdXJlLVwiICsga2V5O1xuXHRlbHNlIGlmIChwcmVmaXggPT09IFwiaG9zdFwiKSBmaW5hbEtleSA9IFwiX19Ib3N0LVwiICsga2V5O1xuXHRlbHNlIHJldHVybjtcblx0cmV0dXJuIGZpbmFsS2V5O1xufTtcbi8qKlxuKiBQYXJzZSBhbiBIVFRQIENvb2tpZSBoZWFkZXIgc3RyaW5nIGFuZCByZXR1cm5pbmcgYW4gb2JqZWN0IG9mIGFsbCBjb29raWVcbiogbmFtZS12YWx1ZSBwYWlycy5cbipcbiogSW5zcGlyZWQgYnkgaHR0cHM6Ly9naXRodWIuY29tL3VuanMvY29va2llLWVzL2Jsb2IvbWFpbi9zcmMvY29va2llL3BhcnNlLnRzXG4qXG4qIEBwYXJhbSBzdHIgdGhlIHN0cmluZyByZXByZXNlbnRpbmcgYSBgQ29va2llYCBoZWFkZXIgdmFsdWVcbiovXG5mdW5jdGlvbiBwYXJzZUNvb2tpZXMoc3RyKSB7XG5cdGlmICh0eXBlb2Ygc3RyICE9PSBcInN0cmluZ1wiKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiYXJndW1lbnQgc3RyIG11c3QgYmUgYSBzdHJpbmdcIik7XG5cdGNvbnN0IGNvb2tpZXMgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuXHRsZXQgaW5kZXggPSAwO1xuXHR3aGlsZSAoaW5kZXggPCBzdHIubGVuZ3RoKSB7XG5cdFx0Y29uc3QgZXFJZHggPSBzdHIuaW5kZXhPZihcIj1cIiwgaW5kZXgpO1xuXHRcdGlmIChlcUlkeCA9PT0gLTEpIGJyZWFrO1xuXHRcdGxldCBlbmRJZHggPSBzdHIuaW5kZXhPZihcIjtcIiwgaW5kZXgpO1xuXHRcdGlmIChlbmRJZHggPT09IC0xKSBlbmRJZHggPSBzdHIubGVuZ3RoO1xuXHRcdGVsc2UgaWYgKGVuZElkeCA8IGVxSWR4KSB7XG5cdFx0XHRpbmRleCA9IHN0ci5sYXN0SW5kZXhPZihcIjtcIiwgZXFJZHggLSAxKSArIDE7XG5cdFx0XHRjb250aW51ZTtcblx0XHR9XG5cdFx0Y29uc3Qga2V5ID0gc3RyLnNsaWNlKGluZGV4LCBlcUlkeCkudHJpbSgpO1xuXHRcdGlmICghY29va2llcy5oYXMoa2V5KSkge1xuXHRcdFx0bGV0IHZhbCA9IHN0ci5zbGljZShlcUlkeCArIDEsIGVuZElkeCkudHJpbSgpO1xuXHRcdFx0aWYgKHZhbC5jb2RlUG9pbnRBdCgwKSA9PT0gMzQpIHZhbCA9IHZhbC5zbGljZSgxLCAtMSk7XG5cdFx0XHRjb29raWVzLnNldChrZXksIHRyeURlY29kZSh2YWwpKTtcblx0XHR9XG5cdFx0aW5kZXggPSBlbmRJZHggKyAxO1xuXHR9XG5cdHJldHVybiBjb29raWVzO1xufVxuY29uc3QgX3NlcmlhbGl6ZSA9IChrZXksIHZhbHVlLCBvcHQgPSB7fSkgPT4ge1xuXHRsZXQgY29va2llO1xuXHRpZiAob3B0Py5wcmVmaXggPT09IFwic2VjdXJlXCIpIGNvb2tpZSA9IGAke2BfX1NlY3VyZS0ke2tleX1gfT0ke3ZhbHVlfWA7XG5cdGVsc2UgaWYgKG9wdD8ucHJlZml4ID09PSBcImhvc3RcIikgY29va2llID0gYCR7YF9fSG9zdC0ke2tleX1gfT0ke3ZhbHVlfWA7XG5cdGVsc2UgY29va2llID0gYCR7a2V5fT0ke3ZhbHVlfWA7XG5cdGlmIChrZXkuc3RhcnRzV2l0aChcIl9fU2VjdXJlLVwiKSAmJiAhb3B0LnNlY3VyZSkgb3B0LnNlY3VyZSA9IHRydWU7XG5cdGlmIChrZXkuc3RhcnRzV2l0aChcIl9fSG9zdC1cIikpIHtcblx0XHRpZiAoIW9wdC5zZWN1cmUpIG9wdC5zZWN1cmUgPSB0cnVlO1xuXHRcdGlmIChvcHQucGF0aCAhPT0gXCIvXCIpIG9wdC5wYXRoID0gXCIvXCI7XG5cdFx0aWYgKG9wdC5kb21haW4pIG9wdC5kb21haW4gPSB2b2lkIDA7XG5cdH1cblx0aWYgKG9wdCAmJiB0eXBlb2Ygb3B0Lm1heEFnZSA9PT0gXCJudW1iZXJcIiAmJiBvcHQubWF4QWdlID49IDApIHtcblx0XHRpZiAob3B0Lm1heEFnZSA+IDM0NTZlNCkgdGhyb3cgbmV3IEVycm9yKFwiQ29va2llcyBNYXgtQWdlIFNIT1VMRCBOT1QgYmUgZ3JlYXRlciB0aGFuIDQwMCBkYXlzICgzNDU2MDAwMCBzZWNvbmRzKSBpbiBkdXJhdGlvbi5cIik7XG5cdFx0Y29va2llICs9IGA7IE1heC1BZ2U9JHtNYXRoLmZsb29yKG9wdC5tYXhBZ2UpfWA7XG5cdH1cblx0aWYgKG9wdC5kb21haW4gJiYgb3B0LnByZWZpeCAhPT0gXCJob3N0XCIpIGNvb2tpZSArPSBgOyBEb21haW49JHtvcHQuZG9tYWlufWA7XG5cdGlmIChvcHQucGF0aCkgY29va2llICs9IGA7IFBhdGg9JHtvcHQucGF0aH1gO1xuXHRpZiAob3B0LmV4cGlyZXMpIHtcblx0XHRpZiAob3B0LmV4cGlyZXMuZ2V0VGltZSgpIC0gRGF0ZS5ub3coKSA+IDM0NTZlNykgdGhyb3cgbmV3IEVycm9yKFwiQ29va2llcyBFeHBpcmVzIFNIT1VMRCBOT1QgYmUgZ3JlYXRlciB0aGFuIDQwMCBkYXlzICgzNDU2MDAwMCBzZWNvbmRzKSBpbiB0aGUgZnV0dXJlLlwiKTtcblx0XHRjb29raWUgKz0gYDsgRXhwaXJlcz0ke29wdC5leHBpcmVzLnRvVVRDU3RyaW5nKCl9YDtcblx0fVxuXHRpZiAob3B0Lmh0dHBPbmx5KSBjb29raWUgKz0gXCI7IEh0dHBPbmx5XCI7XG5cdGlmIChvcHQuc2VjdXJlKSBjb29raWUgKz0gXCI7IFNlY3VyZVwiO1xuXHRpZiAob3B0LnNhbWVTaXRlKSBjb29raWUgKz0gYDsgU2FtZVNpdGU9JHtvcHQuc2FtZVNpdGUuY2hhckF0KDApLnRvVXBwZXJDYXNlKCkgKyBvcHQuc2FtZVNpdGUuc2xpY2UoMSl9YDtcblx0aWYgKG9wdC5wYXJ0aXRpb25lZCkge1xuXHRcdGlmICghb3B0LnNlY3VyZSkgb3B0LnNlY3VyZSA9IHRydWU7XG5cdFx0Y29va2llICs9IFwiOyBQYXJ0aXRpb25lZFwiO1xuXHR9XG5cdHJldHVybiBjb29raWU7XG59O1xuY29uc3Qgc2VyaWFsaXplQ29va2llID0gKGtleSwgdmFsdWUsIG9wdCkgPT4ge1xuXHR2YWx1ZSA9IGVuY29kZVVSSUNvbXBvbmVudCh2YWx1ZSk7XG5cdHJldHVybiBfc2VyaWFsaXplKGtleSwgdmFsdWUsIG9wdCk7XG59O1xuY29uc3Qgc2VyaWFsaXplU2lnbmVkQ29va2llID0gYXN5bmMgKGtleSwgdmFsdWUsIHNlY3JldCwgb3B0KSA9PiB7XG5cdHZhbHVlID0gYXdhaXQgc2lnbkNvb2tpZVZhbHVlKHZhbHVlLCBzZWNyZXQpO1xuXHRyZXR1cm4gX3NlcmlhbGl6ZShrZXksIHZhbHVlLCBvcHQpO1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL2NvbnRleHQudHNcbmNvbnN0IGNyZWF0ZUludGVybmFsQ29udGV4dCA9IGFzeW5jIChjb250ZXh0LCB7IG9wdGlvbnMsIHBhdGggfSkgPT4ge1xuXHRjb25zdCBoZWFkZXJzID0gbmV3IEhlYWRlcnMoKTtcblx0bGV0IHJlc3BvbnNlU3RhdHVzID0gdm9pZCAwO1xuXHRjb25zdCB7IGRhdGEsIGVycm9yIH0gPSBhd2FpdCBydW5WYWxpZGF0aW9uKG9wdGlvbnMsIGNvbnRleHQpO1xuXHRpZiAoZXJyb3IpIHRocm93IG5ldyBBUElFcnJvcig0MDAsIHtcblx0XHRtZXNzYWdlOiBlcnJvci5tZXNzYWdlLFxuXHRcdGNvZGU6IFwiVkFMSURBVElPTl9FUlJPUlwiXG5cdH0pO1xuXHRjb25zdCByZXF1ZXN0SGVhZGVycyA9IFwiaGVhZGVyc1wiIGluIGNvbnRleHQgPyBjb250ZXh0LmhlYWRlcnMgaW5zdGFuY2VvZiBIZWFkZXJzID8gY29udGV4dC5oZWFkZXJzIDogbmV3IEhlYWRlcnMoY29udGV4dC5oZWFkZXJzKSA6IFwicmVxdWVzdFwiIGluIGNvbnRleHQgJiYgY29udGV4dC5yZXF1ZXN0IGluc3RhbmNlb2YgUmVxdWVzdCA/IGNvbnRleHQucmVxdWVzdC5oZWFkZXJzIDogbnVsbDtcblx0Y29uc3QgcmVxdWVzdENvb2tpZXMgPSByZXF1ZXN0SGVhZGVycz8uZ2V0KFwiY29va2llXCIpO1xuXHRjb25zdCBwYXJzZWRDb29raWVzID0gcmVxdWVzdENvb2tpZXMgPyBwYXJzZUNvb2tpZXMocmVxdWVzdENvb2tpZXMpIDogdm9pZCAwO1xuXHRjb25zdCBpbnRlcm5hbENvbnRleHQgPSB7XG5cdFx0Li4uY29udGV4dCxcblx0XHRib2R5OiBkYXRhLmJvZHksXG5cdFx0cXVlcnk6IGRhdGEucXVlcnksXG5cdFx0cGF0aDogY29udGV4dC5wYXRoIHx8IHBhdGggfHwgXCJ2aXJ0dWFsOlwiLFxuXHRcdGNvbnRleHQ6IFwiY29udGV4dFwiIGluIGNvbnRleHQgJiYgY29udGV4dC5jb250ZXh0ID8gY29udGV4dC5jb250ZXh0IDoge30sXG5cdFx0cmV0dXJuZWQ6IHZvaWQgMCxcblx0XHRoZWFkZXJzOiBjb250ZXh0Py5oZWFkZXJzLFxuXHRcdHJlcXVlc3Q6IGNvbnRleHQ/LnJlcXVlc3QsXG5cdFx0cGFyYW1zOiBcInBhcmFtc1wiIGluIGNvbnRleHQgPyBjb250ZXh0LnBhcmFtcyA6IHZvaWQgMCxcblx0XHRtZXRob2Q6IGNvbnRleHQubWV0aG9kLFxuXHRcdHNldEhlYWRlcjogKGtleSwgdmFsdWUpID0+IHtcblx0XHRcdGhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuXHRcdH0sXG5cdFx0Z2V0SGVhZGVyOiAoa2V5KSA9PiB7XG5cdFx0XHRpZiAoIXJlcXVlc3RIZWFkZXJzKSByZXR1cm4gbnVsbDtcblx0XHRcdHJldHVybiByZXF1ZXN0SGVhZGVycy5nZXQoa2V5KTtcblx0XHR9LFxuXHRcdGdldENvb2tpZTogKGtleSwgcHJlZml4KSA9PiB7XG5cdFx0XHRjb25zdCBmaW5hbEtleSA9IGdldENvb2tpZUtleShrZXksIHByZWZpeCk7XG5cdFx0XHRpZiAoIWZpbmFsS2V5KSByZXR1cm4gbnVsbDtcblx0XHRcdHJldHVybiBwYXJzZWRDb29raWVzPy5nZXQoZmluYWxLZXkpIHx8IG51bGw7XG5cdFx0fSxcblx0XHRnZXRTaWduZWRDb29raWU6IGFzeW5jIChrZXksIHNlY3JldCwgcHJlZml4KSA9PiB7XG5cdFx0XHRjb25zdCBmaW5hbEtleSA9IGdldENvb2tpZUtleShrZXksIHByZWZpeCk7XG5cdFx0XHRpZiAoIWZpbmFsS2V5KSByZXR1cm4gbnVsbDtcblx0XHRcdGNvbnN0IHZhbHVlID0gcGFyc2VkQ29va2llcz8uZ2V0KGZpbmFsS2V5KTtcblx0XHRcdGlmICghdmFsdWUpIHJldHVybiBudWxsO1xuXHRcdFx0Y29uc3Qgc2lnbmF0dXJlU3RhcnRQb3MgPSB2YWx1ZS5sYXN0SW5kZXhPZihcIi5cIik7XG5cdFx0XHRpZiAoc2lnbmF0dXJlU3RhcnRQb3MgPCAxKSByZXR1cm4gbnVsbDtcblx0XHRcdGNvbnN0IHNpZ25lZFZhbHVlID0gdmFsdWUuc3Vic3RyaW5nKDAsIHNpZ25hdHVyZVN0YXJ0UG9zKTtcblx0XHRcdGNvbnN0IHNpZ25hdHVyZSA9IHZhbHVlLnN1YnN0cmluZyhzaWduYXR1cmVTdGFydFBvcyArIDEpO1xuXHRcdFx0aWYgKHNpZ25hdHVyZS5sZW5ndGggIT09IDQ0IHx8ICFzaWduYXR1cmUuZW5kc1dpdGgoXCI9XCIpKSByZXR1cm4gbnVsbDtcblx0XHRcdHJldHVybiBhd2FpdCB2ZXJpZnlTaWduYXR1cmUoc2lnbmF0dXJlLCBzaWduZWRWYWx1ZSwgYXdhaXQgZ2V0Q3J5cHRvS2V5KHNlY3JldCkpID8gc2lnbmVkVmFsdWUgOiBmYWxzZTtcblx0XHR9LFxuXHRcdHNldENvb2tpZTogKGtleSwgdmFsdWUsIG9wdGlvbnMkMSkgPT4ge1xuXHRcdFx0Y29uc3QgY29va2llID0gc2VyaWFsaXplQ29va2llKGtleSwgdmFsdWUsIG9wdGlvbnMkMSk7XG5cdFx0XHRoZWFkZXJzLmFwcGVuZChcInNldC1jb29raWVcIiwgY29va2llKTtcblx0XHRcdHJldHVybiBjb29raWU7XG5cdFx0fSxcblx0XHRzZXRTaWduZWRDb29raWU6IGFzeW5jIChrZXksIHZhbHVlLCBzZWNyZXQsIG9wdGlvbnMkMSkgPT4ge1xuXHRcdFx0Y29uc3QgY29va2llID0gYXdhaXQgc2VyaWFsaXplU2lnbmVkQ29va2llKGtleSwgdmFsdWUsIHNlY3JldCwgb3B0aW9ucyQxKTtcblx0XHRcdGhlYWRlcnMuYXBwZW5kKFwic2V0LWNvb2tpZVwiLCBjb29raWUpO1xuXHRcdFx0cmV0dXJuIGNvb2tpZTtcblx0XHR9LFxuXHRcdHJlZGlyZWN0OiAodXJsKSA9PiB7XG5cdFx0XHRoZWFkZXJzLnNldChcImxvY2F0aW9uXCIsIHVybCk7XG5cdFx0XHRyZXR1cm4gbmV3IEFQSUVycm9yKFwiRk9VTkRcIiwgdm9pZCAwLCBoZWFkZXJzKTtcblx0XHR9LFxuXHRcdGVycm9yOiAoc3RhdHVzLCBib2R5LCBoZWFkZXJzJDEpID0+IHtcblx0XHRcdHJldHVybiBuZXcgQVBJRXJyb3Ioc3RhdHVzLCBib2R5LCBoZWFkZXJzJDEpO1xuXHRcdH0sXG5cdFx0c2V0U3RhdHVzOiAoc3RhdHVzKSA9PiB7XG5cdFx0XHRyZXNwb25zZVN0YXR1cyA9IHN0YXR1cztcblx0XHR9LFxuXHRcdGpzb246IChqc29uLCByb3V0ZXJSZXNwb25zZSkgPT4ge1xuXHRcdFx0aWYgKCFjb250ZXh0LmFzUmVzcG9uc2UpIHJldHVybiBqc29uO1xuXHRcdFx0cmV0dXJuIHtcblx0XHRcdFx0Ym9keTogcm91dGVyUmVzcG9uc2U/LmJvZHkgfHwganNvbixcblx0XHRcdFx0cm91dGVyUmVzcG9uc2UsXG5cdFx0XHRcdF9mbGFnOiBcImpzb25cIlxuXHRcdFx0fTtcblx0XHR9LFxuXHRcdHJlc3BvbnNlSGVhZGVyczogaGVhZGVycyxcblx0XHRnZXQgcmVzcG9uc2VTdGF0dXMoKSB7XG5cdFx0XHRyZXR1cm4gcmVzcG9uc2VTdGF0dXM7XG5cdFx0fVxuXHR9O1xuXHRmb3IgKGNvbnN0IG1pZGRsZXdhcmUgb2Ygb3B0aW9ucy51c2UgfHwgW10pIHtcblx0XHRjb25zdCByZXNwb25zZSA9IGF3YWl0IG1pZGRsZXdhcmUoe1xuXHRcdFx0Li4uaW50ZXJuYWxDb250ZXh0LFxuXHRcdFx0cmV0dXJuSGVhZGVyczogdHJ1ZSxcblx0XHRcdGFzUmVzcG9uc2U6IGZhbHNlXG5cdFx0fSk7XG5cdFx0aWYgKHJlc3BvbnNlLnJlc3BvbnNlKSBPYmplY3QuYXNzaWduKGludGVybmFsQ29udGV4dC5jb250ZXh0LCByZXNwb25zZS5yZXNwb25zZSk7XG5cdFx0LyoqXG5cdFx0KiBBcHBseSBoZWFkZXJzIGZyb20gdGhlIG1pZGRsZXdhcmUgdG8gdGhlIGVuZHBvaW50IGhlYWRlcnNcblx0XHQqL1xuXHRcdGlmIChyZXNwb25zZS5oZWFkZXJzKSByZXNwb25zZS5oZWFkZXJzLmZvckVhY2goKHZhbHVlLCBrZXkpID0+IHtcblx0XHRcdGludGVybmFsQ29udGV4dC5yZXNwb25zZUhlYWRlcnMuc2V0KGtleSwgdmFsdWUpO1xuXHRcdH0pO1xuXHR9XG5cdHJldHVybiBpbnRlcm5hbENvbnRleHQ7XG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvZW5kcG9pbnQudHNcbmZ1bmN0aW9uIGNyZWF0ZUVuZHBvaW50KHBhdGhPck9wdGlvbnMsIGhhbmRsZXJPck9wdGlvbnMsIGhhbmRsZXJPck5ldmVyKSB7XG5cdGNvbnN0IHBhdGggPSB0eXBlb2YgcGF0aE9yT3B0aW9ucyA9PT0gXCJzdHJpbmdcIiA/IHBhdGhPck9wdGlvbnMgOiB2b2lkIDA7XG5cdGNvbnN0IG9wdGlvbnMgPSB0eXBlb2YgaGFuZGxlck9yT3B0aW9ucyA9PT0gXCJvYmplY3RcIiA/IGhhbmRsZXJPck9wdGlvbnMgOiBwYXRoT3JPcHRpb25zO1xuXHRjb25zdCBoYW5kbGVyID0gdHlwZW9mIGhhbmRsZXJPck9wdGlvbnMgPT09IFwiZnVuY3Rpb25cIiA/IGhhbmRsZXJPck9wdGlvbnMgOiBoYW5kbGVyT3JOZXZlcjtcblx0aWYgKChvcHRpb25zLm1ldGhvZCA9PT0gXCJHRVRcIiB8fCBvcHRpb25zLm1ldGhvZCA9PT0gXCJIRUFEXCIpICYmIG9wdGlvbnMuYm9keSkgdGhyb3cgbmV3IEJldHRlckNhbGxFcnJvcihcIkJvZHkgaXMgbm90IGFsbG93ZWQgd2l0aCBHRVQgb3IgSEVBRCBtZXRob2RzXCIpO1xuXHRjb25zdCBpbnRlcm5hbEhhbmRsZXIgPSBhc3luYyAoLi4uaW5wdXRDdHgpID0+IHtcblx0XHRjb25zdCBjb250ZXh0ID0gaW5wdXRDdHhbMF0gfHwge307XG5cdFx0Y29uc3QgaW50ZXJuYWxDb250ZXh0ID0gYXdhaXQgY3JlYXRlSW50ZXJuYWxDb250ZXh0KGNvbnRleHQsIHtcblx0XHRcdG9wdGlvbnMsXG5cdFx0XHRwYXRoXG5cdFx0fSk7XG5cdFx0Y29uc3QgcmVzcG9uc2UgPSBhd2FpdCBoYW5kbGVyKGludGVybmFsQ29udGV4dCkuY2F0Y2goYXN5bmMgKGUpID0+IHtcblx0XHRcdGlmIChpc0FQSUVycm9yKGUpKSB7XG5cdFx0XHRcdGNvbnN0IG9uQVBJRXJyb3IgPSBvcHRpb25zLm9uQVBJRXJyb3I7XG5cdFx0XHRcdGlmIChvbkFQSUVycm9yKSBhd2FpdCBvbkFQSUVycm9yKGUpO1xuXHRcdFx0XHRpZiAoY29udGV4dC5hc1Jlc3BvbnNlKSByZXR1cm4gZTtcblx0XHRcdH1cblx0XHRcdHRocm93IGU7XG5cdFx0fSk7XG5cdFx0Y29uc3QgaGVhZGVycyA9IGludGVybmFsQ29udGV4dC5yZXNwb25zZUhlYWRlcnM7XG5cdFx0Y29uc3Qgc3RhdHVzID0gaW50ZXJuYWxDb250ZXh0LnJlc3BvbnNlU3RhdHVzO1xuXHRcdHJldHVybiBjb250ZXh0LmFzUmVzcG9uc2UgPyB0b1Jlc3BvbnNlKHJlc3BvbnNlLCB7XG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0c3RhdHVzXG5cdFx0fSkgOiBjb250ZXh0LnJldHVybkhlYWRlcnMgPyBjb250ZXh0LnJldHVyblN0YXR1cyA/IHtcblx0XHRcdGhlYWRlcnMsXG5cdFx0XHRyZXNwb25zZSxcblx0XHRcdHN0YXR1c1xuXHRcdH0gOiB7XG5cdFx0XHRoZWFkZXJzLFxuXHRcdFx0cmVzcG9uc2Vcblx0XHR9IDogY29udGV4dC5yZXR1cm5TdGF0dXMgPyB7XG5cdFx0XHRyZXNwb25zZSxcblx0XHRcdHN0YXR1c1xuXHRcdH0gOiByZXNwb25zZTtcblx0fTtcblx0aW50ZXJuYWxIYW5kbGVyLm9wdGlvbnMgPSBvcHRpb25zO1xuXHRpbnRlcm5hbEhhbmRsZXIucGF0aCA9IHBhdGg7XG5cdHJldHVybiBpbnRlcm5hbEhhbmRsZXI7XG59XG5jcmVhdGVFbmRwb2ludC5jcmVhdGUgPSAob3B0cykgPT4ge1xuXHRyZXR1cm4gKHBhdGgsIG9wdGlvbnMsIGhhbmRsZXIpID0+IHtcblx0XHRyZXR1cm4gY3JlYXRlRW5kcG9pbnQocGF0aCwge1xuXHRcdFx0Li4ub3B0aW9ucyxcblx0XHRcdHVzZTogWy4uLm9wdGlvbnM/LnVzZSB8fCBbXSwgLi4ub3B0cz8udXNlIHx8IFtdXVxuXHRcdH0sIGhhbmRsZXIpO1xuXHR9O1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gc3JjL21pZGRsZXdhcmUudHNcbmZ1bmN0aW9uIGNyZWF0ZU1pZGRsZXdhcmUob3B0aW9uc09ySGFuZGxlciwgaGFuZGxlcikge1xuXHRjb25zdCBpbnRlcm5hbEhhbmRsZXIgPSBhc3luYyAoaW5wdXRDdHgpID0+IHtcblx0XHRjb25zdCBjb250ZXh0ID0gaW5wdXRDdHg7XG5cdFx0Y29uc3QgX2hhbmRsZXIgPSB0eXBlb2Ygb3B0aW9uc09ySGFuZGxlciA9PT0gXCJmdW5jdGlvblwiID8gb3B0aW9uc09ySGFuZGxlciA6IGhhbmRsZXI7XG5cdFx0Y29uc3QgaW50ZXJuYWxDb250ZXh0ID0gYXdhaXQgY3JlYXRlSW50ZXJuYWxDb250ZXh0KGNvbnRleHQsIHtcblx0XHRcdG9wdGlvbnM6IHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyB7fSA6IG9wdGlvbnNPckhhbmRsZXIsXG5cdFx0XHRwYXRoOiBcIi9cIlxuXHRcdH0pO1xuXHRcdGlmICghX2hhbmRsZXIpIHRocm93IG5ldyBFcnJvcihcImhhbmRsZXIgbXVzdCBiZSBkZWZpbmVkXCIpO1xuXHRcdGNvbnN0IHJlc3BvbnNlID0gYXdhaXQgX2hhbmRsZXIoaW50ZXJuYWxDb250ZXh0KTtcblx0XHRjb25zdCBoZWFkZXJzID0gaW50ZXJuYWxDb250ZXh0LnJlc3BvbnNlSGVhZGVycztcblx0XHRyZXR1cm4gY29udGV4dC5yZXR1cm5IZWFkZXJzID8ge1xuXHRcdFx0aGVhZGVycyxcblx0XHRcdHJlc3BvbnNlXG5cdFx0fSA6IHJlc3BvbnNlO1xuXHR9O1xuXHRpbnRlcm5hbEhhbmRsZXIub3B0aW9ucyA9IHR5cGVvZiBvcHRpb25zT3JIYW5kbGVyID09PSBcImZ1bmN0aW9uXCIgPyB7fSA6IG9wdGlvbnNPckhhbmRsZXI7XG5cdHJldHVybiBpbnRlcm5hbEhhbmRsZXI7XG59XG5jcmVhdGVNaWRkbGV3YXJlLmNyZWF0ZSA9IChvcHRzKSA9PiB7XG5cdGZ1bmN0aW9uIGZuKG9wdGlvbnNPckhhbmRsZXIsIGhhbmRsZXIpIHtcblx0XHRpZiAodHlwZW9mIG9wdGlvbnNPckhhbmRsZXIgPT09IFwiZnVuY3Rpb25cIikgcmV0dXJuIGNyZWF0ZU1pZGRsZXdhcmUoeyB1c2U6IG9wdHM/LnVzZSB9LCBvcHRpb25zT3JIYW5kbGVyKTtcblx0XHRpZiAoIWhhbmRsZXIpIHRocm93IG5ldyBFcnJvcihcIk1pZGRsZXdhcmUgaGFuZGxlciBpcyByZXF1aXJlZFwiKTtcblx0XHRyZXR1cm4gY3JlYXRlTWlkZGxld2FyZSh7XG5cdFx0XHQuLi5vcHRpb25zT3JIYW5kbGVyLFxuXHRcdFx0bWV0aG9kOiBcIipcIixcblx0XHRcdHVzZTogWy4uLm9wdHM/LnVzZSB8fCBbXSwgLi4ub3B0aW9uc09ySGFuZGxlci51c2UgfHwgW11dXG5cdFx0fSwgaGFuZGxlcik7XG5cdH1cblx0cmV0dXJuIGZuO1xufTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvY29yZS5qc1xuLyoqIEEgc3BlY2lhbCBjb25zdGFudCB3aXRoIHR5cGUgYG5ldmVyYCAqL1xuY29uc3QgTkVWRVIgPSBPYmplY3QuZnJlZXplKHsgc3RhdHVzOiBcImFib3J0ZWRcIiB9KTtcbmZ1bmN0aW9uICRjb25zdHJ1Y3RvcihuYW1lLCBpbml0aWFsaXplciQyLCBwYXJhbXMpIHtcblx0ZnVuY3Rpb24gaW5pdChpbnN0LCBkZWYpIHtcblx0XHR2YXIgX2E7XG5cdFx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiX3pvZFwiLCB7XG5cdFx0XHR2YWx1ZTogaW5zdC5fem9kID8/IHt9LFxuXHRcdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0XHR9KTtcblx0XHQoX2EgPSBpbnN0Ll96b2QpLnRyYWl0cyA/PyAoX2EudHJhaXRzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKSk7XG5cdFx0aW5zdC5fem9kLnRyYWl0cy5hZGQobmFtZSk7XG5cdFx0aW5pdGlhbGl6ZXIkMihpbnN0LCBkZWYpO1xuXHRcdGZvciAoY29uc3QgayBpbiBfLnByb3RvdHlwZSkgaWYgKCEoayBpbiBpbnN0KSkgT2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIGssIHsgdmFsdWU6IF8ucHJvdG90eXBlW2tdLmJpbmQoaW5zdCkgfSk7XG5cdFx0aW5zdC5fem9kLmNvbnN0ciA9IF87XG5cdFx0aW5zdC5fem9kLmRlZiA9IGRlZjtcblx0fVxuXHRjb25zdCBQYXJlbnQgPSBwYXJhbXM/LlBhcmVudCA/PyBPYmplY3Q7XG5cdGNsYXNzIERlZmluaXRpb24gZXh0ZW5kcyBQYXJlbnQge31cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KERlZmluaXRpb24sIFwibmFtZVwiLCB7IHZhbHVlOiBuYW1lIH0pO1xuXHRmdW5jdGlvbiBfKGRlZikge1xuXHRcdHZhciBfYTtcblx0XHRjb25zdCBpbnN0ID0gcGFyYW1zPy5QYXJlbnQgPyBuZXcgRGVmaW5pdGlvbigpIDogdGhpcztcblx0XHRpbml0KGluc3QsIGRlZik7XG5cdFx0KF9hID0gaW5zdC5fem9kKS5kZWZlcnJlZCA/PyAoX2EuZGVmZXJyZWQgPSBbXSk7XG5cdFx0Zm9yIChjb25zdCBmbiBvZiBpbnN0Ll96b2QuZGVmZXJyZWQpIGZuKCk7XG5cdFx0cmV0dXJuIGluc3Q7XG5cdH1cblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KF8sIFwiaW5pdFwiLCB7IHZhbHVlOiBpbml0IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgU3ltYm9sLmhhc0luc3RhbmNlLCB7IHZhbHVlOiAoaW5zdCkgPT4ge1xuXHRcdGlmIChwYXJhbXM/LlBhcmVudCAmJiBpbnN0IGluc3RhbmNlb2YgcGFyYW1zLlBhcmVudCkgcmV0dXJuIHRydWU7XG5cdFx0cmV0dXJuIGluc3Q/Ll96b2Q/LnRyYWl0cz8uaGFzKG5hbWUpO1xuXHR9IH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoXywgXCJuYW1lXCIsIHsgdmFsdWU6IG5hbWUgfSk7XG5cdHJldHVybiBfO1xufVxuY29uc3QgJGJyYW5kID0gU3ltYm9sKFwiem9kX2JyYW5kXCIpO1xudmFyICRab2RBc3luY0Vycm9yID0gY2xhc3MgZXh0ZW5kcyBFcnJvciB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHN1cGVyKGBFbmNvdW50ZXJlZCBQcm9taXNlIGR1cmluZyBzeW5jaHJvbm91cyBwYXJzZS4gVXNlIC5wYXJzZUFzeW5jKCkgaW5zdGVhZC5gKTtcblx0fVxufTtcbmNvbnN0IGdsb2JhbENvbmZpZyA9IHt9O1xuZnVuY3Rpb24gY29uZmlnKG5ld0NvbmZpZykge1xuXHRpZiAobmV3Q29uZmlnKSBPYmplY3QuYXNzaWduKGdsb2JhbENvbmZpZywgbmV3Q29uZmlnKTtcblx0cmV0dXJuIGdsb2JhbENvbmZpZztcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvdXRpbC5qc1xuZnVuY3Rpb24gZ2V0RW51bVZhbHVlcyhlbnRyaWVzKSB7XG5cdGNvbnN0IG51bWVyaWNWYWx1ZXMgPSBPYmplY3QudmFsdWVzKGVudHJpZXMpLmZpbHRlcigodikgPT4gdHlwZW9mIHYgPT09IFwibnVtYmVyXCIpO1xuXHRyZXR1cm4gT2JqZWN0LmVudHJpZXMoZW50cmllcykuZmlsdGVyKChbaywgX10pID0+IG51bWVyaWNWYWx1ZXMuaW5kZXhPZigraykgPT09IC0xKS5tYXAoKFtfLCB2XSkgPT4gdik7XG59XG5mdW5jdGlvbiBqc29uU3RyaW5naWZ5UmVwbGFjZXIoXywgdmFsdWUpIHtcblx0aWYgKHR5cGVvZiB2YWx1ZSA9PT0gXCJiaWdpbnRcIikgcmV0dXJuIHZhbHVlLnRvU3RyaW5nKCk7XG5cdHJldHVybiB2YWx1ZTtcbn1cbmZ1bmN0aW9uIGNhY2hlZChnZXR0ZXIpIHtcblx0cmV0dXJuIHsgZ2V0IHZhbHVlKCkge1xuXHRcdHtcblx0XHRcdGNvbnN0IHZhbHVlID0gZ2V0dGVyKCk7XG5cdFx0XHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGhpcywgXCJ2YWx1ZVwiLCB7IHZhbHVlIH0pO1xuXHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdH1cblx0XHR0aHJvdyBuZXcgRXJyb3IoXCJjYWNoZWQgdmFsdWUgYWxyZWFkeSBzZXRcIik7XG5cdH0gfTtcbn1cbmZ1bmN0aW9uIG51bGxpc2goaW5wdXQpIHtcblx0cmV0dXJuIGlucHV0ID09PSBudWxsIHx8IGlucHV0ID09PSB2b2lkIDA7XG59XG5mdW5jdGlvbiBjbGVhblJlZ2V4KHNvdXJjZSkge1xuXHRjb25zdCBzdGFydCA9IHNvdXJjZS5zdGFydHNXaXRoKFwiXlwiKSA/IDEgOiAwO1xuXHRjb25zdCBlbmQgPSBzb3VyY2UuZW5kc1dpdGgoXCIkXCIpID8gc291cmNlLmxlbmd0aCAtIDEgOiBzb3VyY2UubGVuZ3RoO1xuXHRyZXR1cm4gc291cmNlLnNsaWNlKHN0YXJ0LCBlbmQpO1xufVxuZnVuY3Rpb24gZGVmaW5lTGF6eShvYmplY3QsIGtleSwgZ2V0dGVyKSB7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwge1xuXHRcdGdldCgpIHtcblx0XHRcdHtcblx0XHRcdFx0Y29uc3QgdmFsdWUgPSBnZXR0ZXIoKTtcblx0XHRcdFx0b2JqZWN0W2tleV0gPSB2YWx1ZTtcblx0XHRcdFx0cmV0dXJuIHZhbHVlO1xuXHRcdFx0fVxuXHRcdFx0dGhyb3cgbmV3IEVycm9yKFwiY2FjaGVkIHZhbHVlIGFscmVhZHkgc2V0XCIpO1xuXHRcdH0sXG5cdFx0c2V0KHYpIHtcblx0XHRcdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmplY3QsIGtleSwgeyB2YWx1ZTogdiB9KTtcblx0XHR9LFxuXHRcdGNvbmZpZ3VyYWJsZTogdHJ1ZVxuXHR9KTtcbn1cbmZ1bmN0aW9uIGFzc2lnblByb3AodGFyZ2V0LCBwcm9wLCB2YWx1ZSkge1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkodGFyZ2V0LCBwcm9wLCB7XG5cdFx0dmFsdWUsXG5cdFx0d3JpdGFibGU6IHRydWUsXG5cdFx0ZW51bWVyYWJsZTogdHJ1ZSxcblx0XHRjb25maWd1cmFibGU6IHRydWVcblx0fSk7XG59XG5mdW5jdGlvbiBlc2Moc3RyKSB7XG5cdHJldHVybiBKU09OLnN0cmluZ2lmeShzdHIpO1xufVxuY29uc3QgY2FwdHVyZVN0YWNrVHJhY2UgPSBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSA/IEVycm9yLmNhcHR1cmVTdGFja1RyYWNlIDogKC4uLl9hcmdzKSA9PiB7fTtcbmZ1bmN0aW9uIGlzT2JqZWN0KGRhdGEpIHtcblx0cmV0dXJuIHR5cGVvZiBkYXRhID09PSBcIm9iamVjdFwiICYmIGRhdGEgIT09IG51bGwgJiYgIUFycmF5LmlzQXJyYXkoZGF0YSk7XG59XG5jb25zdCBhbGxvd3NFdmFsID0gY2FjaGVkKCgpID0+IHtcblx0aWYgKHR5cGVvZiBuYXZpZ2F0b3IgIT09IFwidW5kZWZpbmVkXCIgJiYgbmF2aWdhdG9yPy51c2VyQWdlbnQ/LmluY2x1ZGVzKFwiQ2xvdWRmbGFyZVwiKSkgcmV0dXJuIGZhbHNlO1xuXHR0cnkge1xuXHRcdG5ldyBGdW5jdGlvbihcIlwiKTtcblx0XHRyZXR1cm4gdHJ1ZTtcblx0fSBjYXRjaCAoXykge1xuXHRcdHJldHVybiBmYWxzZTtcblx0fVxufSk7XG5mdW5jdGlvbiBpc1BsYWluT2JqZWN0KG8pIHtcblx0aWYgKGlzT2JqZWN0KG8pID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRjb25zdCBjdG9yID0gby5jb25zdHJ1Y3Rvcjtcblx0aWYgKGN0b3IgPT09IHZvaWQgMCkgcmV0dXJuIHRydWU7XG5cdGNvbnN0IHByb3QgPSBjdG9yLnByb3RvdHlwZTtcblx0aWYgKGlzT2JqZWN0KHByb3QpID09PSBmYWxzZSkgcmV0dXJuIGZhbHNlO1xuXHRpZiAoT2JqZWN0LnByb3RvdHlwZS5oYXNPd25Qcm9wZXJ0eS5jYWxsKHByb3QsIFwiaXNQcm90b3R5cGVPZlwiKSA9PT0gZmFsc2UpIHJldHVybiBmYWxzZTtcblx0cmV0dXJuIHRydWU7XG59XG5jb25zdCBwcm9wZXJ0eUtleVR5cGVzID0gbmV3IFNldChbXG5cdFwic3RyaW5nXCIsXG5cdFwibnVtYmVyXCIsXG5cdFwic3ltYm9sXCJcbl0pO1xuZnVuY3Rpb24gZXNjYXBlUmVnZXgoc3RyKSB7XG5cdHJldHVybiBzdHIucmVwbGFjZSgvWy4qKz9eJHt9KCl8W1xcXVxcXFxdL2csIFwiXFxcXCQmXCIpO1xufVxuZnVuY3Rpb24gY2xvbmUoaW5zdCwgZGVmLCBwYXJhbXMpIHtcblx0Y29uc3QgY2wgPSBuZXcgaW5zdC5fem9kLmNvbnN0cihkZWYgPz8gaW5zdC5fem9kLmRlZik7XG5cdGlmICghZGVmIHx8IHBhcmFtcz8ucGFyZW50KSBjbC5fem9kLnBhcmVudCA9IGluc3Q7XG5cdHJldHVybiBjbDtcbn1cbmZ1bmN0aW9uIG5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKSB7XG5cdGNvbnN0IHBhcmFtcyA9IF9wYXJhbXM7XG5cdGlmICghcGFyYW1zKSByZXR1cm4ge307XG5cdGlmICh0eXBlb2YgcGFyYW1zID09PSBcInN0cmluZ1wiKSByZXR1cm4geyBlcnJvcjogKCkgPT4gcGFyYW1zIH07XG5cdGlmIChwYXJhbXM/Lm1lc3NhZ2UgIT09IHZvaWQgMCkge1xuXHRcdGlmIChwYXJhbXM/LmVycm9yICE9PSB2b2lkIDApIHRocm93IG5ldyBFcnJvcihcIkNhbm5vdCBzcGVjaWZ5IGJvdGggYG1lc3NhZ2VgIGFuZCBgZXJyb3JgIHBhcmFtc1wiKTtcblx0XHRwYXJhbXMuZXJyb3IgPSBwYXJhbXMubWVzc2FnZTtcblx0fVxuXHRkZWxldGUgcGFyYW1zLm1lc3NhZ2U7XG5cdGlmICh0eXBlb2YgcGFyYW1zLmVycm9yID09PSBcInN0cmluZ1wiKSByZXR1cm4ge1xuXHRcdC4uLnBhcmFtcyxcblx0XHRlcnJvcjogKCkgPT4gcGFyYW1zLmVycm9yXG5cdH07XG5cdHJldHVybiBwYXJhbXM7XG59XG5mdW5jdGlvbiBvcHRpb25hbEtleXMoc2hhcGUpIHtcblx0cmV0dXJuIE9iamVjdC5rZXlzKHNoYXBlKS5maWx0ZXIoKGspID0+IHtcblx0XHRyZXR1cm4gc2hhcGVba10uX3pvZC5vcHRpbiA9PT0gXCJvcHRpb25hbFwiICYmIHNoYXBlW2tdLl96b2Qub3B0b3V0ID09PSBcIm9wdGlvbmFsXCI7XG5cdH0pO1xufVxuY29uc3QgTlVNQkVSX0ZPUk1BVF9SQU5HRVMgPSB7XG5cdHNhZmVpbnQ6IFtOdW1iZXIuTUlOX1NBRkVfSU5URUdFUiwgTnVtYmVyLk1BWF9TQUZFX0lOVEVHRVJdLFxuXHRpbnQzMjogWy0yMTQ3NDgzNjQ4LCAyMTQ3NDgzNjQ3XSxcblx0dWludDMyOiBbMCwgNDI5NDk2NzI5NV0sXG5cdGZsb2F0MzI6IFstMzQwMjgyMzQ2NjM4NTI4ODZlMjIsIDM0MDI4MjM0NjYzODUyODg2ZTIyXSxcblx0ZmxvYXQ2NDogWy1OdW1iZXIuTUFYX1ZBTFVFLCBOdW1iZXIuTUFYX1ZBTFVFXVxufTtcbmZ1bmN0aW9uIHBpY2soc2NoZW1hLCBtYXNrKSB7XG5cdGNvbnN0IG5ld1NoYXBlID0ge307XG5cdGNvbnN0IGN1cnJEZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG5cdGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcblx0XHRpZiAoIShrZXkgaW4gY3VyckRlZi5zaGFwZSkpIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuXHRcdGlmICghbWFza1trZXldKSBjb250aW51ZTtcblx0XHRuZXdTaGFwZVtrZXldID0gY3VyckRlZi5zaGFwZVtrZXldO1xuXHR9XG5cdHJldHVybiBjbG9uZShzY2hlbWEsIHtcblx0XHQuLi5zY2hlbWEuX3pvZC5kZWYsXG5cdFx0c2hhcGU6IG5ld1NoYXBlLFxuXHRcdGNoZWNrczogW11cblx0fSk7XG59XG5mdW5jdGlvbiBvbWl0KHNjaGVtYSwgbWFzaykge1xuXHRjb25zdCBuZXdTaGFwZSA9IHsgLi4uc2NoZW1hLl96b2QuZGVmLnNoYXBlIH07XG5cdGNvbnN0IGN1cnJEZWYgPSBzY2hlbWEuX3pvZC5kZWY7XG5cdGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcblx0XHRpZiAoIShrZXkgaW4gY3VyckRlZi5zaGFwZSkpIHRocm93IG5ldyBFcnJvcihgVW5yZWNvZ25pemVkIGtleTogXCIke2tleX1cImApO1xuXHRcdGlmICghbWFza1trZXldKSBjb250aW51ZTtcblx0XHRkZWxldGUgbmV3U2hhcGVba2V5XTtcblx0fVxuXHRyZXR1cm4gY2xvbmUoc2NoZW1hLCB7XG5cdFx0Li4uc2NoZW1hLl96b2QuZGVmLFxuXHRcdHNoYXBlOiBuZXdTaGFwZSxcblx0XHRjaGVja3M6IFtdXG5cdH0pO1xufVxuZnVuY3Rpb24gZXh0ZW5kKHNjaGVtYSwgc2hhcGUpIHtcblx0aWYgKCFpc1BsYWluT2JqZWN0KHNoYXBlKSkgdGhyb3cgbmV3IEVycm9yKFwiSW52YWxpZCBpbnB1dCB0byBleHRlbmQ6IGV4cGVjdGVkIGEgcGxhaW4gb2JqZWN0XCIpO1xuXHRyZXR1cm4gY2xvbmUoc2NoZW1hLCB7XG5cdFx0Li4uc2NoZW1hLl96b2QuZGVmLFxuXHRcdGdldCBzaGFwZSgpIHtcblx0XHRcdGNvbnN0IF9zaGFwZSA9IHtcblx0XHRcdFx0Li4uc2NoZW1hLl96b2QuZGVmLnNoYXBlLFxuXHRcdFx0XHQuLi5zaGFwZVxuXHRcdFx0fTtcblx0XHRcdGFzc2lnblByb3AodGhpcywgXCJzaGFwZVwiLCBfc2hhcGUpO1xuXHRcdFx0cmV0dXJuIF9zaGFwZTtcblx0XHR9LFxuXHRcdGNoZWNrczogW11cblx0fSk7XG59XG5mdW5jdGlvbiBtZXJnZShhLCBiKSB7XG5cdHJldHVybiBjbG9uZShhLCB7XG5cdFx0Li4uYS5fem9kLmRlZixcblx0XHRnZXQgc2hhcGUoKSB7XG5cdFx0XHRjb25zdCBfc2hhcGUgPSB7XG5cdFx0XHRcdC4uLmEuX3pvZC5kZWYuc2hhcGUsXG5cdFx0XHRcdC4uLmIuX3pvZC5kZWYuc2hhcGVcblx0XHRcdH07XG5cdFx0XHRhc3NpZ25Qcm9wKHRoaXMsIFwic2hhcGVcIiwgX3NoYXBlKTtcblx0XHRcdHJldHVybiBfc2hhcGU7XG5cdFx0fSxcblx0XHRjYXRjaGFsbDogYi5fem9kLmRlZi5jYXRjaGFsbCxcblx0XHRjaGVja3M6IFtdXG5cdH0pO1xufVxuZnVuY3Rpb24gcGFydGlhbChDbGFzcywgc2NoZW1hLCBtYXNrKSB7XG5cdGNvbnN0IG9sZFNoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuXHRjb25zdCBzaGFwZSA9IHsgLi4ub2xkU2hhcGUgfTtcblx0aWYgKG1hc2spIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcblx0XHRpZiAoIShrZXkgaW4gb2xkU2hhcGUpKSB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcblx0XHRpZiAoIW1hc2tba2V5XSkgY29udGludWU7XG5cdFx0c2hhcGVba2V5XSA9IENsYXNzID8gbmV3IENsYXNzKHtcblx0XHRcdHR5cGU6IFwib3B0aW9uYWxcIixcblx0XHRcdGlubmVyVHlwZTogb2xkU2hhcGVba2V5XVxuXHRcdH0pIDogb2xkU2hhcGVba2V5XTtcblx0fVxuXHRlbHNlIGZvciAoY29uc3Qga2V5IGluIG9sZFNoYXBlKSBzaGFwZVtrZXldID0gQ2xhc3MgPyBuZXcgQ2xhc3Moe1xuXHRcdHR5cGU6IFwib3B0aW9uYWxcIixcblx0XHRpbm5lclR5cGU6IG9sZFNoYXBlW2tleV1cblx0fSkgOiBvbGRTaGFwZVtrZXldO1xuXHRyZXR1cm4gY2xvbmUoc2NoZW1hLCB7XG5cdFx0Li4uc2NoZW1hLl96b2QuZGVmLFxuXHRcdHNoYXBlLFxuXHRcdGNoZWNrczogW11cblx0fSk7XG59XG5mdW5jdGlvbiByZXF1aXJlZChDbGFzcywgc2NoZW1hLCBtYXNrKSB7XG5cdGNvbnN0IG9sZFNoYXBlID0gc2NoZW1hLl96b2QuZGVmLnNoYXBlO1xuXHRjb25zdCBzaGFwZSA9IHsgLi4ub2xkU2hhcGUgfTtcblx0aWYgKG1hc2spIGZvciAoY29uc3Qga2V5IGluIG1hc2spIHtcblx0XHRpZiAoIShrZXkgaW4gc2hhcGUpKSB0aHJvdyBuZXcgRXJyb3IoYFVucmVjb2duaXplZCBrZXk6IFwiJHtrZXl9XCJgKTtcblx0XHRpZiAoIW1hc2tba2V5XSkgY29udGludWU7XG5cdFx0c2hhcGVba2V5XSA9IG5ldyBDbGFzcyh7XG5cdFx0XHR0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG5cdFx0XHRpbm5lclR5cGU6IG9sZFNoYXBlW2tleV1cblx0XHR9KTtcblx0fVxuXHRlbHNlIGZvciAoY29uc3Qga2V5IGluIG9sZFNoYXBlKSBzaGFwZVtrZXldID0gbmV3IENsYXNzKHtcblx0XHR0eXBlOiBcIm5vbm9wdGlvbmFsXCIsXG5cdFx0aW5uZXJUeXBlOiBvbGRTaGFwZVtrZXldXG5cdH0pO1xuXHRyZXR1cm4gY2xvbmUoc2NoZW1hLCB7XG5cdFx0Li4uc2NoZW1hLl96b2QuZGVmLFxuXHRcdHNoYXBlLFxuXHRcdGNoZWNrczogW11cblx0fSk7XG59XG5mdW5jdGlvbiBhYm9ydGVkKHgsIHN0YXJ0SW5kZXggPSAwKSB7XG5cdGZvciAobGV0IGkgPSBzdGFydEluZGV4OyBpIDwgeC5pc3N1ZXMubGVuZ3RoOyBpKyspIGlmICh4Lmlzc3Vlc1tpXT8uY29udGludWUgIT09IHRydWUpIHJldHVybiB0cnVlO1xuXHRyZXR1cm4gZmFsc2U7XG59XG5mdW5jdGlvbiBwcmVmaXhJc3N1ZXMocGF0aCwgaXNzdWVzKSB7XG5cdHJldHVybiBpc3N1ZXMubWFwKChpc3MpID0+IHtcblx0XHR2YXIgX2E7XG5cdFx0KF9hID0gaXNzKS5wYXRoID8/IChfYS5wYXRoID0gW10pO1xuXHRcdGlzcy5wYXRoLnVuc2hpZnQocGF0aCk7XG5cdFx0cmV0dXJuIGlzcztcblx0fSk7XG59XG5mdW5jdGlvbiB1bndyYXBNZXNzYWdlKG1lc3NhZ2UpIHtcblx0cmV0dXJuIHR5cGVvZiBtZXNzYWdlID09PSBcInN0cmluZ1wiID8gbWVzc2FnZSA6IG1lc3NhZ2U/Lm1lc3NhZ2U7XG59XG5mdW5jdGlvbiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWckMSkge1xuXHRjb25zdCBmdWxsID0ge1xuXHRcdC4uLmlzcyxcblx0XHRwYXRoOiBpc3MucGF0aCA/PyBbXVxuXHR9O1xuXHRpZiAoIWlzcy5tZXNzYWdlKSBmdWxsLm1lc3NhZ2UgPSB1bndyYXBNZXNzYWdlKGlzcy5pbnN0Py5fem9kLmRlZj8uZXJyb3I/Lihpc3MpKSA/PyB1bndyYXBNZXNzYWdlKGN0eD8uZXJyb3I/Lihpc3MpKSA/PyB1bndyYXBNZXNzYWdlKGNvbmZpZyQxLmN1c3RvbUVycm9yPy4oaXNzKSkgPz8gdW53cmFwTWVzc2FnZShjb25maWckMS5sb2NhbGVFcnJvcj8uKGlzcykpID8/IFwiSW52YWxpZCBpbnB1dFwiO1xuXHRkZWxldGUgZnVsbC5pbnN0O1xuXHRkZWxldGUgZnVsbC5jb250aW51ZTtcblx0aWYgKCFjdHg/LnJlcG9ydElucHV0KSBkZWxldGUgZnVsbC5pbnB1dDtcblx0cmV0dXJuIGZ1bGw7XG59XG5mdW5jdGlvbiBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KSB7XG5cdGlmIChBcnJheS5pc0FycmF5KGlucHV0KSkgcmV0dXJuIFwiYXJyYXlcIjtcblx0aWYgKHR5cGVvZiBpbnB1dCA9PT0gXCJzdHJpbmdcIikgcmV0dXJuIFwic3RyaW5nXCI7XG5cdHJldHVybiBcInVua25vd25cIjtcbn1cbmZ1bmN0aW9uIGlzc3VlKC4uLmFyZ3MpIHtcblx0Y29uc3QgW2lzcywgaW5wdXQsIGluc3RdID0gYXJncztcblx0aWYgKHR5cGVvZiBpc3MgPT09IFwic3RyaW5nXCIpIHJldHVybiB7XG5cdFx0bWVzc2FnZTogaXNzLFxuXHRcdGNvZGU6IFwiY3VzdG9tXCIsXG5cdFx0aW5wdXQsXG5cdFx0aW5zdFxuXHR9O1xuXHRyZXR1cm4geyAuLi5pc3MgfTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvZXJyb3JzLmpzXG5jb25zdCBpbml0aWFsaXplciQxID0gKGluc3QsIGRlZikgPT4ge1xuXHRpbnN0Lm5hbWUgPSBcIiRab2RFcnJvclwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJfem9kXCIsIHtcblx0XHR2YWx1ZTogaW5zdC5fem9kLFxuXHRcdGVudW1lcmFibGU6IGZhbHNlXG5cdH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJpc3N1ZXNcIiwge1xuXHRcdHZhbHVlOiBkZWYsXG5cdFx0ZW51bWVyYWJsZTogZmFsc2Vcblx0fSk7XG5cdE9iamVjdC5kZWZpbmVQcm9wZXJ0eShpbnN0LCBcIm1lc3NhZ2VcIiwge1xuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiBKU09OLnN0cmluZ2lmeShkZWYsIGpzb25TdHJpbmdpZnlSZXBsYWNlciwgMik7XG5cdFx0fSxcblx0XHRlbnVtZXJhYmxlOiB0cnVlXG5cdH0pO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJ0b1N0cmluZ1wiLCB7XG5cdFx0dmFsdWU6ICgpID0+IGluc3QubWVzc2FnZSxcblx0XHRlbnVtZXJhYmxlOiBmYWxzZVxuXHR9KTtcbn07XG5jb25zdCAkWm9kRXJyb3IgPSAkY29uc3RydWN0b3IoXCIkWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIkMSk7XG5jb25zdCAkWm9kUmVhbEVycm9yID0gJGNvbnN0cnVjdG9yKFwiJFpvZEVycm9yXCIsIGluaXRpYWxpemVyJDEsIHsgUGFyZW50OiBFcnJvciB9KTtcbmZ1bmN0aW9uIGZsYXR0ZW5FcnJvcihlcnJvciwgbWFwcGVyID0gKGlzc3VlJDEpID0+IGlzc3VlJDEubWVzc2FnZSkge1xuXHRjb25zdCBmaWVsZEVycm9ycyA9IHt9O1xuXHRjb25zdCBmb3JtRXJyb3JzID0gW107XG5cdGZvciAoY29uc3Qgc3ViIG9mIGVycm9yLmlzc3VlcykgaWYgKHN1Yi5wYXRoLmxlbmd0aCA+IDApIHtcblx0XHRmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gPSBmaWVsZEVycm9yc1tzdWIucGF0aFswXV0gfHwgW107XG5cdFx0ZmllbGRFcnJvcnNbc3ViLnBhdGhbMF1dLnB1c2gobWFwcGVyKHN1YikpO1xuXHR9IGVsc2UgZm9ybUVycm9ycy5wdXNoKG1hcHBlcihzdWIpKTtcblx0cmV0dXJuIHtcblx0XHRmb3JtRXJyb3JzLFxuXHRcdGZpZWxkRXJyb3JzXG5cdH07XG59XG5mdW5jdGlvbiBmb3JtYXRFcnJvcihlcnJvciwgX21hcHBlcikge1xuXHRjb25zdCBtYXBwZXIgPSBfbWFwcGVyIHx8IGZ1bmN0aW9uKGlzc3VlJDEpIHtcblx0XHRyZXR1cm4gaXNzdWUkMS5tZXNzYWdlO1xuXHR9O1xuXHRjb25zdCBmaWVsZEVycm9ycyA9IHsgX2Vycm9yczogW10gfTtcblx0Y29uc3QgcHJvY2Vzc0Vycm9yID0gKGVycm9yJDEpID0+IHtcblx0XHRmb3IgKGNvbnN0IGlzc3VlJDEgb2YgZXJyb3IkMS5pc3N1ZXMpIGlmIChpc3N1ZSQxLmNvZGUgPT09IFwiaW52YWxpZF91bmlvblwiICYmIGlzc3VlJDEuZXJyb3JzLmxlbmd0aCkgaXNzdWUkMS5lcnJvcnMubWFwKChpc3N1ZXMpID0+IHByb2Nlc3NFcnJvcih7IGlzc3VlcyB9KSk7XG5cdFx0ZWxzZSBpZiAoaXNzdWUkMS5jb2RlID09PSBcImludmFsaWRfa2V5XCIpIHByb2Nlc3NFcnJvcih7IGlzc3VlczogaXNzdWUkMS5pc3N1ZXMgfSk7XG5cdFx0ZWxzZSBpZiAoaXNzdWUkMS5jb2RlID09PSBcImludmFsaWRfZWxlbWVudFwiKSBwcm9jZXNzRXJyb3IoeyBpc3N1ZXM6IGlzc3VlJDEuaXNzdWVzIH0pO1xuXHRcdGVsc2UgaWYgKGlzc3VlJDEucGF0aC5sZW5ndGggPT09IDApIGZpZWxkRXJyb3JzLl9lcnJvcnMucHVzaChtYXBwZXIoaXNzdWUkMSkpO1xuXHRcdGVsc2Uge1xuXHRcdFx0bGV0IGN1cnIgPSBmaWVsZEVycm9ycztcblx0XHRcdGxldCBpID0gMDtcblx0XHRcdHdoaWxlIChpIDwgaXNzdWUkMS5wYXRoLmxlbmd0aCkge1xuXHRcdFx0XHRjb25zdCBlbCA9IGlzc3VlJDEucGF0aFtpXTtcblx0XHRcdFx0aWYgKCEoaSA9PT0gaXNzdWUkMS5wYXRoLmxlbmd0aCAtIDEpKSBjdXJyW2VsXSA9IGN1cnJbZWxdIHx8IHsgX2Vycm9yczogW10gfTtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0Y3VycltlbF0gPSBjdXJyW2VsXSB8fCB7IF9lcnJvcnM6IFtdIH07XG5cdFx0XHRcdFx0Y3VycltlbF0uX2Vycm9ycy5wdXNoKG1hcHBlcihpc3N1ZSQxKSk7XG5cdFx0XHRcdH1cblx0XHRcdFx0Y3VyciA9IGN1cnJbZWxdO1xuXHRcdFx0XHRpKys7XG5cdFx0XHR9XG5cdFx0fVxuXHR9O1xuXHRwcm9jZXNzRXJyb3IoZXJyb3IpO1xuXHRyZXR1cm4gZmllbGRFcnJvcnM7XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3BhcnNlLmpzXG5jb25zdCBfcGFyc2UgPSAoX0VycikgPT4gKHNjaGVtYSwgdmFsdWUsIF9jdHgsIF9wYXJhbXMpID0+IHtcblx0Y29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogZmFsc2UgfSkgOiB7IGFzeW5jOiBmYWxzZSB9O1xuXHRjb25zdCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oe1xuXHRcdHZhbHVlLFxuXHRcdGlzc3VlczogW11cblx0fSwgY3R4KTtcblx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHRocm93IG5ldyAkWm9kQXN5bmNFcnJvcigpO1xuXHRpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcblx0XHRjb25zdCBlID0gbmV3IChfcGFyYW1zPy5FcnIgPz8gX0VycikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSk7XG5cdFx0Y2FwdHVyZVN0YWNrVHJhY2UoZSwgX3BhcmFtcz8uY2FsbGVlKTtcblx0XHR0aHJvdyBlO1xuXHR9XG5cdHJldHVybiByZXN1bHQudmFsdWU7XG59O1xuY29uc3QgcGFyc2UkMSA9IC8qIEBfX1BVUkVfXyAqLyBfcGFyc2UoJFpvZFJlYWxFcnJvcik7XG5jb25zdCBfcGFyc2VBc3luYyA9IChfRXJyKSA9PiBhc3luYyAoc2NoZW1hLCB2YWx1ZSwgX2N0eCwgcGFyYW1zKSA9PiB7XG5cdGNvbnN0IGN0eCA9IF9jdHggPyBPYmplY3QuYXNzaWduKF9jdHgsIHsgYXN5bmM6IHRydWUgfSkgOiB7IGFzeW5jOiB0cnVlIH07XG5cdGxldCByZXN1bHQgPSBzY2hlbWEuX3pvZC5ydW4oe1xuXHRcdHZhbHVlLFxuXHRcdGlzc3VlczogW11cblx0fSwgY3R4KTtcblx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHJlc3VsdCA9IGF3YWl0IHJlc3VsdDtcblx0aWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSB7XG5cdFx0Y29uc3QgZSA9IG5ldyAocGFyYW1zPy5FcnIgPz8gX0VycikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSk7XG5cdFx0Y2FwdHVyZVN0YWNrVHJhY2UoZSwgcGFyYW1zPy5jYWxsZWUpO1xuXHRcdHRocm93IGU7XG5cdH1cblx0cmV0dXJuIHJlc3VsdC52YWx1ZTtcbn07XG5jb25zdCBwYXJzZUFzeW5jJDEgPSAvKiBAX19QVVJFX18gKi8gX3BhcnNlQXN5bmMoJFpvZFJlYWxFcnJvcik7XG5jb25zdCBfc2FmZVBhcnNlID0gKF9FcnIpID0+IChzY2hlbWEsIHZhbHVlLCBfY3R4KSA9PiB7XG5cdGNvbnN0IGN0eCA9IF9jdHggPyB7XG5cdFx0Li4uX2N0eCxcblx0XHRhc3luYzogZmFsc2Vcblx0fSA6IHsgYXN5bmM6IGZhbHNlIH07XG5cdGNvbnN0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7XG5cdFx0dmFsdWUsXG5cdFx0aXNzdWVzOiBbXVxuXHR9LCBjdHgpO1xuXHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG5cdHJldHVybiByZXN1bHQuaXNzdWVzLmxlbmd0aCA/IHtcblx0XHRzdWNjZXNzOiBmYWxzZSxcblx0XHRlcnJvcjogbmV3IChfRXJyID8/ICRab2RFcnJvcikocmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSlcblx0fSA6IHtcblx0XHRzdWNjZXNzOiB0cnVlLFxuXHRcdGRhdGE6IHJlc3VsdC52YWx1ZVxuXHR9O1xufTtcbmNvbnN0IHNhZmVQYXJzZSQxID0gLyogQF9fUFVSRV9fICovIF9zYWZlUGFyc2UoJFpvZFJlYWxFcnJvcik7XG5jb25zdCBfc2FmZVBhcnNlQXN5bmMgPSAoX0VycikgPT4gYXN5bmMgKHNjaGVtYSwgdmFsdWUsIF9jdHgpID0+IHtcblx0Y29uc3QgY3R4ID0gX2N0eCA/IE9iamVjdC5hc3NpZ24oX2N0eCwgeyBhc3luYzogdHJ1ZSB9KSA6IHsgYXN5bmM6IHRydWUgfTtcblx0bGV0IHJlc3VsdCA9IHNjaGVtYS5fem9kLnJ1bih7XG5cdFx0dmFsdWUsXG5cdFx0aXNzdWVzOiBbXVxuXHR9LCBjdHgpO1xuXHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkgcmVzdWx0ID0gYXdhaXQgcmVzdWx0O1xuXHRyZXR1cm4gcmVzdWx0Lmlzc3Vlcy5sZW5ndGggPyB7XG5cdFx0c3VjY2VzczogZmFsc2UsXG5cdFx0ZXJyb3I6IG5ldyBfRXJyKHJlc3VsdC5pc3N1ZXMubWFwKChpc3MpID0+IGZpbmFsaXplSXNzdWUoaXNzLCBjdHgsIGNvbmZpZygpKSkpXG5cdH0gOiB7XG5cdFx0c3VjY2VzczogdHJ1ZSxcblx0XHRkYXRhOiByZXN1bHQudmFsdWVcblx0fTtcbn07XG5jb25zdCBzYWZlUGFyc2VBc3luYyQxID0gLyogQF9fUFVSRV9fICovIF9zYWZlUGFyc2VBc3luYygkWm9kUmVhbEVycm9yKTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvY2hlY2tzLmpzXG5jb25zdCAkWm9kQ2hlY2sgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrXCIsIChpbnN0LCBkZWYpID0+IHtcblx0dmFyIF9hO1xuXHRpbnN0Ll96b2QgPz8gKGluc3QuX3pvZCA9IHt9KTtcblx0aW5zdC5fem9kLmRlZiA9IGRlZjtcblx0KF9hID0gaW5zdC5fem9kKS5vbmF0dGFjaCA/PyAoX2Eub25hdHRhY2ggPSBbXSk7XG59KTtcbmNvbnN0ICRab2RDaGVja01heExlbmd0aCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tNYXhMZW5ndGhcIiwgKGluc3QsIGRlZikgPT4ge1xuXHR2YXIgX2E7XG5cdCRab2RDaGVjay5pbml0KGluc3QsIGRlZik7XG5cdChfYSA9IGluc3QuX3pvZC5kZWYpLndoZW4gPz8gKF9hLndoZW4gPSAocGF5bG9hZCkgPT4ge1xuXHRcdGNvbnN0IHZhbCA9IHBheWxvYWQudmFsdWU7XG5cdFx0cmV0dXJuICFudWxsaXNoKHZhbCkgJiYgdmFsLmxlbmd0aCAhPT0gdm9pZCAwO1xuXHR9KTtcblx0aW5zdC5fem9kLm9uYXR0YWNoLnB1c2goKGluc3QkMSkgPT4ge1xuXHRcdGNvbnN0IGN1cnIgPSBpbnN0JDEuX3pvZC5iYWcubWF4aW11bSA/PyBOdW1iZXIuUE9TSVRJVkVfSU5GSU5JVFk7XG5cdFx0aWYgKGRlZi5tYXhpbXVtIDwgY3VycikgaW5zdCQxLl96b2QuYmFnLm1heGltdW0gPSBkZWYubWF4aW11bTtcblx0fSk7XG5cdGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG5cdFx0Y29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuXHRcdGlmIChpbnB1dC5sZW5ndGggPD0gZGVmLm1heGltdW0pIHJldHVybjtcblx0XHRjb25zdCBvcmlnaW4gPSBnZXRMZW5ndGhhYmxlT3JpZ2luKGlucHV0KTtcblx0XHRwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcblx0XHRcdG9yaWdpbixcblx0XHRcdGNvZGU6IFwidG9vX2JpZ1wiLFxuXHRcdFx0bWF4aW11bTogZGVmLm1heGltdW0sXG5cdFx0XHRpbmNsdXNpdmU6IHRydWUsXG5cdFx0XHRpbnB1dCxcblx0XHRcdGluc3QsXG5cdFx0XHRjb250aW51ZTogIWRlZi5hYm9ydFxuXHRcdH0pO1xuXHR9O1xufSk7XG5jb25zdCAkWm9kQ2hlY2tNaW5MZW5ndGggPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTWluTGVuZ3RoXCIsIChpbnN0LCBkZWYpID0+IHtcblx0dmFyIF9hO1xuXHQkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuXHQoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcblx0XHRjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuXHRcdHJldHVybiAhbnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHZvaWQgMDtcblx0fSk7XG5cdGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0JDEpID0+IHtcblx0XHRjb25zdCBjdXJyID0gaW5zdCQxLl96b2QuYmFnLm1pbmltdW0gPz8gTnVtYmVyLk5FR0FUSVZFX0lORklOSVRZO1xuXHRcdGlmIChkZWYubWluaW11bSA+IGN1cnIpIGluc3QkMS5fem9kLmJhZy5taW5pbXVtID0gZGVmLm1pbmltdW07XG5cdH0pO1xuXHRpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuXHRcdGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcblx0XHRpZiAoaW5wdXQubGVuZ3RoID49IGRlZi5taW5pbXVtKSByZXR1cm47XG5cdFx0Y29uc3Qgb3JpZ2luID0gZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCk7XG5cdFx0cGF5bG9hZC5pc3N1ZXMucHVzaCh7XG5cdFx0XHRvcmlnaW4sXG5cdFx0XHRjb2RlOiBcInRvb19zbWFsbFwiLFxuXHRcdFx0bWluaW11bTogZGVmLm1pbmltdW0sXG5cdFx0XHRpbmNsdXNpdmU6IHRydWUsXG5cdFx0XHRpbnB1dCxcblx0XHRcdGluc3QsXG5cdFx0XHRjb250aW51ZTogIWRlZi5hYm9ydFxuXHRcdH0pO1xuXHR9O1xufSk7XG5jb25zdCAkWm9kQ2hlY2tMZW5ndGhFcXVhbHMgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZENoZWNrTGVuZ3RoRXF1YWxzXCIsIChpbnN0LCBkZWYpID0+IHtcblx0dmFyIF9hO1xuXHQkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuXHQoX2EgPSBpbnN0Ll96b2QuZGVmKS53aGVuID8/IChfYS53aGVuID0gKHBheWxvYWQpID0+IHtcblx0XHRjb25zdCB2YWwgPSBwYXlsb2FkLnZhbHVlO1xuXHRcdHJldHVybiAhbnVsbGlzaCh2YWwpICYmIHZhbC5sZW5ndGggIT09IHZvaWQgMDtcblx0fSk7XG5cdGluc3QuX3pvZC5vbmF0dGFjaC5wdXNoKChpbnN0JDEpID0+IHtcblx0XHRjb25zdCBiYWcgPSBpbnN0JDEuX3pvZC5iYWc7XG5cdFx0YmFnLm1pbmltdW0gPSBkZWYubGVuZ3RoO1xuXHRcdGJhZy5tYXhpbXVtID0gZGVmLmxlbmd0aDtcblx0XHRiYWcubGVuZ3RoID0gZGVmLmxlbmd0aDtcblx0fSk7XG5cdGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG5cdFx0Y29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuXHRcdGNvbnN0IGxlbmd0aCA9IGlucHV0Lmxlbmd0aDtcblx0XHRpZiAobGVuZ3RoID09PSBkZWYubGVuZ3RoKSByZXR1cm47XG5cdFx0Y29uc3Qgb3JpZ2luID0gZ2V0TGVuZ3RoYWJsZU9yaWdpbihpbnB1dCk7XG5cdFx0Y29uc3QgdG9vQmlnID0gbGVuZ3RoID4gZGVmLmxlbmd0aDtcblx0XHRwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcblx0XHRcdG9yaWdpbixcblx0XHRcdC4uLnRvb0JpZyA/IHtcblx0XHRcdFx0Y29kZTogXCJ0b29fYmlnXCIsXG5cdFx0XHRcdG1heGltdW06IGRlZi5sZW5ndGhcblx0XHRcdH0gOiB7XG5cdFx0XHRcdGNvZGU6IFwidG9vX3NtYWxsXCIsXG5cdFx0XHRcdG1pbmltdW06IGRlZi5sZW5ndGhcblx0XHRcdH0sXG5cdFx0XHRpbmNsdXNpdmU6IHRydWUsXG5cdFx0XHRleGFjdDogdHJ1ZSxcblx0XHRcdGlucHV0OiBwYXlsb2FkLnZhbHVlLFxuXHRcdFx0aW5zdCxcblx0XHRcdGNvbnRpbnVlOiAhZGVmLmFib3J0XG5cdFx0fSk7XG5cdH07XG59KTtcbmNvbnN0ICRab2RDaGVja092ZXJ3cml0ZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2hlY2tPdmVyd3JpdGVcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuXHRpbnN0Ll96b2QuY2hlY2sgPSAocGF5bG9hZCkgPT4ge1xuXHRcdHBheWxvYWQudmFsdWUgPSBkZWYudHgocGF5bG9hZC52YWx1ZSk7XG5cdH07XG59KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NvcmUvZG9jLmpzXG52YXIgRG9jID0gY2xhc3Mge1xuXHRjb25zdHJ1Y3RvcihhcmdzID0gW10pIHtcblx0XHR0aGlzLmNvbnRlbnQgPSBbXTtcblx0XHR0aGlzLmluZGVudCA9IDA7XG5cdFx0aWYgKHRoaXMpIHRoaXMuYXJncyA9IGFyZ3M7XG5cdH1cblx0aW5kZW50ZWQoZm4pIHtcblx0XHR0aGlzLmluZGVudCArPSAxO1xuXHRcdGZuKHRoaXMpO1xuXHRcdHRoaXMuaW5kZW50IC09IDE7XG5cdH1cblx0d3JpdGUoYXJnKSB7XG5cdFx0aWYgKHR5cGVvZiBhcmcgPT09IFwiZnVuY3Rpb25cIikge1xuXHRcdFx0YXJnKHRoaXMsIHsgZXhlY3V0aW9uOiBcInN5bmNcIiB9KTtcblx0XHRcdGFyZyh0aGlzLCB7IGV4ZWN1dGlvbjogXCJhc3luY1wiIH0pO1xuXHRcdFx0cmV0dXJuO1xuXHRcdH1cblx0XHRjb25zdCBsaW5lcyA9IGFyZy5zcGxpdChcIlxcblwiKS5maWx0ZXIoKHgpID0+IHgpO1xuXHRcdGNvbnN0IG1pbkluZGVudCA9IE1hdGgubWluKC4uLmxpbmVzLm1hcCgoeCkgPT4geC5sZW5ndGggLSB4LnRyaW1TdGFydCgpLmxlbmd0aCkpO1xuXHRcdGNvbnN0IGRlZGVudGVkID0gbGluZXMubWFwKCh4KSA9PiB4LnNsaWNlKG1pbkluZGVudCkpLm1hcCgoeCkgPT4gXCIgXCIucmVwZWF0KHRoaXMuaW5kZW50ICogMikgKyB4KTtcblx0XHRmb3IgKGNvbnN0IGxpbmUgb2YgZGVkZW50ZWQpIHRoaXMuY29udGVudC5wdXNoKGxpbmUpO1xuXHR9XG5cdGNvbXBpbGUoKSB7XG5cdFx0Y29uc3QgRiA9IEZ1bmN0aW9uO1xuXHRcdGNvbnN0IGFyZ3MgPSB0aGlzPy5hcmdzO1xuXHRcdGNvbnN0IGxpbmVzID0gWy4uLih0aGlzPy5jb250ZW50ID8/IFtgYF0pLm1hcCgoeCkgPT4gYCAgJHt4fWApXTtcblx0XHRyZXR1cm4gbmV3IEYoLi4uYXJncywgbGluZXMuam9pbihcIlxcblwiKSk7XG5cdH1cbn07XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3ZlcnNpb25zLmpzXG5jb25zdCB2ZXJzaW9uID0ge1xuXHRtYWpvcjogNCxcblx0bWlub3I6IDAsXG5cdHBhdGNoOiAwXG59O1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY29yZS9zY2hlbWFzLmpzXG5jb25zdCAkWm9kVHlwZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kVHlwZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdHZhciBfYTtcblx0aW5zdCA/PyAoaW5zdCA9IHt9KTtcblx0aW5zdC5fem9kLmRlZiA9IGRlZjtcblx0aW5zdC5fem9kLmJhZyA9IGluc3QuX3pvZC5iYWcgfHwge307XG5cdGluc3QuX3pvZC52ZXJzaW9uID0gdmVyc2lvbjtcblx0Y29uc3QgY2hlY2tzID0gWy4uLmluc3QuX3pvZC5kZWYuY2hlY2tzID8/IFtdXTtcblx0aWYgKGluc3QuX3pvZC50cmFpdHMuaGFzKFwiJFpvZENoZWNrXCIpKSBjaGVja3MudW5zaGlmdChpbnN0KTtcblx0Zm9yIChjb25zdCBjaCBvZiBjaGVja3MpIGZvciAoY29uc3QgZm4gb2YgY2guX3pvZC5vbmF0dGFjaCkgZm4oaW5zdCk7XG5cdGlmIChjaGVja3MubGVuZ3RoID09PSAwKSB7XG5cdFx0KF9hID0gaW5zdC5fem9kKS5kZWZlcnJlZCA/PyAoX2EuZGVmZXJyZWQgPSBbXSk7XG5cdFx0aW5zdC5fem9kLmRlZmVycmVkPy5wdXNoKCgpID0+IHtcblx0XHRcdGluc3QuX3pvZC5ydW4gPSBpbnN0Ll96b2QucGFyc2U7XG5cdFx0fSk7XG5cdH0gZWxzZSB7XG5cdFx0Y29uc3QgcnVuQ2hlY2tzID0gKHBheWxvYWQsIGNoZWNrcyQxLCBjdHgpID0+IHtcblx0XHRcdGxldCBpc0Fib3J0ZWQgPSBhYm9ydGVkKHBheWxvYWQpO1xuXHRcdFx0bGV0IGFzeW5jUmVzdWx0O1xuXHRcdFx0Zm9yIChjb25zdCBjaCBvZiBjaGVja3MkMSkge1xuXHRcdFx0XHRpZiAoY2guX3pvZC5kZWYud2hlbikge1xuXHRcdFx0XHRcdGlmICghY2guX3pvZC5kZWYud2hlbihwYXlsb2FkKSkgY29udGludWU7XG5cdFx0XHRcdH0gZWxzZSBpZiAoaXNBYm9ydGVkKSBjb250aW51ZTtcblx0XHRcdFx0Y29uc3QgY3VyckxlbiA9IHBheWxvYWQuaXNzdWVzLmxlbmd0aDtcblx0XHRcdFx0Y29uc3QgXyA9IGNoLl96b2QuY2hlY2socGF5bG9hZCk7XG5cdFx0XHRcdGlmIChfIGluc3RhbmNlb2YgUHJvbWlzZSAmJiBjdHg/LmFzeW5jID09PSBmYWxzZSkgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG5cdFx0XHRcdGlmIChhc3luY1Jlc3VsdCB8fCBfIGluc3RhbmNlb2YgUHJvbWlzZSkgYXN5bmNSZXN1bHQgPSAoYXN5bmNSZXN1bHQgPz8gUHJvbWlzZS5yZXNvbHZlKCkpLnRoZW4oYXN5bmMgKCkgPT4ge1xuXHRcdFx0XHRcdGF3YWl0IF87XG5cdFx0XHRcdFx0aWYgKHBheWxvYWQuaXNzdWVzLmxlbmd0aCA9PT0gY3VyckxlbikgcmV0dXJuO1xuXHRcdFx0XHRcdGlmICghaXNBYm9ydGVkKSBpc0Fib3J0ZWQgPSBhYm9ydGVkKHBheWxvYWQsIGN1cnJMZW4pO1xuXHRcdFx0XHR9KTtcblx0XHRcdFx0ZWxzZSB7XG5cdFx0XHRcdFx0aWYgKHBheWxvYWQuaXNzdWVzLmxlbmd0aCA9PT0gY3VyckxlbikgY29udGludWU7XG5cdFx0XHRcdFx0aWYgKCFpc0Fib3J0ZWQpIGlzQWJvcnRlZCA9IGFib3J0ZWQocGF5bG9hZCwgY3Vyckxlbik7XG5cdFx0XHRcdH1cblx0XHRcdH1cblx0XHRcdGlmIChhc3luY1Jlc3VsdCkgcmV0dXJuIGFzeW5jUmVzdWx0LnRoZW4oKCkgPT4ge1xuXHRcdFx0XHRyZXR1cm4gcGF5bG9hZDtcblx0XHRcdH0pO1xuXHRcdFx0cmV0dXJuIHBheWxvYWQ7XG5cdFx0fTtcblx0XHRpbnN0Ll96b2QucnVuID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gaW5zdC5fem9kLnBhcnNlKHBheWxvYWQsIGN0eCk7XG5cdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuXHRcdFx0XHRpZiAoY3R4LmFzeW5jID09PSBmYWxzZSkgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG5cdFx0XHRcdHJldHVybiByZXN1bHQudGhlbigocmVzdWx0JDEpID0+IHJ1bkNoZWNrcyhyZXN1bHQkMSwgY2hlY2tzLCBjdHgpKTtcblx0XHRcdH1cblx0XHRcdHJldHVybiBydW5DaGVja3MocmVzdWx0LCBjaGVja3MsIGN0eCk7XG5cdFx0fTtcblx0fVxuXHRpbnN0W1wifnN0YW5kYXJkXCJdID0ge1xuXHRcdHZhbGlkYXRlOiAodmFsdWUpID0+IHtcblx0XHRcdHRyeSB7XG5cdFx0XHRcdGNvbnN0IHIgPSBzYWZlUGFyc2UkMShpbnN0LCB2YWx1ZSk7XG5cdFx0XHRcdHJldHVybiByLnN1Y2Nlc3MgPyB7IHZhbHVlOiByLmRhdGEgfSA6IHsgaXNzdWVzOiByLmVycm9yPy5pc3N1ZXMgfTtcblx0XHRcdH0gY2F0Y2ggKF8pIHtcblx0XHRcdFx0cmV0dXJuIHNhZmVQYXJzZUFzeW5jJDEoaW5zdCwgdmFsdWUpLnRoZW4oKHIpID0+IHIuc3VjY2VzcyA/IHsgdmFsdWU6IHIuZGF0YSB9IDogeyBpc3N1ZXM6IHIuZXJyb3I/Lmlzc3VlcyB9KTtcblx0XHRcdH1cblx0XHR9LFxuXHRcdHZlbmRvcjogXCJ6b2RcIixcblx0XHR2ZXJzaW9uOiAxXG5cdH07XG59KTtcbmNvbnN0ICRab2RVbmtub3duID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RVbmtub3duXCIsIChpbnN0LCBkZWYpID0+IHtcblx0JFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuXHRpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCkgPT4gcGF5bG9hZDtcbn0pO1xuY29uc3QgJFpvZE5ldmVyID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2ROZXZlclwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcblx0aW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcblx0XHRwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcblx0XHRcdGV4cGVjdGVkOiBcIm5ldmVyXCIsXG5cdFx0XHRjb2RlOiBcImludmFsaWRfdHlwZVwiLFxuXHRcdFx0aW5wdXQ6IHBheWxvYWQudmFsdWUsXG5cdFx0XHRpbnN0XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHBheWxvYWQ7XG5cdH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCwgZmluYWwsIGluZGV4KSB7XG5cdGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkgZmluYWwuaXNzdWVzLnB1c2goLi4ucHJlZml4SXNzdWVzKGluZGV4LCByZXN1bHQuaXNzdWVzKSk7XG5cdGZpbmFsLnZhbHVlW2luZGV4XSA9IHJlc3VsdC52YWx1ZTtcbn1cbmNvbnN0ICRab2RBcnJheSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQXJyYXlcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcblx0XHRjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG5cdFx0aWYgKCFBcnJheS5pc0FycmF5KGlucHV0KSkge1xuXHRcdFx0cGF5bG9hZC5pc3N1ZXMucHVzaCh7XG5cdFx0XHRcdGV4cGVjdGVkOiBcImFycmF5XCIsXG5cdFx0XHRcdGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG5cdFx0XHRcdGlucHV0LFxuXHRcdFx0XHRpbnN0XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBwYXlsb2FkO1xuXHRcdH1cblx0XHRwYXlsb2FkLnZhbHVlID0gQXJyYXkoaW5wdXQubGVuZ3RoKTtcblx0XHRjb25zdCBwcm9tcyA9IFtdO1xuXHRcdGZvciAobGV0IGkgPSAwOyBpIDwgaW5wdXQubGVuZ3RoOyBpKyspIHtcblx0XHRcdGNvbnN0IGl0ZW0gPSBpbnB1dFtpXTtcblx0XHRcdGNvbnN0IHJlc3VsdCA9IGRlZi5lbGVtZW50Ll96b2QucnVuKHtcblx0XHRcdFx0dmFsdWU6IGl0ZW0sXG5cdFx0XHRcdGlzc3VlczogW11cblx0XHRcdH0sIGN0eCk7XG5cdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkgcHJvbXMucHVzaChyZXN1bHQudGhlbigocmVzdWx0JDEpID0+IGhhbmRsZUFycmF5UmVzdWx0KHJlc3VsdCQxLCBwYXlsb2FkLCBpKSkpO1xuXHRcdFx0ZWxzZSBoYW5kbGVBcnJheVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGkpO1xuXHRcdH1cblx0XHRpZiAocHJvbXMubGVuZ3RoKSByZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4gcGF5bG9hZCk7XG5cdFx0cmV0dXJuIHBheWxvYWQ7XG5cdH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZU9iamVjdFJlc3VsdChyZXN1bHQsIGZpbmFsLCBrZXkpIHtcblx0aWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoKSBmaW5hbC5pc3N1ZXMucHVzaCguLi5wcmVmaXhJc3N1ZXMoa2V5LCByZXN1bHQuaXNzdWVzKSk7XG5cdGZpbmFsLnZhbHVlW2tleV0gPSByZXN1bHQudmFsdWU7XG59XG5mdW5jdGlvbiBoYW5kbGVPcHRpb25hbE9iamVjdFJlc3VsdChyZXN1bHQsIGZpbmFsLCBrZXksIGlucHV0KSB7XG5cdGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCkgaWYgKGlucHV0W2tleV0gPT09IHZvaWQgMCkgaWYgKGtleSBpbiBpbnB1dCkgZmluYWwudmFsdWVba2V5XSA9IHZvaWQgMDtcblx0ZWxzZSBmaW5hbC52YWx1ZVtrZXldID0gcmVzdWx0LnZhbHVlO1xuXHRlbHNlIGZpbmFsLmlzc3Vlcy5wdXNoKC4uLnByZWZpeElzc3VlcyhrZXksIHJlc3VsdC5pc3N1ZXMpKTtcblx0ZWxzZSBpZiAocmVzdWx0LnZhbHVlID09PSB2b2lkIDApIHtcblx0XHRpZiAoa2V5IGluIGlucHV0KSBmaW5hbC52YWx1ZVtrZXldID0gdm9pZCAwO1xuXHR9IGVsc2UgZmluYWwudmFsdWVba2V5XSA9IHJlc3VsdC52YWx1ZTtcbn1cbmNvbnN0ICRab2RPYmplY3QgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZE9iamVjdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcblx0Y29uc3QgX25vcm1hbGl6ZWQgPSBjYWNoZWQoKCkgPT4ge1xuXHRcdGNvbnN0IGtleXMgPSBPYmplY3Qua2V5cyhkZWYuc2hhcGUpO1xuXHRcdGZvciAoY29uc3QgayBvZiBrZXlzKSBpZiAoIShkZWYuc2hhcGVba10gaW5zdGFuY2VvZiAkWm9kVHlwZSkpIHRocm93IG5ldyBFcnJvcihgSW52YWxpZCBlbGVtZW50IGF0IGtleSBcIiR7a31cIjogZXhwZWN0ZWQgYSBab2Qgc2NoZW1hYCk7XG5cdFx0Y29uc3Qgb2tleXMgPSBvcHRpb25hbEtleXMoZGVmLnNoYXBlKTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0c2hhcGU6IGRlZi5zaGFwZSxcblx0XHRcdGtleXMsXG5cdFx0XHRrZXlTZXQ6IG5ldyBTZXQoa2V5cyksXG5cdFx0XHRudW1LZXlzOiBrZXlzLmxlbmd0aCxcblx0XHRcdG9wdGlvbmFsS2V5czogbmV3IFNldChva2V5cylcblx0XHR9O1xuXHR9KTtcblx0ZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicHJvcFZhbHVlc1wiLCAoKSA9PiB7XG5cdFx0Y29uc3Qgc2hhcGUgPSBkZWYuc2hhcGU7XG5cdFx0Y29uc3QgcHJvcFZhbHVlcyA9IHt9O1xuXHRcdGZvciAoY29uc3Qga2V5IGluIHNoYXBlKSB7XG5cdFx0XHRjb25zdCBmaWVsZCA9IHNoYXBlW2tleV0uX3pvZDtcblx0XHRcdGlmIChmaWVsZC52YWx1ZXMpIHtcblx0XHRcdFx0cHJvcFZhbHVlc1trZXldID8/IChwcm9wVmFsdWVzW2tleV0gPSAvKiBAX19QVVJFX18gKi8gbmV3IFNldCgpKTtcblx0XHRcdFx0Zm9yIChjb25zdCB2IG9mIGZpZWxkLnZhbHVlcykgcHJvcFZhbHVlc1trZXldLmFkZCh2KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0cmV0dXJuIHByb3BWYWx1ZXM7XG5cdH0pO1xuXHRjb25zdCBnZW5lcmF0ZUZhc3RwYXNzID0gKHNoYXBlKSA9PiB7XG5cdFx0Y29uc3QgZG9jID0gbmV3IERvYyhbXG5cdFx0XHRcInNoYXBlXCIsXG5cdFx0XHRcInBheWxvYWRcIixcblx0XHRcdFwiY3R4XCJcblx0XHRdKTtcblx0XHRjb25zdCBub3JtYWxpemVkID0gX25vcm1hbGl6ZWQudmFsdWU7XG5cdFx0Y29uc3QgcGFyc2VTdHIgPSAoa2V5KSA9PiB7XG5cdFx0XHRjb25zdCBrID0gZXNjKGtleSk7XG5cdFx0XHRyZXR1cm4gYHNoYXBlWyR7a31dLl96b2QucnVuKHsgdmFsdWU6IGlucHV0WyR7a31dLCBpc3N1ZXM6IFtdIH0sIGN0eClgO1xuXHRcdH07XG5cdFx0ZG9jLndyaXRlKGBjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7YCk7XG5cdFx0Y29uc3QgaWRzID0gT2JqZWN0LmNyZWF0ZShudWxsKTtcblx0XHRsZXQgY291bnRlciA9IDA7XG5cdFx0Zm9yIChjb25zdCBrZXkgb2Ygbm9ybWFsaXplZC5rZXlzKSBpZHNba2V5XSA9IGBrZXlfJHtjb3VudGVyKyt9YDtcblx0XHRkb2Mud3JpdGUoYGNvbnN0IG5ld1Jlc3VsdCA9IHt9YCk7XG5cdFx0Zm9yIChjb25zdCBrZXkgb2Ygbm9ybWFsaXplZC5rZXlzKSBpZiAobm9ybWFsaXplZC5vcHRpb25hbEtleXMuaGFzKGtleSkpIHtcblx0XHRcdGNvbnN0IGlkID0gaWRzW2tleV07XG5cdFx0XHRkb2Mud3JpdGUoYGNvbnN0ICR7aWR9ID0gJHtwYXJzZVN0cihrZXkpfTtgKTtcblx0XHRcdGNvbnN0IGsgPSBlc2Moa2V5KTtcblx0XHRcdGRvYy53cml0ZShgXG4gICAgICAgIGlmICgke2lkfS5pc3N1ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgaWYgKGlucHV0WyR7a31dID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICAgIGlmICgke2t9IGluIGlucHV0KSB7XG4gICAgICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9IHVuZGVmaW5lZDtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgcGF5bG9hZC5pc3N1ZXMgPSBwYXlsb2FkLmlzc3Vlcy5jb25jYXQoXG4gICAgICAgICAgICAgICR7aWR9Lmlzc3Vlcy5tYXAoKGlzcykgPT4gKHtcbiAgICAgICAgICAgICAgICAuLi5pc3MsXG4gICAgICAgICAgICAgICAgcGF0aDogaXNzLnBhdGggPyBbJHtrfSwgLi4uaXNzLnBhdGhdIDogWyR7a31dLFxuICAgICAgICAgICAgICB9KSlcbiAgICAgICAgICAgICk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGVsc2UgaWYgKCR7aWR9LnZhbHVlID09PSB1bmRlZmluZWQpIHtcbiAgICAgICAgICBpZiAoJHtrfSBpbiBpbnB1dCkgbmV3UmVzdWx0WyR7a31dID0gdW5kZWZpbmVkO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIG5ld1Jlc3VsdFske2t9XSA9ICR7aWR9LnZhbHVlO1xuICAgICAgICB9XG4gICAgICAgIGApO1xuXHRcdH0gZWxzZSB7XG5cdFx0XHRjb25zdCBpZCA9IGlkc1trZXldO1xuXHRcdFx0ZG9jLndyaXRlKGBjb25zdCAke2lkfSA9ICR7cGFyc2VTdHIoa2V5KX07YCk7XG5cdFx0XHRkb2Mud3JpdGUoYFxuICAgICAgICAgIGlmICgke2lkfS5pc3N1ZXMubGVuZ3RoKSBwYXlsb2FkLmlzc3VlcyA9IHBheWxvYWQuaXNzdWVzLmNvbmNhdCgke2lkfS5pc3N1ZXMubWFwKGlzcyA9PiAoe1xuICAgICAgICAgICAgLi4uaXNzLFxuICAgICAgICAgICAgcGF0aDogaXNzLnBhdGggPyBbJHtlc2Moa2V5KX0sIC4uLmlzcy5wYXRoXSA6IFske2VzYyhrZXkpfV1cbiAgICAgICAgICB9KSkpO2ApO1xuXHRcdFx0ZG9jLndyaXRlKGBuZXdSZXN1bHRbJHtlc2Moa2V5KX1dID0gJHtpZH0udmFsdWVgKTtcblx0XHR9XG5cdFx0ZG9jLndyaXRlKGBwYXlsb2FkLnZhbHVlID0gbmV3UmVzdWx0O2ApO1xuXHRcdGRvYy53cml0ZShgcmV0dXJuIHBheWxvYWQ7YCk7XG5cdFx0Y29uc3QgZm4gPSBkb2MuY29tcGlsZSgpO1xuXHRcdHJldHVybiAocGF5bG9hZCwgY3R4KSA9PiBmbihzaGFwZSwgcGF5bG9hZCwgY3R4KTtcblx0fTtcblx0bGV0IGZhc3RwYXNzO1xuXHRjb25zdCBpc09iamVjdCQxID0gaXNPYmplY3Q7XG5cdGNvbnN0IGppdCA9ICFnbG9iYWxDb25maWcuaml0bGVzcztcblx0Y29uc3QgYWxsb3dzRXZhbCQxID0gYWxsb3dzRXZhbDtcblx0Y29uc3QgZmFzdEVuYWJsZWQgPSBqaXQgJiYgYWxsb3dzRXZhbCQxLnZhbHVlO1xuXHRjb25zdCBjYXRjaGFsbCA9IGRlZi5jYXRjaGFsbDtcblx0bGV0IHZhbHVlO1xuXHRpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG5cdFx0dmFsdWUgPz8gKHZhbHVlID0gX25vcm1hbGl6ZWQudmFsdWUpO1xuXHRcdGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcblx0XHRpZiAoIWlzT2JqZWN0JDEoaW5wdXQpKSB7XG5cdFx0XHRwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcblx0XHRcdFx0ZXhwZWN0ZWQ6IFwib2JqZWN0XCIsXG5cdFx0XHRcdGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG5cdFx0XHRcdGlucHV0LFxuXHRcdFx0XHRpbnN0XG5cdFx0XHR9KTtcblx0XHRcdHJldHVybiBwYXlsb2FkO1xuXHRcdH1cblx0XHRjb25zdCBwcm9tcyA9IFtdO1xuXHRcdGlmIChqaXQgJiYgZmFzdEVuYWJsZWQgJiYgY3R4Py5hc3luYyA9PT0gZmFsc2UgJiYgY3R4LmppdGxlc3MgIT09IHRydWUpIHtcblx0XHRcdGlmICghZmFzdHBhc3MpIGZhc3RwYXNzID0gZ2VuZXJhdGVGYXN0cGFzcyhkZWYuc2hhcGUpO1xuXHRcdFx0cGF5bG9hZCA9IGZhc3RwYXNzKHBheWxvYWQsIGN0eCk7XG5cdFx0fSBlbHNlIHtcblx0XHRcdHBheWxvYWQudmFsdWUgPSB7fTtcblx0XHRcdGNvbnN0IHNoYXBlID0gdmFsdWUuc2hhcGU7XG5cdFx0XHRmb3IgKGNvbnN0IGtleSBvZiB2YWx1ZS5rZXlzKSB7XG5cdFx0XHRcdGNvbnN0IGVsID0gc2hhcGVba2V5XTtcblx0XHRcdFx0Y29uc3QgciA9IGVsLl96b2QucnVuKHtcblx0XHRcdFx0XHR2YWx1ZTogaW5wdXRba2V5XSxcblx0XHRcdFx0XHRpc3N1ZXM6IFtdXG5cdFx0XHRcdH0sIGN0eCk7XG5cdFx0XHRcdGNvbnN0IGlzT3B0aW9uYWwgPSBlbC5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIgJiYgZWwuX3pvZC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIjtcblx0XHRcdFx0aWYgKHIgaW5zdGFuY2VvZiBQcm9taXNlKSBwcm9tcy5wdXNoKHIudGhlbigociQxKSA9PiBpc09wdGlvbmFsID8gaGFuZGxlT3B0aW9uYWxPYmplY3RSZXN1bHQociQxLCBwYXlsb2FkLCBrZXksIGlucHV0KSA6IGhhbmRsZU9iamVjdFJlc3VsdChyJDEsIHBheWxvYWQsIGtleSkpKTtcblx0XHRcdFx0ZWxzZSBpZiAoaXNPcHRpb25hbCkgaGFuZGxlT3B0aW9uYWxPYmplY3RSZXN1bHQociwgcGF5bG9hZCwga2V5LCBpbnB1dCk7XG5cdFx0XHRcdGVsc2UgaGFuZGxlT2JqZWN0UmVzdWx0KHIsIHBheWxvYWQsIGtleSk7XG5cdFx0XHR9XG5cdFx0fVxuXHRcdGlmICghY2F0Y2hhbGwpIHJldHVybiBwcm9tcy5sZW5ndGggPyBQcm9taXNlLmFsbChwcm9tcykudGhlbigoKSA9PiBwYXlsb2FkKSA6IHBheWxvYWQ7XG5cdFx0Y29uc3QgdW5yZWNvZ25pemVkID0gW107XG5cdFx0Y29uc3Qga2V5U2V0ID0gdmFsdWUua2V5U2V0O1xuXHRcdGNvbnN0IF9jYXRjaGFsbCA9IGNhdGNoYWxsLl96b2Q7XG5cdFx0Y29uc3QgdCA9IF9jYXRjaGFsbC5kZWYudHlwZTtcblx0XHRmb3IgKGNvbnN0IGtleSBvZiBPYmplY3Qua2V5cyhpbnB1dCkpIHtcblx0XHRcdGlmIChrZXlTZXQuaGFzKGtleSkpIGNvbnRpbnVlO1xuXHRcdFx0aWYgKHQgPT09IFwibmV2ZXJcIikge1xuXHRcdFx0XHR1bnJlY29nbml6ZWQucHVzaChrZXkpO1xuXHRcdFx0XHRjb250aW51ZTtcblx0XHRcdH1cblx0XHRcdGNvbnN0IHIgPSBfY2F0Y2hhbGwucnVuKHtcblx0XHRcdFx0dmFsdWU6IGlucHV0W2tleV0sXG5cdFx0XHRcdGlzc3VlczogW11cblx0XHRcdH0sIGN0eCk7XG5cdFx0XHRpZiAociBpbnN0YW5jZW9mIFByb21pc2UpIHByb21zLnB1c2goci50aGVuKChyJDEpID0+IGhhbmRsZU9iamVjdFJlc3VsdChyJDEsIHBheWxvYWQsIGtleSkpKTtcblx0XHRcdGVsc2UgaGFuZGxlT2JqZWN0UmVzdWx0KHIsIHBheWxvYWQsIGtleSk7XG5cdFx0fVxuXHRcdGlmICh1bnJlY29nbml6ZWQubGVuZ3RoKSBwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcblx0XHRcdGNvZGU6IFwidW5yZWNvZ25pemVkX2tleXNcIixcblx0XHRcdGtleXM6IHVucmVjb2duaXplZCxcblx0XHRcdGlucHV0LFxuXHRcdFx0aW5zdFxuXHRcdH0pO1xuXHRcdGlmICghcHJvbXMubGVuZ3RoKSByZXR1cm4gcGF5bG9hZDtcblx0XHRyZXR1cm4gUHJvbWlzZS5hbGwocHJvbXMpLnRoZW4oKCkgPT4ge1xuXHRcdFx0cmV0dXJuIHBheWxvYWQ7XG5cdFx0fSk7XG5cdH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBmaW5hbCwgaW5zdCwgY3R4KSB7XG5cdGZvciAoY29uc3QgcmVzdWx0IG9mIHJlc3VsdHMpIGlmIChyZXN1bHQuaXNzdWVzLmxlbmd0aCA9PT0gMCkge1xuXHRcdGZpbmFsLnZhbHVlID0gcmVzdWx0LnZhbHVlO1xuXHRcdHJldHVybiBmaW5hbDtcblx0fVxuXHRmaW5hbC5pc3N1ZXMucHVzaCh7XG5cdFx0Y29kZTogXCJpbnZhbGlkX3VuaW9uXCIsXG5cdFx0aW5wdXQ6IGZpbmFsLnZhbHVlLFxuXHRcdGluc3QsXG5cdFx0ZXJyb3JzOiByZXN1bHRzLm1hcCgocmVzdWx0KSA9PiByZXN1bHQuaXNzdWVzLm1hcCgoaXNzKSA9PiBmaW5hbGl6ZUlzc3VlKGlzcywgY3R4LCBjb25maWcoKSkpKVxuXHR9KTtcblx0cmV0dXJuIGZpbmFsO1xufVxuY29uc3QgJFpvZFVuaW9uID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RVbmlvblwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcblx0ZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLm9wdGlvbnMuc29tZSgobykgPT4gby5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIpID8gXCJvcHRpb25hbFwiIDogdm9pZCAwKTtcblx0ZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5vcHRpb25zLnNvbWUoKG8pID0+IG8uX3pvZC5vcHRvdXQgPT09IFwib3B0aW9uYWxcIikgPyBcIm9wdGlvbmFsXCIgOiB2b2lkIDApO1xuXHRkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4ge1xuXHRcdGlmIChkZWYub3B0aW9ucy5ldmVyeSgobykgPT4gby5fem9kLnZhbHVlcykpIHJldHVybiBuZXcgU2V0KGRlZi5vcHRpb25zLmZsYXRNYXAoKG9wdGlvbikgPT4gQXJyYXkuZnJvbShvcHRpb24uX3pvZC52YWx1ZXMpKSk7XG5cdH0pO1xuXHRkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcblx0XHRpZiAoZGVmLm9wdGlvbnMuZXZlcnkoKG8pID0+IG8uX3pvZC5wYXR0ZXJuKSkge1xuXHRcdFx0Y29uc3QgcGF0dGVybnMgPSBkZWYub3B0aW9ucy5tYXAoKG8pID0+IG8uX3pvZC5wYXR0ZXJuKTtcblx0XHRcdHJldHVybiAvKiBAX19QVVJFX18gKi8gbmV3IFJlZ0V4cChgXigke3BhdHRlcm5zLm1hcCgocCkgPT4gY2xlYW5SZWdleChwLnNvdXJjZSkpLmpvaW4oXCJ8XCIpfSkkYCk7XG5cdFx0fVxuXHR9KTtcblx0aW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuXHRcdGxldCBhc3luYyA9IGZhbHNlO1xuXHRcdGNvbnN0IHJlc3VsdHMgPSBbXTtcblx0XHRmb3IgKGNvbnN0IG9wdGlvbiBvZiBkZWYub3B0aW9ucykge1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gb3B0aW9uLl96b2QucnVuKHtcblx0XHRcdFx0dmFsdWU6IHBheWxvYWQudmFsdWUsXG5cdFx0XHRcdGlzc3VlczogW11cblx0XHRcdH0sIGN0eCk7XG5cdFx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkge1xuXHRcdFx0XHRyZXN1bHRzLnB1c2gocmVzdWx0KTtcblx0XHRcdFx0YXN5bmMgPSB0cnVlO1xuXHRcdFx0fSBlbHNlIHtcblx0XHRcdFx0aWYgKHJlc3VsdC5pc3N1ZXMubGVuZ3RoID09PSAwKSByZXR1cm4gcmVzdWx0O1xuXHRcdFx0XHRyZXN1bHRzLnB1c2gocmVzdWx0KTtcblx0XHRcdH1cblx0XHR9XG5cdFx0aWYgKCFhc3luYykgcmV0dXJuIGhhbmRsZVVuaW9uUmVzdWx0cyhyZXN1bHRzLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuXHRcdHJldHVybiBQcm9taXNlLmFsbChyZXN1bHRzKS50aGVuKChyZXN1bHRzJDEpID0+IHtcblx0XHRcdHJldHVybiBoYW5kbGVVbmlvblJlc3VsdHMocmVzdWx0cyQxLCBwYXlsb2FkLCBpbnN0LCBjdHgpO1xuXHRcdH0pO1xuXHR9O1xufSk7XG5jb25zdCAkWm9kSW50ZXJzZWN0aW9uID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RJbnRlcnNlY3Rpb25cIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcblx0XHRjb25zdCBpbnB1dCA9IHBheWxvYWQudmFsdWU7XG5cdFx0Y29uc3QgbGVmdCA9IGRlZi5sZWZ0Ll96b2QucnVuKHtcblx0XHRcdHZhbHVlOiBpbnB1dCxcblx0XHRcdGlzc3VlczogW11cblx0XHR9LCBjdHgpO1xuXHRcdGNvbnN0IHJpZ2h0ID0gZGVmLnJpZ2h0Ll96b2QucnVuKHtcblx0XHRcdHZhbHVlOiBpbnB1dCxcblx0XHRcdGlzc3VlczogW11cblx0XHR9LCBjdHgpO1xuXHRcdGlmIChsZWZ0IGluc3RhbmNlb2YgUHJvbWlzZSB8fCByaWdodCBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBQcm9taXNlLmFsbChbbGVmdCwgcmlnaHRdKS50aGVuKChbbGVmdCQxLCByaWdodCQxXSkgPT4ge1xuXHRcdFx0cmV0dXJuIGhhbmRsZUludGVyc2VjdGlvblJlc3VsdHMocGF5bG9hZCwgbGVmdCQxLCByaWdodCQxKTtcblx0XHR9KTtcblx0XHRyZXR1cm4gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhwYXlsb2FkLCBsZWZ0LCByaWdodCk7XG5cdH07XG59KTtcbmZ1bmN0aW9uIG1lcmdlVmFsdWVzKGEsIGIpIHtcblx0aWYgKGEgPT09IGIpIHJldHVybiB7XG5cdFx0dmFsaWQ6IHRydWUsXG5cdFx0ZGF0YTogYVxuXHR9O1xuXHRpZiAoYSBpbnN0YW5jZW9mIERhdGUgJiYgYiBpbnN0YW5jZW9mIERhdGUgJiYgK2EgPT09ICtiKSByZXR1cm4ge1xuXHRcdHZhbGlkOiB0cnVlLFxuXHRcdGRhdGE6IGFcblx0fTtcblx0aWYgKGlzUGxhaW5PYmplY3QoYSkgJiYgaXNQbGFpbk9iamVjdChiKSkge1xuXHRcdGNvbnN0IGJLZXlzID0gT2JqZWN0LmtleXMoYik7XG5cdFx0Y29uc3Qgc2hhcmVkS2V5cyA9IE9iamVjdC5rZXlzKGEpLmZpbHRlcigoa2V5KSA9PiBiS2V5cy5pbmRleE9mKGtleSkgIT09IC0xKTtcblx0XHRjb25zdCBuZXdPYmogPSB7XG5cdFx0XHQuLi5hLFxuXHRcdFx0Li4uYlxuXHRcdH07XG5cdFx0Zm9yIChjb25zdCBrZXkgb2Ygc2hhcmVkS2V5cykge1xuXHRcdFx0Y29uc3Qgc2hhcmVkVmFsdWUgPSBtZXJnZVZhbHVlcyhhW2tleV0sIGJba2V5XSk7XG5cdFx0XHRpZiAoIXNoYXJlZFZhbHVlLnZhbGlkKSByZXR1cm4ge1xuXHRcdFx0XHR2YWxpZDogZmFsc2UsXG5cdFx0XHRcdG1lcmdlRXJyb3JQYXRoOiBba2V5LCAuLi5zaGFyZWRWYWx1ZS5tZXJnZUVycm9yUGF0aF1cblx0XHRcdH07XG5cdFx0XHRuZXdPYmpba2V5XSA9IHNoYXJlZFZhbHVlLmRhdGE7XG5cdFx0fVxuXHRcdHJldHVybiB7XG5cdFx0XHR2YWxpZDogdHJ1ZSxcblx0XHRcdGRhdGE6IG5ld09ialxuXHRcdH07XG5cdH1cblx0aWYgKEFycmF5LmlzQXJyYXkoYSkgJiYgQXJyYXkuaXNBcnJheShiKSkge1xuXHRcdGlmIChhLmxlbmd0aCAhPT0gYi5sZW5ndGgpIHJldHVybiB7XG5cdFx0XHR2YWxpZDogZmFsc2UsXG5cdFx0XHRtZXJnZUVycm9yUGF0aDogW11cblx0XHR9O1xuXHRcdGNvbnN0IG5ld0FycmF5ID0gW107XG5cdFx0Zm9yIChsZXQgaW5kZXggPSAwOyBpbmRleCA8IGEubGVuZ3RoOyBpbmRleCsrKSB7XG5cdFx0XHRjb25zdCBpdGVtQSA9IGFbaW5kZXhdO1xuXHRcdFx0Y29uc3QgaXRlbUIgPSBiW2luZGV4XTtcblx0XHRcdGNvbnN0IHNoYXJlZFZhbHVlID0gbWVyZ2VWYWx1ZXMoaXRlbUEsIGl0ZW1CKTtcblx0XHRcdGlmICghc2hhcmVkVmFsdWUudmFsaWQpIHJldHVybiB7XG5cdFx0XHRcdHZhbGlkOiBmYWxzZSxcblx0XHRcdFx0bWVyZ2VFcnJvclBhdGg6IFtpbmRleCwgLi4uc2hhcmVkVmFsdWUubWVyZ2VFcnJvclBhdGhdXG5cdFx0XHR9O1xuXHRcdFx0bmV3QXJyYXkucHVzaChzaGFyZWRWYWx1ZS5kYXRhKTtcblx0XHR9XG5cdFx0cmV0dXJuIHtcblx0XHRcdHZhbGlkOiB0cnVlLFxuXHRcdFx0ZGF0YTogbmV3QXJyYXlcblx0XHR9O1xuXHR9XG5cdHJldHVybiB7XG5cdFx0dmFsaWQ6IGZhbHNlLFxuXHRcdG1lcmdlRXJyb3JQYXRoOiBbXVxuXHR9O1xufVxuZnVuY3Rpb24gaGFuZGxlSW50ZXJzZWN0aW9uUmVzdWx0cyhyZXN1bHQsIGxlZnQsIHJpZ2h0KSB7XG5cdGlmIChsZWZ0Lmlzc3Vlcy5sZW5ndGgpIHJlc3VsdC5pc3N1ZXMucHVzaCguLi5sZWZ0Lmlzc3Vlcyk7XG5cdGlmIChyaWdodC5pc3N1ZXMubGVuZ3RoKSByZXN1bHQuaXNzdWVzLnB1c2goLi4ucmlnaHQuaXNzdWVzKTtcblx0aWYgKGFib3J0ZWQocmVzdWx0KSkgcmV0dXJuIHJlc3VsdDtcblx0Y29uc3QgbWVyZ2VkID0gbWVyZ2VWYWx1ZXMobGVmdC52YWx1ZSwgcmlnaHQudmFsdWUpO1xuXHRpZiAoIW1lcmdlZC52YWxpZCkgdGhyb3cgbmV3IEVycm9yKGBVbm1lcmdhYmxlIGludGVyc2VjdGlvbi4gRXJyb3IgcGF0aDogJHtKU09OLnN0cmluZ2lmeShtZXJnZWQubWVyZ2VFcnJvclBhdGgpfWApO1xuXHRyZXN1bHQudmFsdWUgPSBtZXJnZWQuZGF0YTtcblx0cmV0dXJuIHJlc3VsdDtcbn1cbmNvbnN0ICRab2RFbnVtID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RFbnVtXCIsIChpbnN0LCBkZWYpID0+IHtcblx0JFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuXHRjb25zdCB2YWx1ZXMgPSBnZXRFbnVtVmFsdWVzKGRlZi5lbnRyaWVzKTtcblx0aW5zdC5fem9kLnZhbHVlcyA9IG5ldyBTZXQodmFsdWVzKTtcblx0aW5zdC5fem9kLnBhdHRlcm4gPSAvKiBAX19QVVJFX18gKi8gbmV3IFJlZ0V4cChgXigke3ZhbHVlcy5maWx0ZXIoKGspID0+IHByb3BlcnR5S2V5VHlwZXMuaGFzKHR5cGVvZiBrKSkubWFwKChvKSA9PiB0eXBlb2YgbyA9PT0gXCJzdHJpbmdcIiA/IGVzY2FwZVJlZ2V4KG8pIDogby50b1N0cmluZygpKS5qb2luKFwifFwiKX0pJGApO1xuXHRpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgX2N0eCkgPT4ge1xuXHRcdGNvbnN0IGlucHV0ID0gcGF5bG9hZC52YWx1ZTtcblx0XHRpZiAoaW5zdC5fem9kLnZhbHVlcy5oYXMoaW5wdXQpKSByZXR1cm4gcGF5bG9hZDtcblx0XHRwYXlsb2FkLmlzc3Vlcy5wdXNoKHtcblx0XHRcdGNvZGU6IFwiaW52YWxpZF92YWx1ZVwiLFxuXHRcdFx0dmFsdWVzLFxuXHRcdFx0aW5wdXQsXG5cdFx0XHRpbnN0XG5cdFx0fSk7XG5cdFx0cmV0dXJuIHBheWxvYWQ7XG5cdH07XG59KTtcbmNvbnN0ICRab2RUcmFuc2Zvcm0gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFRyYW5zZm9ybVwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcblx0aW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIF9jdHgpID0+IHtcblx0XHRjb25zdCBfb3V0ID0gZGVmLnRyYW5zZm9ybShwYXlsb2FkLnZhbHVlLCBwYXlsb2FkKTtcblx0XHRpZiAoX2N0eC5hc3luYykgcmV0dXJuIChfb3V0IGluc3RhbmNlb2YgUHJvbWlzZSA/IF9vdXQgOiBQcm9taXNlLnJlc29sdmUoX291dCkpLnRoZW4oKG91dHB1dCkgPT4ge1xuXHRcdFx0cGF5bG9hZC52YWx1ZSA9IG91dHB1dDtcblx0XHRcdHJldHVybiBwYXlsb2FkO1xuXHRcdH0pO1xuXHRcdGlmIChfb3V0IGluc3RhbmNlb2YgUHJvbWlzZSkgdGhyb3cgbmV3ICRab2RBc3luY0Vycm9yKCk7XG5cdFx0cGF5bG9hZC52YWx1ZSA9IF9vdXQ7XG5cdFx0cmV0dXJuIHBheWxvYWQ7XG5cdH07XG59KTtcbmNvbnN0ICRab2RPcHRpb25hbCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcblx0aW5zdC5fem9kLm9wdG91dCA9IFwib3B0aW9uYWxcIjtcblx0ZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwidmFsdWVzXCIsICgpID0+IHtcblx0XHRyZXR1cm4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyA/IG5ldyBTZXQoWy4uLmRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMsIHZvaWQgMF0pIDogdm9pZCAwO1xuXHR9KTtcblx0ZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwicGF0dGVyblwiLCAoKSA9PiB7XG5cdFx0Y29uc3QgcGF0dGVybiA9IGRlZi5pbm5lclR5cGUuX3pvZC5wYXR0ZXJuO1xuXHRcdHJldHVybiBwYXR0ZXJuID8gLyogQF9fUFVSRV9fICovIG5ldyBSZWdFeHAoYF4oJHtjbGVhblJlZ2V4KHBhdHRlcm4uc291cmNlKX0pPyRgKSA6IHZvaWQgMDtcblx0fSk7XG5cdGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcblx0XHRpZiAoZGVmLmlubmVyVHlwZS5fem9kLm9wdGluID09PSBcIm9wdGlvbmFsXCIpIHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG5cdFx0aWYgKHBheWxvYWQudmFsdWUgPT09IHZvaWQgMCkgcmV0dXJuIHBheWxvYWQ7XG5cdFx0cmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcblx0fTtcbn0pO1xuY29uc3QgJFpvZE51bGxhYmxlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2ROdWxsYWJsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcblx0ZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0aW5cIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLm9wdGluKTtcblx0ZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRvdXQpO1xuXHRkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJwYXR0ZXJuXCIsICgpID0+IHtcblx0XHRjb25zdCBwYXR0ZXJuID0gZGVmLmlubmVyVHlwZS5fem9kLnBhdHRlcm47XG5cdFx0cmV0dXJuIHBhdHRlcm4gPyAvKiBAX19QVVJFX18gKi8gbmV3IFJlZ0V4cChgXigke2NsZWFuUmVnZXgocGF0dGVybi5zb3VyY2UpfXxudWxsKSRgKSA6IHZvaWQgMDtcblx0fSk7XG5cdGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG5cdFx0cmV0dXJuIGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXMgPyBuZXcgU2V0KFsuLi5kZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzLCBudWxsXSkgOiB2b2lkIDA7XG5cdH0pO1xuXHRpbnN0Ll96b2QucGFyc2UgPSAocGF5bG9hZCwgY3R4KSA9PiB7XG5cdFx0aWYgKHBheWxvYWQudmFsdWUgPT09IG51bGwpIHJldHVybiBwYXlsb2FkO1xuXHRcdHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG5cdH07XG59KTtcbmNvbnN0ICRab2REZWZhdWx0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2REZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcblx0JFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuXHRpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG5cdGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcblx0aW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuXHRcdGlmIChwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHtcblx0XHRcdHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuXHRcdFx0LyoqXG5cdFx0XHQqICRab2REZWZhdWx0IGFsd2F5cyByZXR1cm5zIHRoZSBkZWZhdWx0IHZhbHVlIGltbWVkaWF0ZWx5LlxuXHRcdFx0KiBJdCBkb2Vzbid0IHBhc3MgdGhlIGRlZmF1bHQgdmFsdWUgaW50byB0aGUgdmFsaWRhdG9yIChcInByZWZhdWx0XCIpLiBUaGVyZSdzIG5vIHJlYXNvbiB0byBwYXNzIHRoZSBkZWZhdWx0IHZhbHVlIHRocm91Z2ggdmFsaWRhdGlvbi4gVGhlIHZhbGlkaXR5IG9mIHRoZSBkZWZhdWx0IGlzIGVuZm9yY2VkIGJ5IFR5cGVTY3JpcHQgc3RhdGljYWxseS4gT3RoZXJ3aXNlLCBpdCdzIHRoZSByZXNwb25zaWJpbGl0eSBvZiB0aGUgdXNlciB0byBlbnN1cmUgdGhlIGRlZmF1bHQgaXMgdmFsaWQuIEluIHRoZSBjYXNlIG9mIHBpcGVzIHdpdGggZGl2ZXJnZW50IGluL291dCB0eXBlcywgeW91IGNhbiBzcGVjaWZ5IHRoZSBkZWZhdWx0IG9uIHRoZSBgaW5gIHNjaGVtYSBvZiB5b3VyIFpvZFBpcGUgdG8gc2V0IGEgXCJwcmVmYXVsdFwiIGZvciB0aGUgcGlwZS4gICAqL1xuXHRcdFx0cmV0dXJuIHBheWxvYWQ7XG5cdFx0fVxuXHRcdGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcblx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQkMSkgPT4gaGFuZGxlRGVmYXVsdFJlc3VsdChyZXN1bHQkMSwgZGVmKSk7XG5cdFx0cmV0dXJuIGhhbmRsZURlZmF1bHRSZXN1bHQocmVzdWx0LCBkZWYpO1xuXHR9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVEZWZhdWx0UmVzdWx0KHBheWxvYWQsIGRlZikge1xuXHRpZiAocGF5bG9hZC52YWx1ZSA9PT0gdm9pZCAwKSBwYXlsb2FkLnZhbHVlID0gZGVmLmRlZmF1bHRWYWx1ZTtcblx0cmV0dXJuIHBheWxvYWQ7XG59XG5jb25zdCAkWm9kUHJlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFByZWZhdWx0XCIsIChpbnN0LCBkZWYpID0+IHtcblx0JFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuXHRpbnN0Ll96b2Qub3B0aW4gPSBcIm9wdGlvbmFsXCI7XG5cdGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2QudmFsdWVzKTtcblx0aW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuXHRcdGlmIChwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHBheWxvYWQudmFsdWUgPSBkZWYuZGVmYXVsdFZhbHVlO1xuXHRcdHJldHVybiBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG5cdH07XG59KTtcbmNvbnN0ICRab2ROb25PcHRpb25hbCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kTm9uT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiB7XG5cdFx0Y29uc3QgdiA9IGRlZi5pbm5lclR5cGUuX3pvZC52YWx1ZXM7XG5cdFx0cmV0dXJuIHYgPyBuZXcgU2V0KFsuLi52XS5maWx0ZXIoKHgpID0+IHggIT09IHZvaWQgMCkpIDogdm9pZCAwO1xuXHR9KTtcblx0aW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcblx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHJlc3VsdC50aGVuKChyZXN1bHQkMSkgPT4gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocmVzdWx0JDEsIGluc3QpKTtcblx0XHRyZXR1cm4gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocmVzdWx0LCBpbnN0KTtcblx0fTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlTm9uT3B0aW9uYWxSZXN1bHQocGF5bG9hZCwgaW5zdCkge1xuXHRpZiAoIXBheWxvYWQuaXNzdWVzLmxlbmd0aCAmJiBwYXlsb2FkLnZhbHVlID09PSB2b2lkIDApIHBheWxvYWQuaXNzdWVzLnB1c2goe1xuXHRcdGNvZGU6IFwiaW52YWxpZF90eXBlXCIsXG5cdFx0ZXhwZWN0ZWQ6IFwibm9ub3B0aW9uYWxcIixcblx0XHRpbnB1dDogcGF5bG9hZC52YWx1ZSxcblx0XHRpbnN0XG5cdH0pO1xuXHRyZXR1cm4gcGF5bG9hZDtcbn1cbmNvbnN0ICRab2RDYXRjaCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kQ2F0Y2hcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QuX3pvZC5vcHRpbiA9IFwib3B0aW9uYWxcIjtcblx0ZGVmaW5lTGF6eShpbnN0Ll96b2QsIFwib3B0b3V0XCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRvdXQpO1xuXHRkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG5cdGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBjdHgpID0+IHtcblx0XHRjb25zdCByZXN1bHQgPSBkZWYuaW5uZXJUeXBlLl96b2QucnVuKHBheWxvYWQsIGN0eCk7XG5cdFx0aWYgKHJlc3VsdCBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiByZXN1bHQudGhlbigocmVzdWx0JDEpID0+IHtcblx0XHRcdHBheWxvYWQudmFsdWUgPSByZXN1bHQkMS52YWx1ZTtcblx0XHRcdGlmIChyZXN1bHQkMS5pc3N1ZXMubGVuZ3RoKSB7XG5cdFx0XHRcdHBheWxvYWQudmFsdWUgPSBkZWYuY2F0Y2hWYWx1ZSh7XG5cdFx0XHRcdFx0Li4ucGF5bG9hZCxcblx0XHRcdFx0XHRlcnJvcjogeyBpc3N1ZXM6IHJlc3VsdCQxLmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSB9LFxuXHRcdFx0XHRcdGlucHV0OiBwYXlsb2FkLnZhbHVlXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRwYXlsb2FkLmlzc3VlcyA9IFtdO1xuXHRcdFx0fVxuXHRcdFx0cmV0dXJuIHBheWxvYWQ7XG5cdFx0fSk7XG5cdFx0cGF5bG9hZC52YWx1ZSA9IHJlc3VsdC52YWx1ZTtcblx0XHRpZiAocmVzdWx0Lmlzc3Vlcy5sZW5ndGgpIHtcblx0XHRcdHBheWxvYWQudmFsdWUgPSBkZWYuY2F0Y2hWYWx1ZSh7XG5cdFx0XHRcdC4uLnBheWxvYWQsXG5cdFx0XHRcdGVycm9yOiB7IGlzc3VlczogcmVzdWx0Lmlzc3Vlcy5tYXAoKGlzcykgPT4gZmluYWxpemVJc3N1ZShpc3MsIGN0eCwgY29uZmlnKCkpKSB9LFxuXHRcdFx0XHRpbnB1dDogcGF5bG9hZC52YWx1ZVxuXHRcdFx0fSk7XG5cdFx0XHRwYXlsb2FkLmlzc3VlcyA9IFtdO1xuXHRcdH1cblx0XHRyZXR1cm4gcGF5bG9hZDtcblx0fTtcbn0pO1xuY29uc3QgJFpvZFBpcGUgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiJFpvZFBpcGVcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGRlZmluZUxhenkoaW5zdC5fem9kLCBcInZhbHVlc1wiLCAoKSA9PiBkZWYuaW4uX3pvZC52YWx1ZXMpO1xuXHRkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJvcHRpblwiLCAoKSA9PiBkZWYuaW4uX3pvZC5vcHRpbik7XG5cdGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYub3V0Ll96b2Qub3B0b3V0KTtcblx0aW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuXHRcdGNvbnN0IGxlZnQgPSBkZWYuaW4uX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcblx0XHRpZiAobGVmdCBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBsZWZ0LnRoZW4oKGxlZnQkMSkgPT4gaGFuZGxlUGlwZVJlc3VsdChsZWZ0JDEsIGRlZiwgY3R4KSk7XG5cdFx0cmV0dXJuIGhhbmRsZVBpcGVSZXN1bHQobGVmdCwgZGVmLCBjdHgpO1xuXHR9O1xufSk7XG5mdW5jdGlvbiBoYW5kbGVQaXBlUmVzdWx0KGxlZnQsIGRlZiwgY3R4KSB7XG5cdGlmIChhYm9ydGVkKGxlZnQpKSByZXR1cm4gbGVmdDtcblx0cmV0dXJuIGRlZi5vdXQuX3pvZC5ydW4oe1xuXHRcdHZhbHVlOiBsZWZ0LnZhbHVlLFxuXHRcdGlzc3VlczogbGVmdC5pc3N1ZXNcblx0fSwgY3R4KTtcbn1cbmNvbnN0ICRab2RSZWFkb25seSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCIkWm9kUmVhZG9ubHlcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGRlZmluZUxhenkoaW5zdC5fem9kLCBcInByb3BWYWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnByb3BWYWx1ZXMpO1xuXHRkZWZpbmVMYXp5KGluc3QuX3pvZCwgXCJ2YWx1ZXNcIiwgKCkgPT4gZGVmLmlubmVyVHlwZS5fem9kLnZhbHVlcyk7XG5cdGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdGluXCIsICgpID0+IGRlZi5pbm5lclR5cGUuX3pvZC5vcHRpbik7XG5cdGRlZmluZUxhenkoaW5zdC5fem9kLCBcIm9wdG91dFwiLCAoKSA9PiBkZWYuaW5uZXJUeXBlLl96b2Qub3B0b3V0KTtcblx0aW5zdC5fem9kLnBhcnNlID0gKHBheWxvYWQsIGN0eCkgPT4ge1xuXHRcdGNvbnN0IHJlc3VsdCA9IGRlZi5pbm5lclR5cGUuX3pvZC5ydW4ocGF5bG9hZCwgY3R4KTtcblx0XHRpZiAocmVzdWx0IGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHJlc3VsdC50aGVuKGhhbmRsZVJlYWRvbmx5UmVzdWx0KTtcblx0XHRyZXR1cm4gaGFuZGxlUmVhZG9ubHlSZXN1bHQocmVzdWx0KTtcblx0fTtcbn0pO1xuZnVuY3Rpb24gaGFuZGxlUmVhZG9ubHlSZXN1bHQocGF5bG9hZCkge1xuXHRwYXlsb2FkLnZhbHVlID0gT2JqZWN0LmZyZWV6ZShwYXlsb2FkLnZhbHVlKTtcblx0cmV0dXJuIHBheWxvYWQ7XG59XG5jb25zdCAkWm9kQ3VzdG9tID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIiRab2RDdXN0b21cIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kQ2hlY2suaW5pdChpbnN0LCBkZWYpO1xuXHQkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfKSA9PiB7XG5cdFx0cmV0dXJuIHBheWxvYWQ7XG5cdH07XG5cdGluc3QuX3pvZC5jaGVjayA9IChwYXlsb2FkKSA9PiB7XG5cdFx0Y29uc3QgaW5wdXQgPSBwYXlsb2FkLnZhbHVlO1xuXHRcdGNvbnN0IHIgPSBkZWYuZm4oaW5wdXQpO1xuXHRcdGlmIChyIGluc3RhbmNlb2YgUHJvbWlzZSkgcmV0dXJuIHIudGhlbigociQxKSA9PiBoYW5kbGVSZWZpbmVSZXN1bHQociQxLCBwYXlsb2FkLCBpbnB1dCwgaW5zdCkpO1xuXHRcdGhhbmRsZVJlZmluZVJlc3VsdChyLCBwYXlsb2FkLCBpbnB1dCwgaW5zdCk7XG5cdH07XG59KTtcbmZ1bmN0aW9uIGhhbmRsZVJlZmluZVJlc3VsdChyZXN1bHQsIHBheWxvYWQsIGlucHV0LCBpbnN0KSB7XG5cdGlmICghcmVzdWx0KSB7XG5cdFx0Y29uc3QgX2lzcyA9IHtcblx0XHRcdGNvZGU6IFwiY3VzdG9tXCIsXG5cdFx0XHRpbnB1dCxcblx0XHRcdGluc3QsXG5cdFx0XHRwYXRoOiBbLi4uaW5zdC5fem9kLmRlZi5wYXRoID8/IFtdXSxcblx0XHRcdGNvbnRpbnVlOiAhaW5zdC5fem9kLmRlZi5hYm9ydFxuXHRcdH07XG5cdFx0aWYgKGluc3QuX3pvZC5kZWYucGFyYW1zKSBfaXNzLnBhcmFtcyA9IGluc3QuX3pvZC5kZWYucGFyYW1zO1xuXHRcdHBheWxvYWQuaXNzdWVzLnB1c2goaXNzdWUoX2lzcykpO1xuXHR9XG59XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL3JlZ2lzdHJpZXMuanNcbmNvbnN0ICRvdXRwdXQgPSBTeW1ib2woXCJab2RPdXRwdXRcIik7XG5jb25zdCAkaW5wdXQgPSBTeW1ib2woXCJab2RJbnB1dFwiKTtcbnZhciAkWm9kUmVnaXN0cnkgPSBjbGFzcyB7XG5cdGNvbnN0cnVjdG9yKCkge1xuXHRcdHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5cdFx0dGhpcy5faWRtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuXHR9XG5cdGFkZChzY2hlbWEsIC4uLl9tZXRhKSB7XG5cdFx0Y29uc3QgbWV0YSA9IF9tZXRhWzBdO1xuXHRcdHRoaXMuX21hcC5zZXQoc2NoZW1hLCBtZXRhKTtcblx0XHRpZiAobWV0YSAmJiB0eXBlb2YgbWV0YSA9PT0gXCJvYmplY3RcIiAmJiBcImlkXCIgaW4gbWV0YSkge1xuXHRcdFx0aWYgKHRoaXMuX2lkbWFwLmhhcyhtZXRhLmlkKSkgdGhyb3cgbmV3IEVycm9yKGBJRCAke21ldGEuaWR9IGFscmVhZHkgZXhpc3RzIGluIHRoZSByZWdpc3RyeWApO1xuXHRcdFx0dGhpcy5faWRtYXAuc2V0KG1ldGEuaWQsIHNjaGVtYSk7XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGNsZWFyKCkge1xuXHRcdHRoaXMuX21hcCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgTWFwKCk7XG5cdFx0dGhpcy5faWRtYXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hcCgpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdHJlbW92ZShzY2hlbWEpIHtcblx0XHRjb25zdCBtZXRhID0gdGhpcy5fbWFwLmdldChzY2hlbWEpO1xuXHRcdGlmIChtZXRhICYmIHR5cGVvZiBtZXRhID09PSBcIm9iamVjdFwiICYmIFwiaWRcIiBpbiBtZXRhKSB0aGlzLl9pZG1hcC5kZWxldGUobWV0YS5pZCk7XG5cdFx0dGhpcy5fbWFwLmRlbGV0ZShzY2hlbWEpO1xuXHRcdHJldHVybiB0aGlzO1xuXHR9XG5cdGdldChzY2hlbWEpIHtcblx0XHRjb25zdCBwID0gc2NoZW1hLl96b2QucGFyZW50O1xuXHRcdGlmIChwKSB7XG5cdFx0XHRjb25zdCBwbSA9IHsgLi4udGhpcy5nZXQocCkgPz8ge30gfTtcblx0XHRcdGRlbGV0ZSBwbS5pZDtcblx0XHRcdHJldHVybiB7XG5cdFx0XHRcdC4uLnBtLFxuXHRcdFx0XHQuLi50aGlzLl9tYXAuZ2V0KHNjaGVtYSlcblx0XHRcdH07XG5cdFx0fVxuXHRcdHJldHVybiB0aGlzLl9tYXAuZ2V0KHNjaGVtYSk7XG5cdH1cblx0aGFzKHNjaGVtYSkge1xuXHRcdHJldHVybiB0aGlzLl9tYXAuaGFzKHNjaGVtYSk7XG5cdH1cbn07XG5mdW5jdGlvbiByZWdpc3RyeSgpIHtcblx0cmV0dXJuIG5ldyAkWm9kUmVnaXN0cnkoKTtcbn1cbmNvbnN0IGdsb2JhbFJlZ2lzdHJ5ID0gLyogQF9fUFVSRV9fICovIHJlZ2lzdHJ5KCk7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIG5vZGVfbW9kdWxlcy8ucG5wbS96b2RANC4wLjEvbm9kZV9tb2R1bGVzL3pvZC92NC9jb3JlL2FwaS5qc1xuZnVuY3Rpb24gX3Vua25vd24oQ2xhc3MpIHtcblx0cmV0dXJuIG5ldyBDbGFzcyh7IHR5cGU6IFwidW5rbm93blwiIH0pO1xufVxuZnVuY3Rpb24gX25ldmVyKENsYXNzLCBwYXJhbXMpIHtcblx0cmV0dXJuIG5ldyBDbGFzcyh7XG5cdFx0dHlwZTogXCJuZXZlclwiLFxuXHRcdC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpXG5cdH0pO1xufVxuZnVuY3Rpb24gX21heExlbmd0aChtYXhpbXVtLCBwYXJhbXMpIHtcblx0cmV0dXJuIG5ldyAkWm9kQ2hlY2tNYXhMZW5ndGgoe1xuXHRcdGNoZWNrOiBcIm1heF9sZW5ndGhcIixcblx0XHQuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcblx0XHRtYXhpbXVtXG5cdH0pO1xufVxuZnVuY3Rpb24gX21pbkxlbmd0aChtaW5pbXVtLCBwYXJhbXMpIHtcblx0cmV0dXJuIG5ldyAkWm9kQ2hlY2tNaW5MZW5ndGgoe1xuXHRcdGNoZWNrOiBcIm1pbl9sZW5ndGhcIixcblx0XHQuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcblx0XHRtaW5pbXVtXG5cdH0pO1xufVxuZnVuY3Rpb24gX2xlbmd0aChsZW5ndGgsIHBhcmFtcykge1xuXHRyZXR1cm4gbmV3ICRab2RDaGVja0xlbmd0aEVxdWFscyh7XG5cdFx0Y2hlY2s6IFwibGVuZ3RoX2VxdWFsc1wiLFxuXHRcdC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuXHRcdGxlbmd0aFxuXHR9KTtcbn1cbmZ1bmN0aW9uIF9vdmVyd3JpdGUodHgpIHtcblx0cmV0dXJuIG5ldyAkWm9kQ2hlY2tPdmVyd3JpdGUoe1xuXHRcdGNoZWNrOiBcIm92ZXJ3cml0ZVwiLFxuXHRcdHR4XG5cdH0pO1xufVxuZnVuY3Rpb24gX2FycmF5KENsYXNzLCBlbGVtZW50LCBwYXJhbXMpIHtcblx0cmV0dXJuIG5ldyBDbGFzcyh7XG5cdFx0dHlwZTogXCJhcnJheVwiLFxuXHRcdGVsZW1lbnQsXG5cdFx0Li4ubm9ybWFsaXplUGFyYW1zKHBhcmFtcylcblx0fSk7XG59XG5mdW5jdGlvbiBfcmVmaW5lKENsYXNzLCBmbiwgX3BhcmFtcykge1xuXHRyZXR1cm4gbmV3IENsYXNzKHtcblx0XHR0eXBlOiBcImN1c3RvbVwiLFxuXHRcdGNoZWNrOiBcImN1c3RvbVwiLFxuXHRcdGZuLFxuXHRcdC4uLm5vcm1hbGl6ZVBhcmFtcyhfcGFyYW1zKVxuXHR9KTtcbn1cblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NsYXNzaWMvZXJyb3JzLmpzXG5jb25zdCBpbml0aWFsaXplciA9IChpbnN0LCBpc3N1ZXMpID0+IHtcblx0JFpvZEVycm9yLmluaXQoaW5zdCwgaXNzdWVzKTtcblx0aW5zdC5uYW1lID0gXCJab2RFcnJvclwiO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydGllcyhpbnN0LCB7XG5cdFx0Zm9ybWF0OiB7IHZhbHVlOiAobWFwcGVyKSA9PiBmb3JtYXRFcnJvcihpbnN0LCBtYXBwZXIpIH0sXG5cdFx0ZmxhdHRlbjogeyB2YWx1ZTogKG1hcHBlcikgPT4gZmxhdHRlbkVycm9yKGluc3QsIG1hcHBlcikgfSxcblx0XHRhZGRJc3N1ZTogeyB2YWx1ZTogKGlzc3VlJDEpID0+IGluc3QuaXNzdWVzLnB1c2goaXNzdWUkMSkgfSxcblx0XHRhZGRJc3N1ZXM6IHsgdmFsdWU6IChpc3N1ZXMkMSkgPT4gaW5zdC5pc3N1ZXMucHVzaCguLi5pc3N1ZXMkMSkgfSxcblx0XHRpc0VtcHR5OiB7IGdldCgpIHtcblx0XHRcdHJldHVybiBpbnN0Lmlzc3Vlcy5sZW5ndGggPT09IDA7XG5cdFx0fSB9XG5cdH0pO1xufTtcbmNvbnN0IFpvZEVycm9yID0gJGNvbnN0cnVjdG9yKFwiWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIpO1xuY29uc3QgWm9kUmVhbEVycm9yID0gJGNvbnN0cnVjdG9yKFwiWm9kRXJyb3JcIiwgaW5pdGlhbGl6ZXIsIHsgUGFyZW50OiBFcnJvciB9KTtcblxuLy8jZW5kcmVnaW9uXG4vLyNyZWdpb24gbm9kZV9tb2R1bGVzLy5wbnBtL3pvZEA0LjAuMS9ub2RlX21vZHVsZXMvem9kL3Y0L2NsYXNzaWMvcGFyc2UuanNcbmNvbnN0IHBhcnNlID0gLyogQF9fUFVSRV9fICovIF9wYXJzZShab2RSZWFsRXJyb3IpO1xuY29uc3QgcGFyc2VBc3luYyA9IC8qIEBfX1BVUkVfXyAqLyBfcGFyc2VBc3luYyhab2RSZWFsRXJyb3IpO1xuY29uc3Qgc2FmZVBhcnNlID0gLyogQF9fUFVSRV9fICovIF9zYWZlUGFyc2UoWm9kUmVhbEVycm9yKTtcbmNvbnN0IHNhZmVQYXJzZUFzeW5jID0gLyogQF9fUFVSRV9fICovIF9zYWZlUGFyc2VBc3luYyhab2RSZWFsRXJyb3IpO1xuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBub2RlX21vZHVsZXMvLnBucG0vem9kQDQuMC4xL25vZGVfbW9kdWxlcy96b2QvdjQvY2xhc3NpYy9zY2hlbWFzLmpzXG5jb25zdCBab2RUeXBlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFR5cGVcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QuZGVmID0gZGVmO1xuXHRPYmplY3QuZGVmaW5lUHJvcGVydHkoaW5zdCwgXCJfZGVmXCIsIHsgdmFsdWU6IGRlZiB9KTtcblx0aW5zdC5jaGVjayA9ICguLi5jaGVja3MpID0+IHtcblx0XHRyZXR1cm4gaW5zdC5jbG9uZSh7XG5cdFx0XHQuLi5kZWYsXG5cdFx0XHRjaGVja3M6IFsuLi5kZWYuY2hlY2tzID8/IFtdLCAuLi5jaGVja3MubWFwKChjaCkgPT4gdHlwZW9mIGNoID09PSBcImZ1bmN0aW9uXCIgPyB7IF96b2Q6IHtcblx0XHRcdFx0Y2hlY2s6IGNoLFxuXHRcdFx0XHRkZWY6IHsgY2hlY2s6IFwiY3VzdG9tXCIgfSxcblx0XHRcdFx0b25hdHRhY2g6IFtdXG5cdFx0XHR9IH0gOiBjaCldXG5cdFx0fSk7XG5cdH07XG5cdGluc3QuY2xvbmUgPSAoZGVmJDEsIHBhcmFtcykgPT4gY2xvbmUoaW5zdCwgZGVmJDEsIHBhcmFtcyk7XG5cdGluc3QuYnJhbmQgPSAoKSA9PiBpbnN0O1xuXHRpbnN0LnJlZ2lzdGVyID0gKChyZWcsIG1ldGEpID0+IHtcblx0XHRyZWcuYWRkKGluc3QsIG1ldGEpO1xuXHRcdHJldHVybiBpbnN0O1xuXHR9KTtcblx0aW5zdC5wYXJzZSA9IChkYXRhLCBwYXJhbXMpID0+IHBhcnNlKGluc3QsIGRhdGEsIHBhcmFtcywgeyBjYWxsZWU6IGluc3QucGFyc2UgfSk7XG5cdGluc3Quc2FmZVBhcnNlID0gKGRhdGEsIHBhcmFtcykgPT4gc2FmZVBhcnNlKGluc3QsIGRhdGEsIHBhcmFtcyk7XG5cdGluc3QucGFyc2VBc3luYyA9IGFzeW5jIChkYXRhLCBwYXJhbXMpID0+IHBhcnNlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zLCB7IGNhbGxlZTogaW5zdC5wYXJzZUFzeW5jIH0pO1xuXHRpbnN0LnNhZmVQYXJzZUFzeW5jID0gYXN5bmMgKGRhdGEsIHBhcmFtcykgPT4gc2FmZVBhcnNlQXN5bmMoaW5zdCwgZGF0YSwgcGFyYW1zKTtcblx0aW5zdC5zcGEgPSBpbnN0LnNhZmVQYXJzZUFzeW5jO1xuXHRpbnN0LnJlZmluZSA9IChjaGVjayQxLCBwYXJhbXMpID0+IGluc3QuY2hlY2socmVmaW5lKGNoZWNrJDEsIHBhcmFtcykpO1xuXHRpbnN0LnN1cGVyUmVmaW5lID0gKHJlZmluZW1lbnQpID0+IGluc3QuY2hlY2soc3VwZXJSZWZpbmUocmVmaW5lbWVudCkpO1xuXHRpbnN0Lm92ZXJ3cml0ZSA9IChmbikgPT4gaW5zdC5jaGVjayhfb3ZlcndyaXRlKGZuKSk7XG5cdGluc3Qub3B0aW9uYWwgPSAoKSA9PiBvcHRpb25hbChpbnN0KTtcblx0aW5zdC5udWxsYWJsZSA9ICgpID0+IG51bGxhYmxlKGluc3QpO1xuXHRpbnN0Lm51bGxpc2ggPSAoKSA9PiBvcHRpb25hbChudWxsYWJsZShpbnN0KSk7XG5cdGluc3Qubm9ub3B0aW9uYWwgPSAocGFyYW1zKSA9PiBub25vcHRpb25hbChpbnN0LCBwYXJhbXMpO1xuXHRpbnN0LmFycmF5ID0gKCkgPT4gYXJyYXkoaW5zdCk7XG5cdGluc3Qub3IgPSAoYXJnKSA9PiB1bmlvbihbaW5zdCwgYXJnXSk7XG5cdGluc3QuYW5kID0gKGFyZykgPT4gaW50ZXJzZWN0aW9uKGluc3QsIGFyZyk7XG5cdGluc3QudHJhbnNmb3JtID0gKHR4KSA9PiBwaXBlKGluc3QsIHRyYW5zZm9ybSh0eCkpO1xuXHRpbnN0LmRlZmF1bHQgPSAoZGVmJDEpID0+IF9kZWZhdWx0KGluc3QsIGRlZiQxKTtcblx0aW5zdC5wcmVmYXVsdCA9IChkZWYkMSkgPT4gcHJlZmF1bHQoaW5zdCwgZGVmJDEpO1xuXHRpbnN0LmNhdGNoID0gKHBhcmFtcykgPT4gX2NhdGNoKGluc3QsIHBhcmFtcyk7XG5cdGluc3QucGlwZSA9ICh0YXJnZXQpID0+IHBpcGUoaW5zdCwgdGFyZ2V0KTtcblx0aW5zdC5yZWFkb25seSA9ICgpID0+IHJlYWRvbmx5KGluc3QpO1xuXHRpbnN0LmRlc2NyaWJlID0gKGRlc2NyaXB0aW9uKSA9PiB7XG5cdFx0Y29uc3QgY2wgPSBpbnN0LmNsb25lKCk7XG5cdFx0Z2xvYmFsUmVnaXN0cnkuYWRkKGNsLCB7IGRlc2NyaXB0aW9uIH0pO1xuXHRcdHJldHVybiBjbDtcblx0fTtcblx0T2JqZWN0LmRlZmluZVByb3BlcnR5KGluc3QsIFwiZGVzY3JpcHRpb25cIiwge1xuXHRcdGdldCgpIHtcblx0XHRcdHJldHVybiBnbG9iYWxSZWdpc3RyeS5nZXQoaW5zdCk/LmRlc2NyaXB0aW9uO1xuXHRcdH0sXG5cdFx0Y29uZmlndXJhYmxlOiB0cnVlXG5cdH0pO1xuXHRpbnN0Lm1ldGEgPSAoLi4uYXJncykgPT4ge1xuXHRcdGlmIChhcmdzLmxlbmd0aCA9PT0gMCkgcmV0dXJuIGdsb2JhbFJlZ2lzdHJ5LmdldChpbnN0KTtcblx0XHRjb25zdCBjbCA9IGluc3QuY2xvbmUoKTtcblx0XHRnbG9iYWxSZWdpc3RyeS5hZGQoY2wsIGFyZ3NbMF0pO1xuXHRcdHJldHVybiBjbDtcblx0fTtcblx0aW5zdC5pc09wdGlvbmFsID0gKCkgPT4gaW5zdC5zYWZlUGFyc2Uodm9pZCAwKS5zdWNjZXNzO1xuXHRpbnN0LmlzTnVsbGFibGUgPSAoKSA9PiBpbnN0LnNhZmVQYXJzZShudWxsKS5zdWNjZXNzO1xuXHRyZXR1cm4gaW5zdDtcbn0pO1xuY29uc3QgWm9kVW5rbm93biA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RVbmtub3duXCIsIChpbnN0LCBkZWYpID0+IHtcblx0JFpvZFVua25vd24uaW5pdChpbnN0LCBkZWYpO1xuXHRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZnVuY3Rpb24gdW5rbm93bigpIHtcblx0cmV0dXJuIF91bmtub3duKFpvZFVua25vd24pO1xufVxuY29uc3QgWm9kTmV2ZXIgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kTmV2ZXJcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kTmV2ZXIuaW5pdChpbnN0LCBkZWYpO1xuXHRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZnVuY3Rpb24gbmV2ZXIocGFyYW1zKSB7XG5cdHJldHVybiBfbmV2ZXIoWm9kTmV2ZXIsIHBhcmFtcyk7XG59XG5jb25zdCBab2RBcnJheSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RBcnJheVwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RBcnJheS5pbml0KGluc3QsIGRlZik7XG5cdFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuXHRpbnN0LmVsZW1lbnQgPSBkZWYuZWxlbWVudDtcblx0aW5zdC5taW4gPSAobWluTGVuZ3RoLCBwYXJhbXMpID0+IGluc3QuY2hlY2soX21pbkxlbmd0aChtaW5MZW5ndGgsIHBhcmFtcykpO1xuXHRpbnN0Lm5vbmVtcHR5ID0gKHBhcmFtcykgPT4gaW5zdC5jaGVjayhfbWluTGVuZ3RoKDEsIHBhcmFtcykpO1xuXHRpbnN0Lm1heCA9IChtYXhMZW5ndGgsIHBhcmFtcykgPT4gaW5zdC5jaGVjayhfbWF4TGVuZ3RoKG1heExlbmd0aCwgcGFyYW1zKSk7XG5cdGluc3QubGVuZ3RoID0gKGxlbiwgcGFyYW1zKSA9PiBpbnN0LmNoZWNrKF9sZW5ndGgobGVuLCBwYXJhbXMpKTtcblx0aW5zdC51bndyYXAgPSAoKSA9PiBpbnN0LmVsZW1lbnQ7XG59KTtcbmZ1bmN0aW9uIGFycmF5KGVsZW1lbnQsIHBhcmFtcykge1xuXHRyZXR1cm4gX2FycmF5KFpvZEFycmF5LCBlbGVtZW50LCBwYXJhbXMpO1xufVxuY29uc3QgWm9kT2JqZWN0ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE9iamVjdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RPYmplY3QuaW5pdChpbnN0LCBkZWYpO1xuXHRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcblx0ZGVmaW5lTGF6eShpbnN0LCBcInNoYXBlXCIsICgpID0+IGRlZi5zaGFwZSk7XG5cdGluc3Qua2V5b2YgPSAoKSA9PiBfZW51bShPYmplY3Qua2V5cyhpbnN0Ll96b2QuZGVmLnNoYXBlKSk7XG5cdGluc3QuY2F0Y2hhbGwgPSAoY2F0Y2hhbGwpID0+IGluc3QuY2xvbmUoe1xuXHRcdC4uLmluc3QuX3pvZC5kZWYsXG5cdFx0Y2F0Y2hhbGxcblx0fSk7XG5cdGluc3QucGFzc3Rocm91Z2ggPSAoKSA9PiBpbnN0LmNsb25lKHtcblx0XHQuLi5pbnN0Ll96b2QuZGVmLFxuXHRcdGNhdGNoYWxsOiB1bmtub3duKClcblx0fSk7XG5cdGluc3QubG9vc2UgPSAoKSA9PiBpbnN0LmNsb25lKHtcblx0XHQuLi5pbnN0Ll96b2QuZGVmLFxuXHRcdGNhdGNoYWxsOiB1bmtub3duKClcblx0fSk7XG5cdGluc3Quc3RyaWN0ID0gKCkgPT4gaW5zdC5jbG9uZSh7XG5cdFx0Li4uaW5zdC5fem9kLmRlZixcblx0XHRjYXRjaGFsbDogbmV2ZXIoKVxuXHR9KTtcblx0aW5zdC5zdHJpcCA9ICgpID0+IGluc3QuY2xvbmUoe1xuXHRcdC4uLmluc3QuX3pvZC5kZWYsXG5cdFx0Y2F0Y2hhbGw6IHZvaWQgMFxuXHR9KTtcblx0aW5zdC5leHRlbmQgPSAoaW5jb21pbmcpID0+IHtcblx0XHRyZXR1cm4gZXh0ZW5kKGluc3QsIGluY29taW5nKTtcblx0fTtcblx0aW5zdC5tZXJnZSA9IChvdGhlcikgPT4gbWVyZ2UoaW5zdCwgb3RoZXIpO1xuXHRpbnN0LnBpY2sgPSAobWFzaykgPT4gcGljayhpbnN0LCBtYXNrKTtcblx0aW5zdC5vbWl0ID0gKG1hc2spID0+IG9taXQoaW5zdCwgbWFzayk7XG5cdGluc3QucGFydGlhbCA9ICguLi5hcmdzKSA9PiBwYXJ0aWFsKFpvZE9wdGlvbmFsLCBpbnN0LCBhcmdzWzBdKTtcblx0aW5zdC5yZXF1aXJlZCA9ICguLi5hcmdzKSA9PiByZXF1aXJlZChab2ROb25PcHRpb25hbCwgaW5zdCwgYXJnc1swXSk7XG59KTtcbmNvbnN0IFpvZFVuaW9uID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFVuaW9uXCIsIChpbnN0LCBkZWYpID0+IHtcblx0JFpvZFVuaW9uLmluaXQoaW5zdCwgZGVmKTtcblx0Wm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3Qub3B0aW9ucyA9IGRlZi5vcHRpb25zO1xufSk7XG5mdW5jdGlvbiB1bmlvbihvcHRpb25zLCBwYXJhbXMpIHtcblx0cmV0dXJuIG5ldyBab2RVbmlvbih7XG5cdFx0dHlwZTogXCJ1bmlvblwiLFxuXHRcdG9wdGlvbnMsXG5cdFx0Li4ubm9ybWFsaXplUGFyYW1zKHBhcmFtcylcblx0fSk7XG59XG5jb25zdCBab2RJbnRlcnNlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kSW50ZXJzZWN0aW9uXCIsIChpbnN0LCBkZWYpID0+IHtcblx0JFpvZEludGVyc2VjdGlvbi5pbml0KGluc3QsIGRlZik7XG5cdFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xufSk7XG5mdW5jdGlvbiBpbnRlcnNlY3Rpb24obGVmdCwgcmlnaHQpIHtcblx0cmV0dXJuIG5ldyBab2RJbnRlcnNlY3Rpb24oe1xuXHRcdHR5cGU6IFwiaW50ZXJzZWN0aW9uXCIsXG5cdFx0bGVmdCxcblx0XHRyaWdodFxuXHR9KTtcbn1cbmNvbnN0IFpvZEVudW0gPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kRW51bVwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RFbnVtLmluaXQoaW5zdCwgZGVmKTtcblx0Wm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QuZW51bSA9IGRlZi5lbnRyaWVzO1xuXHRpbnN0Lm9wdGlvbnMgPSBPYmplY3QudmFsdWVzKGRlZi5lbnRyaWVzKTtcblx0Y29uc3Qga2V5cyA9IG5ldyBTZXQoT2JqZWN0LmtleXMoZGVmLmVudHJpZXMpKTtcblx0aW5zdC5leHRyYWN0ID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG5cdFx0Y29uc3QgbmV3RW50cmllcyA9IHt9O1xuXHRcdGZvciAoY29uc3QgdmFsdWUgb2YgdmFsdWVzKSBpZiAoa2V5cy5oYXModmFsdWUpKSBuZXdFbnRyaWVzW3ZhbHVlXSA9IGRlZi5lbnRyaWVzW3ZhbHVlXTtcblx0XHRlbHNlIHRocm93IG5ldyBFcnJvcihgS2V5ICR7dmFsdWV9IG5vdCBmb3VuZCBpbiBlbnVtYCk7XG5cdFx0cmV0dXJuIG5ldyBab2RFbnVtKHtcblx0XHRcdC4uLmRlZixcblx0XHRcdGNoZWNrczogW10sXG5cdFx0XHQuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKSxcblx0XHRcdGVudHJpZXM6IG5ld0VudHJpZXNcblx0XHR9KTtcblx0fTtcblx0aW5zdC5leGNsdWRlID0gKHZhbHVlcywgcGFyYW1zKSA9PiB7XG5cdFx0Y29uc3QgbmV3RW50cmllcyA9IHsgLi4uZGVmLmVudHJpZXMgfTtcblx0XHRmb3IgKGNvbnN0IHZhbHVlIG9mIHZhbHVlcykgaWYgKGtleXMuaGFzKHZhbHVlKSkgZGVsZXRlIG5ld0VudHJpZXNbdmFsdWVdO1xuXHRcdGVsc2UgdGhyb3cgbmV3IEVycm9yKGBLZXkgJHt2YWx1ZX0gbm90IGZvdW5kIGluIGVudW1gKTtcblx0XHRyZXR1cm4gbmV3IFpvZEVudW0oe1xuXHRcdFx0Li4uZGVmLFxuXHRcdFx0Y2hlY2tzOiBbXSxcblx0XHRcdC4uLm5vcm1hbGl6ZVBhcmFtcyhwYXJhbXMpLFxuXHRcdFx0ZW50cmllczogbmV3RW50cmllc1xuXHRcdH0pO1xuXHR9O1xufSk7XG5mdW5jdGlvbiBfZW51bSh2YWx1ZXMsIHBhcmFtcykge1xuXHRyZXR1cm4gbmV3IFpvZEVudW0oe1xuXHRcdHR5cGU6IFwiZW51bVwiLFxuXHRcdGVudHJpZXM6IEFycmF5LmlzQXJyYXkodmFsdWVzKSA/IE9iamVjdC5mcm9tRW50cmllcyh2YWx1ZXMubWFwKCh2KSA9PiBbdiwgdl0pKSA6IHZhbHVlcyxcblx0XHQuLi5ub3JtYWxpemVQYXJhbXMocGFyYW1zKVxuXHR9KTtcbn1cbmNvbnN0IFpvZFRyYW5zZm9ybSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RUcmFuc2Zvcm1cIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kVHJhbnNmb3JtLmluaXQoaW5zdCwgZGVmKTtcblx0Wm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QuX3pvZC5wYXJzZSA9IChwYXlsb2FkLCBfY3R4KSA9PiB7XG5cdFx0cGF5bG9hZC5hZGRJc3N1ZSA9IChpc3N1ZSQxKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIGlzc3VlJDEgPT09IFwic3RyaW5nXCIpIHBheWxvYWQuaXNzdWVzLnB1c2goaXNzdWUoaXNzdWUkMSwgcGF5bG9hZC52YWx1ZSwgZGVmKSk7XG5cdFx0XHRlbHNlIHtcblx0XHRcdFx0Y29uc3QgX2lzc3VlID0gaXNzdWUkMTtcblx0XHRcdFx0aWYgKF9pc3N1ZS5mYXRhbCkgX2lzc3VlLmNvbnRpbnVlID0gZmFsc2U7XG5cdFx0XHRcdF9pc3N1ZS5jb2RlID8/IChfaXNzdWUuY29kZSA9IFwiY3VzdG9tXCIpO1xuXHRcdFx0XHRfaXNzdWUuaW5wdXQgPz8gKF9pc3N1ZS5pbnB1dCA9IHBheWxvYWQudmFsdWUpO1xuXHRcdFx0XHRfaXNzdWUuaW5zdCA/PyAoX2lzc3VlLmluc3QgPSBpbnN0KTtcblx0XHRcdFx0X2lzc3VlLmNvbnRpbnVlID8/IChfaXNzdWUuY29udGludWUgPSB0cnVlKTtcblx0XHRcdFx0cGF5bG9hZC5pc3N1ZXMucHVzaChpc3N1ZShfaXNzdWUpKTtcblx0XHRcdH1cblx0XHR9O1xuXHRcdGNvbnN0IG91dHB1dCA9IGRlZi50cmFuc2Zvcm0ocGF5bG9hZC52YWx1ZSwgcGF5bG9hZCk7XG5cdFx0aWYgKG91dHB1dCBpbnN0YW5jZW9mIFByb21pc2UpIHJldHVybiBvdXRwdXQudGhlbigob3V0cHV0JDEpID0+IHtcblx0XHRcdHBheWxvYWQudmFsdWUgPSBvdXRwdXQkMTtcblx0XHRcdHJldHVybiBwYXlsb2FkO1xuXHRcdH0pO1xuXHRcdHBheWxvYWQudmFsdWUgPSBvdXRwdXQ7XG5cdFx0cmV0dXJuIHBheWxvYWQ7XG5cdH07XG59KTtcbmZ1bmN0aW9uIHRyYW5zZm9ybShmbikge1xuXHRyZXR1cm4gbmV3IFpvZFRyYW5zZm9ybSh7XG5cdFx0dHlwZTogXCJ0cmFuc2Zvcm1cIixcblx0XHR0cmFuc2Zvcm06IGZuXG5cdH0pO1xufVxuY29uc3QgWm9kT3B0aW9uYWwgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kT3B0aW9uYWxcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kT3B0aW9uYWwuaW5pdChpbnN0LCBkZWYpO1xuXHRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcblx0aW5zdC51bndyYXAgPSAoKSA9PiBpbnN0Ll96b2QuZGVmLmlubmVyVHlwZTtcbn0pO1xuZnVuY3Rpb24gb3B0aW9uYWwoaW5uZXJUeXBlKSB7XG5cdHJldHVybiBuZXcgWm9kT3B0aW9uYWwoe1xuXHRcdHR5cGU6IFwib3B0aW9uYWxcIixcblx0XHRpbm5lclR5cGVcblx0fSk7XG59XG5jb25zdCBab2ROdWxsYWJsZSA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2ROdWxsYWJsZVwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2ROdWxsYWJsZS5pbml0KGluc3QsIGRlZik7XG5cdFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuXHRpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5mdW5jdGlvbiBudWxsYWJsZShpbm5lclR5cGUpIHtcblx0cmV0dXJuIG5ldyBab2ROdWxsYWJsZSh7XG5cdFx0dHlwZTogXCJudWxsYWJsZVwiLFxuXHRcdGlubmVyVHlwZVxuXHR9KTtcbn1cbmNvbnN0IFpvZERlZmF1bHQgPSAvKiBAX19QVVJFX18gKi8gJGNvbnN0cnVjdG9yKFwiWm9kRGVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2REZWZhdWx0LmluaXQoaW5zdCwgZGVmKTtcblx0Wm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG5cdGluc3QucmVtb3ZlRGVmYXVsdCA9IGluc3QudW53cmFwO1xufSk7XG5mdW5jdGlvbiBfZGVmYXVsdChpbm5lclR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuXHRyZXR1cm4gbmV3IFpvZERlZmF1bHQoe1xuXHRcdHR5cGU6IFwiZGVmYXVsdFwiLFxuXHRcdGlubmVyVHlwZSxcblx0XHRnZXQgZGVmYXVsdFZhbHVlKCkge1xuXHRcdFx0cmV0dXJuIHR5cGVvZiBkZWZhdWx0VmFsdWUgPT09IFwiZnVuY3Rpb25cIiA/IGRlZmF1bHRWYWx1ZSgpIDogZGVmYXVsdFZhbHVlO1xuXHRcdH1cblx0fSk7XG59XG5jb25zdCBab2RQcmVmYXVsdCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RQcmVmYXVsdFwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RQcmVmYXVsdC5pbml0KGluc3QsIGRlZik7XG5cdFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuXHRpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xufSk7XG5mdW5jdGlvbiBwcmVmYXVsdChpbm5lclR5cGUsIGRlZmF1bHRWYWx1ZSkge1xuXHRyZXR1cm4gbmV3IFpvZFByZWZhdWx0KHtcblx0XHR0eXBlOiBcInByZWZhdWx0XCIsXG5cdFx0aW5uZXJUeXBlLFxuXHRcdGdldCBkZWZhdWx0VmFsdWUoKSB7XG5cdFx0XHRyZXR1cm4gdHlwZW9mIGRlZmF1bHRWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gZGVmYXVsdFZhbHVlKCkgOiBkZWZhdWx0VmFsdWU7XG5cdFx0fVxuXHR9KTtcbn1cbmNvbnN0IFpvZE5vbk9wdGlvbmFsID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZE5vbk9wdGlvbmFsXCIsIChpbnN0LCBkZWYpID0+IHtcblx0JFpvZE5vbk9wdGlvbmFsLmluaXQoaW5zdCwgZGVmKTtcblx0Wm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG5cdGluc3QudW53cmFwID0gKCkgPT4gaW5zdC5fem9kLmRlZi5pbm5lclR5cGU7XG59KTtcbmZ1bmN0aW9uIG5vbm9wdGlvbmFsKGlubmVyVHlwZSwgcGFyYW1zKSB7XG5cdHJldHVybiBuZXcgWm9kTm9uT3B0aW9uYWwoe1xuXHRcdHR5cGU6IFwibm9ub3B0aW9uYWxcIixcblx0XHRpbm5lclR5cGUsXG5cdFx0Li4ubm9ybWFsaXplUGFyYW1zKHBhcmFtcylcblx0fSk7XG59XG5jb25zdCBab2RDYXRjaCA9IC8qIEBfX1BVUkVfXyAqLyAkY29uc3RydWN0b3IoXCJab2RDYXRjaFwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RDYXRjaC5pbml0KGluc3QsIGRlZik7XG5cdFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuXHRpbnN0LnVud3JhcCA9ICgpID0+IGluc3QuX3pvZC5kZWYuaW5uZXJUeXBlO1xuXHRpbnN0LnJlbW92ZUNhdGNoID0gaW5zdC51bndyYXA7XG59KTtcbmZ1bmN0aW9uIF9jYXRjaChpbm5lclR5cGUsIGNhdGNoVmFsdWUpIHtcblx0cmV0dXJuIG5ldyBab2RDYXRjaCh7XG5cdFx0dHlwZTogXCJjYXRjaFwiLFxuXHRcdGlubmVyVHlwZSxcblx0XHRjYXRjaFZhbHVlOiB0eXBlb2YgY2F0Y2hWYWx1ZSA9PT0gXCJmdW5jdGlvblwiID8gY2F0Y2hWYWx1ZSA6ICgpID0+IGNhdGNoVmFsdWVcblx0fSk7XG59XG5jb25zdCBab2RQaXBlID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFBpcGVcIiwgKGluc3QsIGRlZikgPT4ge1xuXHQkWm9kUGlwZS5pbml0KGluc3QsIGRlZik7XG5cdFpvZFR5cGUuaW5pdChpbnN0LCBkZWYpO1xuXHRpbnN0LmluID0gZGVmLmluO1xuXHRpbnN0Lm91dCA9IGRlZi5vdXQ7XG59KTtcbmZ1bmN0aW9uIHBpcGUoaW5fLCBvdXQpIHtcblx0cmV0dXJuIG5ldyBab2RQaXBlKHtcblx0XHR0eXBlOiBcInBpcGVcIixcblx0XHRpbjogaW5fLFxuXHRcdG91dFxuXHR9KTtcbn1cbmNvbnN0IFpvZFJlYWRvbmx5ID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZFJlYWRvbmx5XCIsIChpbnN0LCBkZWYpID0+IHtcblx0JFpvZFJlYWRvbmx5LmluaXQoaW5zdCwgZGVmKTtcblx0Wm9kVHlwZS5pbml0KGluc3QsIGRlZik7XG59KTtcbmZ1bmN0aW9uIHJlYWRvbmx5KGlubmVyVHlwZSkge1xuXHRyZXR1cm4gbmV3IFpvZFJlYWRvbmx5KHtcblx0XHR0eXBlOiBcInJlYWRvbmx5XCIsXG5cdFx0aW5uZXJUeXBlXG5cdH0pO1xufVxuY29uc3QgWm9kQ3VzdG9tID0gLyogQF9fUFVSRV9fICovICRjb25zdHJ1Y3RvcihcIlpvZEN1c3RvbVwiLCAoaW5zdCwgZGVmKSA9PiB7XG5cdCRab2RDdXN0b20uaW5pdChpbnN0LCBkZWYpO1xuXHRab2RUeXBlLmluaXQoaW5zdCwgZGVmKTtcbn0pO1xuZnVuY3Rpb24gY2hlY2soZm4pIHtcblx0Y29uc3QgY2ggPSBuZXcgJFpvZENoZWNrKHsgY2hlY2s6IFwiY3VzdG9tXCIgfSk7XG5cdGNoLl96b2QuY2hlY2sgPSBmbjtcblx0cmV0dXJuIGNoO1xufVxuZnVuY3Rpb24gcmVmaW5lKGZuLCBfcGFyYW1zID0ge30pIHtcblx0cmV0dXJuIF9yZWZpbmUoWm9kQ3VzdG9tLCBmbiwgX3BhcmFtcyk7XG59XG5mdW5jdGlvbiBzdXBlclJlZmluZShmbikge1xuXHRjb25zdCBjaCA9IGNoZWNrKChwYXlsb2FkKSA9PiB7XG5cdFx0cGF5bG9hZC5hZGRJc3N1ZSA9IChpc3N1ZSQxKSA9PiB7XG5cdFx0XHRpZiAodHlwZW9mIGlzc3VlJDEgPT09IFwic3RyaW5nXCIpIHBheWxvYWQuaXNzdWVzLnB1c2goaXNzdWUoaXNzdWUkMSwgcGF5bG9hZC52YWx1ZSwgY2guX3pvZC5kZWYpKTtcblx0XHRcdGVsc2Uge1xuXHRcdFx0XHRjb25zdCBfaXNzdWUgPSBpc3N1ZSQxO1xuXHRcdFx0XHRpZiAoX2lzc3VlLmZhdGFsKSBfaXNzdWUuY29udGludWUgPSBmYWxzZTtcblx0XHRcdFx0X2lzc3VlLmNvZGUgPz8gKF9pc3N1ZS5jb2RlID0gXCJjdXN0b21cIik7XG5cdFx0XHRcdF9pc3N1ZS5pbnB1dCA/PyAoX2lzc3VlLmlucHV0ID0gcGF5bG9hZC52YWx1ZSk7XG5cdFx0XHRcdF9pc3N1ZS5pbnN0ID8/IChfaXNzdWUuaW5zdCA9IGNoKTtcblx0XHRcdFx0X2lzc3VlLmNvbnRpbnVlID8/IChfaXNzdWUuY29udGludWUgPSAhY2guX3pvZC5kZWYuYWJvcnQpO1xuXHRcdFx0XHRwYXlsb2FkLmlzc3Vlcy5wdXNoKGlzc3VlKF9pc3N1ZSkpO1xuXHRcdFx0fVxuXHRcdH07XG5cdFx0cmV0dXJuIGZuKHBheWxvYWQudmFsdWUsIHBheWxvYWQpO1xuXHR9KTtcblx0cmV0dXJuIGNoO1xufVxuXG4vLyNlbmRyZWdpb25cbi8vI3JlZ2lvbiBzcmMvb3BlbmFwaS50c1xuY29uc3QgcGF0aHMgPSB7fTtcbmZ1bmN0aW9uIGdldFR5cGVGcm9tWm9kVHlwZSh6b2RUeXBlKSB7XG5cdHN3aXRjaCAoem9kVHlwZS5jb25zdHJ1Y3Rvci5uYW1lKSB7XG5cdFx0Y2FzZSBcIlpvZFN0cmluZ1wiOiByZXR1cm4gXCJzdHJpbmdcIjtcblx0XHRjYXNlIFwiWm9kTnVtYmVyXCI6IHJldHVybiBcIm51bWJlclwiO1xuXHRcdGNhc2UgXCJab2RCb29sZWFuXCI6IHJldHVybiBcImJvb2xlYW5cIjtcblx0XHRjYXNlIFwiWm9kT2JqZWN0XCI6IHJldHVybiBcIm9iamVjdFwiO1xuXHRcdGNhc2UgXCJab2RBcnJheVwiOiByZXR1cm4gXCJhcnJheVwiO1xuXHRcdGRlZmF1bHQ6IHJldHVybiBcInN0cmluZ1wiO1xuXHR9XG59XG5mdW5jdGlvbiBnZXRQYXJhbWV0ZXJzKG9wdGlvbnMpIHtcblx0Y29uc3QgcGFyYW1ldGVycyA9IFtdO1xuXHRpZiAob3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ucGFyYW1ldGVycykge1xuXHRcdHBhcmFtZXRlcnMucHVzaCguLi5vcHRpb25zLm1ldGFkYXRhLm9wZW5hcGkucGFyYW1ldGVycyk7XG5cdFx0cmV0dXJuIHBhcmFtZXRlcnM7XG5cdH1cblx0aWYgKG9wdGlvbnMucXVlcnkgaW5zdGFuY2VvZiBab2RPYmplY3QpIE9iamVjdC5lbnRyaWVzKG9wdGlvbnMucXVlcnkuc2hhcGUpLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuXHRcdGlmICh2YWx1ZSBpbnN0YW5jZW9mIFpvZE9iamVjdCkgcGFyYW1ldGVycy5wdXNoKHtcblx0XHRcdG5hbWU6IGtleSxcblx0XHRcdGluOiBcInF1ZXJ5XCIsXG5cdFx0XHRzY2hlbWE6IHtcblx0XHRcdFx0dHlwZTogZ2V0VHlwZUZyb21ab2RUeXBlKHZhbHVlKSxcblx0XHRcdFx0Li4uXCJtaW5MZW5ndGhcIiBpbiB2YWx1ZSAmJiB2YWx1ZS5taW5MZW5ndGggPyB7IG1pbkxlbmd0aDogdmFsdWUubWluTGVuZ3RoIH0gOiB7fSxcblx0XHRcdFx0ZGVzY3JpcHRpb246IHZhbHVlLmRlc2NyaXB0aW9uXG5cdFx0XHR9XG5cdFx0fSk7XG5cdH0pO1xuXHRyZXR1cm4gcGFyYW1ldGVycztcbn1cbmZ1bmN0aW9uIGdldFJlcXVlc3RCb2R5KG9wdGlvbnMpIHtcblx0aWYgKG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/LnJlcXVlc3RCb2R5KSByZXR1cm4gb3B0aW9ucy5tZXRhZGF0YS5vcGVuYXBpLnJlcXVlc3RCb2R5O1xuXHRpZiAoIW9wdGlvbnMuYm9keSkgcmV0dXJuIHZvaWQgMDtcblx0aWYgKG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFpvZE9iamVjdCB8fCBvcHRpb25zLmJvZHkgaW5zdGFuY2VvZiBab2RPcHRpb25hbCkge1xuXHRcdGNvbnN0IHNoYXBlID0gb3B0aW9ucy5ib2R5LnNoYXBlO1xuXHRcdGlmICghc2hhcGUpIHJldHVybiB2b2lkIDA7XG5cdFx0Y29uc3QgcHJvcGVydGllcyA9IHt9O1xuXHRcdGNvbnN0IHJlcXVpcmVkJDEgPSBbXTtcblx0XHRPYmplY3QuZW50cmllcyhzaGFwZSkuZm9yRWFjaCgoW2tleSwgdmFsdWVdKSA9PiB7XG5cdFx0XHRpZiAodmFsdWUgaW5zdGFuY2VvZiBab2RPYmplY3QpIHtcblx0XHRcdFx0cHJvcGVydGllc1trZXldID0ge1xuXHRcdFx0XHRcdHR5cGU6IGdldFR5cGVGcm9tWm9kVHlwZSh2YWx1ZSksXG5cdFx0XHRcdFx0ZGVzY3JpcHRpb246IHZhbHVlLmRlc2NyaXB0aW9uXG5cdFx0XHRcdH07XG5cdFx0XHRcdGlmICghKHZhbHVlIGluc3RhbmNlb2YgWm9kT3B0aW9uYWwpKSByZXF1aXJlZCQxLnB1c2goa2V5KTtcblx0XHRcdH1cblx0XHR9KTtcblx0XHRyZXR1cm4ge1xuXHRcdFx0cmVxdWlyZWQ6IG9wdGlvbnMuYm9keSBpbnN0YW5jZW9mIFpvZE9wdGlvbmFsID8gZmFsc2UgOiBvcHRpb25zLmJvZHkgPyB0cnVlIDogZmFsc2UsXG5cdFx0XHRjb250ZW50OiB7IFwiYXBwbGljYXRpb24vanNvblwiOiB7IHNjaGVtYToge1xuXHRcdFx0XHR0eXBlOiBcIm9iamVjdFwiLFxuXHRcdFx0XHRwcm9wZXJ0aWVzLFxuXHRcdFx0XHRyZXF1aXJlZDogcmVxdWlyZWQkMVxuXHRcdFx0fSB9IH1cblx0XHR9O1xuXHR9XG59XG5mdW5jdGlvbiBnZXRSZXNwb25zZShyZXNwb25zZXMpIHtcblx0cmV0dXJuIHtcblx0XHRcIjQwMFwiOiB7XG5cdFx0XHRjb250ZW50OiB7IFwiYXBwbGljYXRpb24vanNvblwiOiB7IHNjaGVtYToge1xuXHRcdFx0XHR0eXBlOiBcIm9iamVjdFwiLFxuXHRcdFx0XHRwcm9wZXJ0aWVzOiB7IG1lc3NhZ2U6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH0sXG5cdFx0XHRcdHJlcXVpcmVkOiBbXCJtZXNzYWdlXCJdXG5cdFx0XHR9IH0gfSxcblx0XHRcdGRlc2NyaXB0aW9uOiBcIkJhZCBSZXF1ZXN0LiBVc3VhbGx5IGR1ZSB0byBtaXNzaW5nIHBhcmFtZXRlcnMsIG9yIGludmFsaWQgcGFyYW1ldGVycy5cIlxuXHRcdH0sXG5cdFx0XCI0MDFcIjoge1xuXHRcdFx0Y29udGVudDogeyBcImFwcGxpY2F0aW9uL2pzb25cIjogeyBzY2hlbWE6IHtcblx0XHRcdFx0dHlwZTogXCJvYmplY3RcIixcblx0XHRcdFx0cHJvcGVydGllczogeyBtZXNzYWdlOiB7IHR5cGU6IFwic3RyaW5nXCIgfSB9LFxuXHRcdFx0XHRyZXF1aXJlZDogW1wibWVzc2FnZVwiXVxuXHRcdFx0fSB9IH0sXG5cdFx0XHRkZXNjcmlwdGlvbjogXCJVbmF1dGhvcml6ZWQuIER1ZSB0byBtaXNzaW5nIG9yIGludmFsaWQgYXV0aGVudGljYXRpb24uXCJcblx0XHR9LFxuXHRcdFwiNDAzXCI6IHtcblx0XHRcdGNvbnRlbnQ6IHsgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHsgc2NoZW1hOiB7XG5cdFx0XHRcdHR5cGU6IFwib2JqZWN0XCIsXG5cdFx0XHRcdHByb3BlcnRpZXM6IHsgbWVzc2FnZTogeyB0eXBlOiBcInN0cmluZ1wiIH0gfVxuXHRcdFx0fSB9IH0sXG5cdFx0XHRkZXNjcmlwdGlvbjogXCJGb3JiaWRkZW4uIFlvdSBkbyBub3QgaGF2ZSBwZXJtaXNzaW9uIHRvIGFjY2VzcyB0aGlzIHJlc291cmNlIG9yIHRvIHBlcmZvcm0gdGhpcyBhY3Rpb24uXCJcblx0XHR9LFxuXHRcdFwiNDA0XCI6IHtcblx0XHRcdGNvbnRlbnQ6IHsgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHsgc2NoZW1hOiB7XG5cdFx0XHRcdHR5cGU6IFwib2JqZWN0XCIsXG5cdFx0XHRcdHByb3BlcnRpZXM6IHsgbWVzc2FnZTogeyB0eXBlOiBcInN0cmluZ1wiIH0gfVxuXHRcdFx0fSB9IH0sXG5cdFx0XHRkZXNjcmlwdGlvbjogXCJOb3QgRm91bmQuIFRoZSByZXF1ZXN0ZWQgcmVzb3VyY2Ugd2FzIG5vdCBmb3VuZC5cIlxuXHRcdH0sXG5cdFx0XCI0MjlcIjoge1xuXHRcdFx0Y29udGVudDogeyBcImFwcGxpY2F0aW9uL2pzb25cIjogeyBzY2hlbWE6IHtcblx0XHRcdFx0dHlwZTogXCJvYmplY3RcIixcblx0XHRcdFx0cHJvcGVydGllczogeyBtZXNzYWdlOiB7IHR5cGU6IFwic3RyaW5nXCIgfSB9XG5cdFx0XHR9IH0gfSxcblx0XHRcdGRlc2NyaXB0aW9uOiBcIlRvbyBNYW55IFJlcXVlc3RzLiBZb3UgaGF2ZSBleGNlZWRlZCB0aGUgcmF0ZSBsaW1pdC4gVHJ5IGFnYWluIGxhdGVyLlwiXG5cdFx0fSxcblx0XHRcIjUwMFwiOiB7XG5cdFx0XHRjb250ZW50OiB7IFwiYXBwbGljYXRpb24vanNvblwiOiB7IHNjaGVtYToge1xuXHRcdFx0XHR0eXBlOiBcIm9iamVjdFwiLFxuXHRcdFx0XHRwcm9wZXJ0aWVzOiB7IG1lc3NhZ2U6IHsgdHlwZTogXCJzdHJpbmdcIiB9IH1cblx0XHRcdH0gfSB9LFxuXHRcdFx0ZGVzY3JpcHRpb246IFwiSW50ZXJuYWwgU2VydmVyIEVycm9yLiBUaGlzIGlzIGEgcHJvYmxlbSB3aXRoIHRoZSBzZXJ2ZXIgdGhhdCB5b3UgY2Fubm90IGZpeC5cIlxuXHRcdH0sXG5cdFx0Li4ucmVzcG9uc2VzXG5cdH07XG59XG5hc3luYyBmdW5jdGlvbiBnZW5lcmF0b3IoZW5kcG9pbnRzLCBjb25maWckMSkge1xuXHRjb25zdCBjb21wb25lbnRzID0geyBzY2hlbWFzOiB7fSB9O1xuXHRPYmplY3QuZW50cmllcyhlbmRwb2ludHMpLmZvckVhY2goKFtfLCB2YWx1ZV0pID0+IHtcblx0XHRjb25zdCBvcHRpb25zID0gdmFsdWUub3B0aW9ucztcblx0XHRpZiAoIXZhbHVlLnBhdGggfHwgb3B0aW9ucy5tZXRhZGF0YT8uU0VSVkVSX09OTFkpIHJldHVybjtcblx0XHRpZiAob3B0aW9ucy5tZXRob2QgPT09IFwiR0VUXCIpIHBhdGhzW3ZhbHVlLnBhdGhdID0geyBnZXQ6IHtcblx0XHRcdHRhZ3M6IFtcIkRlZmF1bHRcIiwgLi4ub3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8udGFncyB8fCBbXV0sXG5cdFx0XHRkZXNjcmlwdGlvbjogb3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8uZGVzY3JpcHRpb24sXG5cdFx0XHRvcGVyYXRpb25JZDogb3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ub3BlcmF0aW9uSWQsXG5cdFx0XHRzZWN1cml0eTogW3sgYmVhcmVyQXV0aDogW10gfV0sXG5cdFx0XHRwYXJhbWV0ZXJzOiBnZXRQYXJhbWV0ZXJzKG9wdGlvbnMpLFxuXHRcdFx0cmVzcG9uc2VzOiBnZXRSZXNwb25zZShvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5yZXNwb25zZXMpXG5cdFx0fSB9O1xuXHRcdGlmIChvcHRpb25zLm1ldGhvZCA9PT0gXCJQT1NUXCIpIHtcblx0XHRcdGNvbnN0IGJvZHkgPSBnZXRSZXF1ZXN0Qm9keShvcHRpb25zKTtcblx0XHRcdHBhdGhzW3ZhbHVlLnBhdGhdID0geyBwb3N0OiB7XG5cdFx0XHRcdHRhZ3M6IFtcIkRlZmF1bHRcIiwgLi4ub3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8udGFncyB8fCBbXV0sXG5cdFx0XHRcdGRlc2NyaXB0aW9uOiBvcHRpb25zLm1ldGFkYXRhPy5vcGVuYXBpPy5kZXNjcmlwdGlvbixcblx0XHRcdFx0b3BlcmF0aW9uSWQ6IG9wdGlvbnMubWV0YWRhdGE/Lm9wZW5hcGk/Lm9wZXJhdGlvbklkLFxuXHRcdFx0XHRzZWN1cml0eTogW3sgYmVhcmVyQXV0aDogW10gfV0sXG5cdFx0XHRcdHBhcmFtZXRlcnM6IGdldFBhcmFtZXRlcnMob3B0aW9ucyksXG5cdFx0XHRcdC4uLmJvZHkgPyB7IHJlcXVlc3RCb2R5OiBib2R5IH0gOiB7IHJlcXVlc3RCb2R5OiB7IGNvbnRlbnQ6IHsgXCJhcHBsaWNhdGlvbi9qc29uXCI6IHsgc2NoZW1hOiB7XG5cdFx0XHRcdFx0dHlwZTogXCJvYmplY3RcIixcblx0XHRcdFx0XHRwcm9wZXJ0aWVzOiB7fVxuXHRcdFx0XHR9IH0gfSB9IH0sXG5cdFx0XHRcdHJlc3BvbnNlczogZ2V0UmVzcG9uc2Uob3B0aW9ucy5tZXRhZGF0YT8ub3BlbmFwaT8ucmVzcG9uc2VzKVxuXHRcdFx0fSB9O1xuXHRcdH1cblx0fSk7XG5cdHJldHVybiB7XG5cdFx0b3BlbmFwaTogXCIzLjEuMVwiLFxuXHRcdGluZm86IHtcblx0XHRcdHRpdGxlOiBcIkJldHRlciBBdXRoXCIsXG5cdFx0XHRkZXNjcmlwdGlvbjogXCJBUEkgUmVmZXJlbmNlIGZvciB5b3VyIEJldHRlciBBdXRoIEluc3RhbmNlXCIsXG5cdFx0XHR2ZXJzaW9uOiBcIjEuMS4wXCJcblx0XHR9LFxuXHRcdGNvbXBvbmVudHMsXG5cdFx0c2VjdXJpdHk6IFt7IGFwaUtleUNvb2tpZTogW10gfV0sXG5cdFx0c2VydmVyczogW3sgdXJsOiBjb25maWckMT8udXJsIH1dLFxuXHRcdHRhZ3M6IFt7XG5cdFx0XHRuYW1lOiBcIkRlZmF1bHRcIixcblx0XHRcdGRlc2NyaXB0aW9uOiBcIkRlZmF1bHQgZW5kcG9pbnRzIHRoYXQgYXJlIGluY2x1ZGVkIHdpdGggQmV0dGVyIEF1dGggYnkgZGVmYXVsdC4gVGhlc2UgZW5kcG9pbnRzIGFyZSBub3QgcGFydCBvZiBhbnkgcGx1Z2luLlwiXG5cdFx0fV0sXG5cdFx0cGF0aHNcblx0fTtcbn1cbmNvbnN0IGdldEhUTUwgPSAoYXBpUmVmZXJlbmNlLCBjb25maWckMSkgPT4gYDwhZG9jdHlwZSBodG1sPlxuPGh0bWw+XG4gIDxoZWFkPlxuICAgIDx0aXRsZT5TY2FsYXIgQVBJIFJlZmVyZW5jZTwvdGl0bGU+XG4gICAgPG1ldGEgY2hhcnNldD1cInV0Zi04XCIgLz5cbiAgICA8bWV0YVxuICAgICAgbmFtZT1cInZpZXdwb3J0XCJcbiAgICAgIGNvbnRlbnQ9XCJ3aWR0aD1kZXZpY2Utd2lkdGgsIGluaXRpYWwtc2NhbGU9MVwiIC8+XG4gIDwvaGVhZD5cbiAgPGJvZHk+XG4gICAgPHNjcmlwdFxuICAgICAgaWQ9XCJhcGktcmVmZXJlbmNlXCJcbiAgICAgIHR5cGU9XCJhcHBsaWNhdGlvbi9qc29uXCI+XG4gICAgJHtKU09OLnN0cmluZ2lmeShhcGlSZWZlcmVuY2UpfVxuICAgIDxcXC9zY3JpcHQ+XG5cdCA8c2NyaXB0PlxuICAgICAgdmFyIGNvbmZpZ3VyYXRpb24gPSB7XG5cdCAgXHRmYXZpY29uOiAke2NvbmZpZyQxPy5sb2dvID8gYGRhdGE6aW1hZ2Uvc3ZnK3htbDt1dGY4LCR7ZW5jb2RlVVJJQ29tcG9uZW50KGNvbmZpZyQxLmxvZ28pfWAgOiB2b2lkIDB9ICxcblx0ICAgXHR0aGVtZTogJHtjb25maWckMT8udGhlbWUgfHwgXCJzYXR1cm5cIn0sXG4gICAgICAgIG1ldGFEYXRhOiB7XG5cdFx0XHR0aXRsZTogJHtjb25maWckMT8udGl0bGUgfHwgXCJPcGVuIEFQSSBSZWZlcmVuY2VcIn0sXG5cdFx0XHRkZXNjcmlwdGlvbjogJHtjb25maWckMT8uZGVzY3JpcHRpb24gfHwgXCJCZXR0ZXIgQ2FsbCBPcGVuIEFQSVwifSxcblx0XHR9XG4gICAgICB9XG4gICAgICBkb2N1bWVudC5nZXRFbGVtZW50QnlJZCgnYXBpLXJlZmVyZW5jZScpLmRhdGFzZXQuY29uZmlndXJhdGlvbiA9XG4gICAgICAgIEpTT04uc3RyaW5naWZ5KGNvbmZpZ3VyYXRpb24pXG4gICAgPFxcL3NjcmlwdD5cblx0ICA8c2NyaXB0IHNyYz1cImh0dHBzOi8vY2RuLmpzZGVsaXZyLm5ldC9ucG0vQHNjYWxhci9hcGktcmVmZXJlbmNlXCI+PFxcL3NjcmlwdD5cbiAgPC9ib2R5PlxuPC9odG1sPmA7XG5cbi8vI2VuZHJlZ2lvblxuLy8jcmVnaW9uIHNyYy9yb3V0ZXIudHNcbmNvbnN0IGNyZWF0ZVJvdXRlciA9IChlbmRwb2ludHMsIGNvbmZpZyQxKSA9PiB7XG5cdGlmICghY29uZmlnJDE/Lm9wZW5hcGk/LmRpc2FibGVkKSB7XG5cdFx0Y29uc3Qgb3BlbmFwaSA9IHtcblx0XHRcdHBhdGg6IFwiL2FwaS9yZWZlcmVuY2VcIixcblx0XHRcdC4uLmNvbmZpZyQxPy5vcGVuYXBpXG5cdFx0fTtcblx0XHRlbmRwb2ludHNbXCJvcGVuYXBpXCJdID0gY3JlYXRlRW5kcG9pbnQob3BlbmFwaS5wYXRoLCB7IG1ldGhvZDogXCJHRVRcIiB9LCBhc3luYyAoYykgPT4ge1xuXHRcdFx0Y29uc3Qgc2NoZW1hID0gYXdhaXQgZ2VuZXJhdG9yKGVuZHBvaW50cyk7XG5cdFx0XHRyZXR1cm4gbmV3IFJlc3BvbnNlKGdldEhUTUwoc2NoZW1hLCBvcGVuYXBpLnNjYWxhciksIHsgaGVhZGVyczogeyBcIkNvbnRlbnQtVHlwZVwiOiBcInRleHQvaHRtbFwiIH0gfSk7XG5cdFx0fSk7XG5cdH1cblx0Y29uc3Qgcm91dGVyID0gY3JlYXRlUm91dGVyJDEoKTtcblx0Y29uc3QgbWlkZGxld2FyZVJvdXRlciA9IGNyZWF0ZVJvdXRlciQxKCk7XG5cdGZvciAoY29uc3QgZW5kcG9pbnQgb2YgT2JqZWN0LnZhbHVlcyhlbmRwb2ludHMpKSB7XG5cdFx0aWYgKCFlbmRwb2ludC5vcHRpb25zIHx8ICFlbmRwb2ludC5wYXRoKSBjb250aW51ZTtcblx0XHRpZiAoZW5kcG9pbnQub3B0aW9ucz8ubWV0YWRhdGE/LlNFUlZFUl9PTkxZKSBjb250aW51ZTtcblx0XHRjb25zdCBtZXRob2RzID0gQXJyYXkuaXNBcnJheShlbmRwb2ludC5vcHRpb25zPy5tZXRob2QpID8gZW5kcG9pbnQub3B0aW9ucy5tZXRob2QgOiBbZW5kcG9pbnQub3B0aW9ucz8ubWV0aG9kXTtcblx0XHRmb3IgKGNvbnN0IG1ldGhvZCBvZiBtZXRob2RzKSBhZGRSb3V0ZShyb3V0ZXIsIG1ldGhvZCwgZW5kcG9pbnQucGF0aCwgZW5kcG9pbnQpO1xuXHR9XG5cdGlmIChjb25maWckMT8ucm91dGVyTWlkZGxld2FyZT8ubGVuZ3RoKSBmb3IgKGNvbnN0IHsgcGF0aCwgbWlkZGxld2FyZSB9IG9mIGNvbmZpZyQxLnJvdXRlck1pZGRsZXdhcmUpIGFkZFJvdXRlKG1pZGRsZXdhcmVSb3V0ZXIsIFwiKlwiLCBwYXRoLCBtaWRkbGV3YXJlKTtcblx0Y29uc3QgcHJvY2Vzc1JlcXVlc3QgPSBhc3luYyAocmVxdWVzdCkgPT4ge1xuXHRcdGNvbnN0IHVybCA9IG5ldyBVUkwocmVxdWVzdC51cmwpO1xuXHRcdGNvbnN0IHBhdGggPSBjb25maWckMT8uYmFzZVBhdGggPyB1cmwucGF0aG5hbWUuc3BsaXQoY29uZmlnJDEuYmFzZVBhdGgpLnJlZHVjZSgoYWNjLCBjdXJyLCBpbmRleCkgPT4ge1xuXHRcdFx0aWYgKGluZGV4ICE9PSAwKSBpZiAoaW5kZXggPiAxKSBhY2MucHVzaChgJHtjb25maWckMS5iYXNlUGF0aH0ke2N1cnJ9YCk7XG5cdFx0XHRlbHNlIGFjYy5wdXNoKGN1cnIpO1xuXHRcdFx0cmV0dXJuIGFjYztcblx0XHR9LCBbXSkuam9pbihcIlwiKSA6IHVybC5wYXRobmFtZTtcblx0XHRpZiAoIXBhdGg/Lmxlbmd0aCkgcmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG5cdFx0XHRzdGF0dXM6IDQwNCxcblx0XHRcdHN0YXR1c1RleHQ6IFwiTm90IEZvdW5kXCJcblx0XHR9KTtcblx0XHRjb25zdCByb3V0ZSA9IGZpbmRSb3V0ZShyb3V0ZXIsIHJlcXVlc3QubWV0aG9kLCBwYXRoKTtcblx0XHRpZiAoIXJvdXRlPy5kYXRhKSByZXR1cm4gbmV3IFJlc3BvbnNlKG51bGwsIHtcblx0XHRcdHN0YXR1czogNDA0LFxuXHRcdFx0c3RhdHVzVGV4dDogXCJOb3QgRm91bmRcIlxuXHRcdH0pO1xuXHRcdGNvbnN0IHF1ZXJ5ID0ge307XG5cdFx0dXJsLnNlYXJjaFBhcmFtcy5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG5cdFx0XHRpZiAoa2V5IGluIHF1ZXJ5KSBpZiAoQXJyYXkuaXNBcnJheShxdWVyeVtrZXldKSkgcXVlcnlba2V5XS5wdXNoKHZhbHVlKTtcblx0XHRcdGVsc2UgcXVlcnlba2V5XSA9IFtxdWVyeVtrZXldLCB2YWx1ZV07XG5cdFx0XHRlbHNlIHF1ZXJ5W2tleV0gPSB2YWx1ZTtcblx0XHR9KTtcblx0XHRjb25zdCBoYW5kbGVyID0gcm91dGUuZGF0YTtcblx0XHR0cnkge1xuXHRcdFx0Y29uc3QgYWxsb3dlZE1lZGlhVHlwZXMgPSBoYW5kbGVyLm9wdGlvbnMubWV0YWRhdGE/LmFsbG93ZWRNZWRpYVR5cGVzIHx8IGNvbmZpZyQxPy5hbGxvd2VkTWVkaWFUeXBlcztcblx0XHRcdGNvbnN0IGNvbnRleHQgPSB7XG5cdFx0XHRcdHBhdGgsXG5cdFx0XHRcdG1ldGhvZDogcmVxdWVzdC5tZXRob2QsXG5cdFx0XHRcdGhlYWRlcnM6IHJlcXVlc3QuaGVhZGVycyxcblx0XHRcdFx0cGFyYW1zOiByb3V0ZS5wYXJhbXMgPyBKU09OLnBhcnNlKEpTT04uc3RyaW5naWZ5KHJvdXRlLnBhcmFtcykpIDoge30sXG5cdFx0XHRcdHJlcXVlc3QsXG5cdFx0XHRcdGJvZHk6IGhhbmRsZXIub3B0aW9ucy5kaXNhYmxlQm9keSA/IHZvaWQgMCA6IGF3YWl0IGdldEJvZHkoaGFuZGxlci5vcHRpb25zLmNsb25lUmVxdWVzdCA/IHJlcXVlc3QuY2xvbmUoKSA6IHJlcXVlc3QsIGFsbG93ZWRNZWRpYVR5cGVzKSxcblx0XHRcdFx0cXVlcnksXG5cdFx0XHRcdF9mbGFnOiBcInJvdXRlclwiLFxuXHRcdFx0XHRhc1Jlc3BvbnNlOiB0cnVlLFxuXHRcdFx0XHRjb250ZXh0OiBjb25maWckMT8ucm91dGVyQ29udGV4dFxuXHRcdFx0fTtcblx0XHRcdGNvbnN0IG1pZGRsZXdhcmVSb3V0ZXMgPSBmaW5kQWxsUm91dGVzKG1pZGRsZXdhcmVSb3V0ZXIsIFwiKlwiLCBwYXRoKTtcblx0XHRcdGlmIChtaWRkbGV3YXJlUm91dGVzPy5sZW5ndGgpIGZvciAoY29uc3QgeyBkYXRhOiBtaWRkbGV3YXJlLCBwYXJhbXMgfSBvZiBtaWRkbGV3YXJlUm91dGVzKSB7XG5cdFx0XHRcdGNvbnN0IHJlcyA9IGF3YWl0IG1pZGRsZXdhcmUoe1xuXHRcdFx0XHRcdC4uLmNvbnRleHQsXG5cdFx0XHRcdFx0cGFyYW1zLFxuXHRcdFx0XHRcdGFzUmVzcG9uc2U6IGZhbHNlXG5cdFx0XHRcdH0pO1xuXHRcdFx0XHRpZiAocmVzIGluc3RhbmNlb2YgUmVzcG9uc2UpIHJldHVybiByZXM7XG5cdFx0XHR9XG5cdFx0XHRyZXR1cm4gYXdhaXQgaGFuZGxlcihjb250ZXh0KTtcblx0XHR9IGNhdGNoIChlcnJvcikge1xuXHRcdFx0aWYgKGNvbmZpZyQxPy5vbkVycm9yKSB0cnkge1xuXHRcdFx0XHRjb25zdCBlcnJvclJlc3BvbnNlID0gYXdhaXQgY29uZmlnJDEub25FcnJvcihlcnJvcik7XG5cdFx0XHRcdGlmIChlcnJvclJlc3BvbnNlIGluc3RhbmNlb2YgUmVzcG9uc2UpIHJldHVybiB0b1Jlc3BvbnNlKGVycm9yUmVzcG9uc2UpO1xuXHRcdFx0fSBjYXRjaCAoZXJyb3IkMSkge1xuXHRcdFx0XHRpZiAoaXNBUElFcnJvcihlcnJvciQxKSkgcmV0dXJuIHRvUmVzcG9uc2UoZXJyb3IkMSk7XG5cdFx0XHRcdHRocm93IGVycm9yJDE7XG5cdFx0XHR9XG5cdFx0XHRpZiAoY29uZmlnJDE/LnRocm93RXJyb3IpIHRocm93IGVycm9yO1xuXHRcdFx0aWYgKGlzQVBJRXJyb3IoZXJyb3IpKSByZXR1cm4gdG9SZXNwb25zZShlcnJvcik7XG5cdFx0XHRjb25zb2xlLmVycm9yKGAjIFNFUlZFUl9FUlJPUjogYCwgZXJyb3IpO1xuXHRcdFx0cmV0dXJuIG5ldyBSZXNwb25zZShudWxsLCB7XG5cdFx0XHRcdHN0YXR1czogNTAwLFxuXHRcdFx0XHRzdGF0dXNUZXh0OiBcIkludGVybmFsIFNlcnZlciBFcnJvclwiXG5cdFx0XHR9KTtcblx0XHR9XG5cdH07XG5cdHJldHVybiB7XG5cdFx0aGFuZGxlcjogYXN5bmMgKHJlcXVlc3QpID0+IHtcblx0XHRcdGNvbnN0IG9uUmVxID0gYXdhaXQgY29uZmlnJDE/Lm9uUmVxdWVzdD8uKHJlcXVlc3QpO1xuXHRcdFx0aWYgKG9uUmVxIGluc3RhbmNlb2YgUmVzcG9uc2UpIHJldHVybiBvblJlcTtcblx0XHRcdGNvbnN0IHJlcyA9IGF3YWl0IHByb2Nlc3NSZXF1ZXN0KG9uUmVxIGluc3RhbmNlb2YgUmVxdWVzdCA/IG9uUmVxIDogcmVxdWVzdCk7XG5cdFx0XHRjb25zdCBvblJlcyA9IGF3YWl0IGNvbmZpZyQxPy5vblJlc3BvbnNlPy4ocmVzKTtcblx0XHRcdGlmIChvblJlcyBpbnN0YW5jZW9mIFJlc3BvbnNlKSByZXR1cm4gb25SZXM7XG5cdFx0XHRyZXR1cm4gcmVzO1xuXHRcdH0sXG5cdFx0ZW5kcG9pbnRzXG5cdH07XG59O1xuXG4vLyNlbmRyZWdpb25cbmV4cG9ydCB7IEFQSUVycm9yLCBCZXR0ZXJDYWxsRXJyb3IsIGNyZWF0ZUVuZHBvaW50LCBjcmVhdGVJbnRlcm5hbENvbnRleHQsIGNyZWF0ZU1pZGRsZXdhcmUsIGNyZWF0ZVJvdXRlciwgZ2VuZXJhdG9yLCBnZXRDb29raWVLZXksIGdldEhUTUwsIGhpZGVJbnRlcm5hbFN0YWNrRnJhbWVzLCBtYWtlRXJyb3JGb3JIaWRlU3RhY2tGcmFtZSwgcGFyc2VDb29raWVzLCBzZXJpYWxpemVDb29raWUsIHNlcmlhbGl6ZVNpZ25lZENvb2tpZSwgc3RhdHVzQ29kZXMsIHRvUmVzcG9uc2UgfTtcbi8vIyBzb3VyY2VNYXBwaW5nVVJMPWluZGV4LmpzLm1hcCJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(rsc)/./node_modules/better-call/dist/index.js\n");

/***/ })

};
;